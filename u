#!/usr/bin/env perl
################################################################################
# Uniqki:	Unique Wiki <https://uniqki.isnew.info>
# Author:	Huidae Cho
# Since:	May 23, 2007
#
# Copyright (C) 2007-2008, 2010-2011, 2016-2019, Huidae Cho
# <https://idea.isnew.info>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
################################################################################
use strict;

# The document root directory relative to the server's URL including /~user, if
# any.  For example, if the full URL path to index.html is
# http://example.com/~user/index.html, $doc_root should be set to ".".  Leave
# it blank if you can run this script outside of the cgi-bin directory.
my $doc_root = "";

# Temporary admin user: admin, password: admin.  DO NOT CHANGE THIS VARIABLE.
my $tmp_adminpw = 'admin:7352327a53727a65613d7a4cb055d722c21f1a0f17ad676daccd4ad8bf728134c9ee739e5f51c9af822da15b69985908148c55b6fdea4bc0bcd5aff660a53db428a9898c12743c7d:admin:@:Administrator:';
# Running this script for the first time will create the password file u.pw
# using the $adminpw credential, which is set to $tmp_adminpw by default.
# Since this password is public, make sure to change the admin password after
# the first login to update the password file.  If $adminpw in the following
# line is not the same as $tmp_adminpw, Uniqki will assume that you have
# changed $adminpw to remove the password file and use this script instead for
# login, and will not create the password file again.  Using this feature, it
# is possible to operate a Uniqki site with this file alone by removing the
# password file after setting the $adminpw variable to your new credential in
# u.pw.  Make sure to back up this variable when updating the script.
# Optionally, you can create u.cfg and template files in u.tpl by running
# u?install_config and u?install_template, respectively, but these files are
# only used for customizations and are not required.
my $adminpw = $tmp_adminpw;

################################################################################
# HTTP server environment variables
use vars qw(
	$CFG
	$HTTPS $HTTP_COOKIE $HTTP_HOST $SERVER_NAME $SCRIPT_NAME $PATH_INFO
	$QUERY_STRING $REQUEST_METHOD $CONTENT_TYPE $CONTENT_LENGTH $REMOTE_ADDR
);

# Useful variables
use vars qw(
	$HTTP_BASE $DOC_BASE $CGI $PAGE $FILE $USER $NAME $AUTHOR
);

# Template variables
use vars qw(
	$TITLE $TEXT $START $COUNT $PREVIEW $VERSION $TIME
	$PASSWORD_RESET_TOKEN $MESSAGE $PARSING_TIME
);

# Config and messages variables
use vars qw(
	$SITE_TITLE $SITE_DESCRIPTION $INDEX_PAGE $LANG $CHARSET $LOCALE
	$TIME_ZONE $TIME_FORMAT
	$SHARE_COOKIES
	$PASSWORD_FILE $SESSIONS_FILE $MESSAGES_FILE $TEMPLATE_DIRECTORY
	$PAGE_NAME_STYLE
	$SECTION_NUMBER_PREFIX $SECTION_NUMBER_SEPARATOR $SECTION_NUMBER_SUFFIX
	$SECTION_REFERENCE_PREFIX $SECTION_REFERENCE_SUFFIX
	$TABLE_NUMBER_PREFIX $TABLE_NUMBER_SUFFIX
	$TABLE_REFERENCE_PREFIX $TABLE_REFERENCE_SUFFIX
	$FIGURE_NUMBER_PREFIX $FIGURE_NUMBER_SUFFIX
	$FIGURE_REFERENCE_PREFIX $FIGURE_REFERENCE_SUFFIX
	$INACTIVE_TIMEOUT $SET_PASSWORD_TIMEOUT $RESET_PASSWORD_TIMEOUT
	$EMAIL_ADDRESS $SMTP $MIME_TYPE_COMMAND
	$READ_ACCESS $WRITE_ACCESS
	$PAGES_NOT_ALLOWED
	$USER_PARSERS_FILE
	$HEADER_FILE $FOOTER_FILE
	$NONWIKI_HEADER_FILE $NONWIKI_FOOTER_FILE
	$WIKI_HEADER_FILE $WIKI_FOOTER_FILE
	$WIKI_PAGES_ALLOWED $WIKI_FILES_ALLOWED
	$MINIMUM_COMMENT_TIME

	%MESSAGES
);

# parse_file() global variables
use vars qw(
	@begin_parsing
	@parse_line
	@end_parsing
	@process_raw_block
	@preprocess_line
	@process_block
	@process_asis_lines
	@skip_comment
	@process_wiki_command
	@process_nonwiki_command
	@skip_unknown_command
	@start_block
	@process_collected_lines
	@process_paragraph_break
	@escape_inline_syntax
	@process_inline_syntax
	@collect_lines
	@process_line_syntax
	@start_paragraph
	@postprocess_line
	@close_all_open
);

# parse_file() local variables
use vars qw(
	$lineno $text $url_char $url_punct $fresh_block $code_block
	$syntax_block @parsed_blocks $re_block $re_start $re_n @re @re_sub $p
	$asis $nosyntax $pre $pre_code $blockquote $list $table $figure
	@h_lines %h_n $h_top $h_prev %h_secs %secs_no $toc $toc_dep $tab_no
	%tabs_n %tabs $lot $nolot $fig_no %figs_n %figs $lof $nolof
);

# Other global variables
use vars qw(
	$preprocess_text
	$verify_input
	$preview
	$wiki
	$html_started
	$header_printed $footer_printed
);

umask 022;

my $win = $^O eq "MSWin32" ? 1 : 0;
eval "use Time::HiRes";
my $show_parsing_time = $@ ? 0 : 1;

if(!defined $ENV{GATEWAY_INTERFACE}){
	my $cmd = "";
	my %opt;
	for(my $i = 0; $i <= $#ARGV; $i++){
		if("-" eq substr $ARGV[$i], 0, 1){
			my $name = substr $ARGV[$i], 1;
			if($name eq "p" || $name eq "c" || $name eq "k" ||
			   $name eq "i" || $name eq "f"){
				die "$ARGV[$i] option requires a value"
					if $i + 1 > $#ARGV;
				$opt{$name} = $ARGV[++$i];
			}else{
				$opt{$name} = 1;
			}
		}elsif($cmd eq ""){
			$cmd = $ARGV[$i];
		}else{
			die "Provide only one command";
		}
	}
	if($opt{p} ne "" && $opt{p} !~ /^[0-9]+$/){
		die "Port must be a number";
	}
	if($opt{p} eq ""){
		$opt{p} = $opt{c} eq "" ? 80 : 443;
	}
	if($opt{c} ne "" && !-f $opt{c}){
		die "$opt{c}: File not found";
	}
	if($opt{k} ne "" && !-f $opt{k}){
		die "$opt{k}: File not found";
	}
	if(($opt{c} eq "" && $opt{k} ne "") ||
	   ($opt{c} ne "" && $opt{k} eq "")){
		die "Both cert and key files must be specified";
	}
	if($opt{i} eq ""){
		$opt{i} = "index.html";
	}
	if($opt{f} eq ""){
		$opt{f} = '(?:^u\.(?:cfg|pw|msg|pid|log)|^\.sessions|\.(?:tpl|txt|txt\.v))$';
	}
	if($opt{r} && $opt{s}){
		die "-r and -s are mutually exclusive";
	}
	my $u = $0;
	if($u =~ m#^(.*)[\\/](.+)#){
		chdir $1;
		$u = $2;
	}
	my $pid_file = "u.pid";
	my $log_file = "u.log";
	my $foreground = 0;

	sub logger{
		my @msg = @_;

		local *FH;
		open FH, ">>$log_file";
		printf FH @msg;
		close FH;

		printf @msg if $foreground;
	}

	sub die_logger{
		logger @_;
		die;
	}

	sub get_pid{
		return 0 unless -f $pid_file;

		local *FH;
		open FH, $pid_file;
		my $pid = <FH>;
		close FH;
		chomp $pid;

		my $alive = kill 0, $pid;
		unlink $pid_file unless $alive;

		return $alive ? $pid : 0;
	}

	sub stop_server{
		my $pid = get_pid();
		if($pid > 0){
			kill 9, $pid;
			logger "Stopped by the user.\n";
		}
		unlink $pid_file;
	}

	sub respond_error{
		my ($client, $code_msg) = @_;
		(my $msg = $code_msg) =~ s/^[0-9]+ //;

		logger "$code_msg\n\n";
		select $client;
		print "HTTP/1.1 $code_msg\n";
		print "Content-Type: text/plain\n\n";
		print "$msg\n";
	}

	sub respond_location{
		my ($client, $url) = @_;
		logger "Redirecting to $url...\n\n";
		select $client;
		print "HTTP/1.1 302 Found\n";
		print "Location: $url\n\n";
	}

	sub respond_file{
		my ($client, $file) = @_;
		logger "Sending $file...\n\n";
		my $mime_type = get_mime_type($file);
		select $client;
		print "HTTP/1.1 200 OK\n";
		print "Content-Type: $mime_type\n\n";

		local *FH;
		open FH, $file;
		binmode FH;
		print <FH>;
		close FH;
	}

	if($cmd eq "start" || $cmd eq "restart"){
################################################################################
# Tiny HTTP server to self-serve Uniqki
		my $pid;
		unless($win){
			$pid = get_pid();
			if($pid > 0){
				if($cmd eq "start"){
					die "Process $pid is still running";
				}else{
					stop_server();
				}
			}
		}

		$ENV{GATEWAY_INTERFACE} = "CGI/1.1";
		eval "use IO::Socket::INET;1" or
			die "The IO::Socket::INET module is required to self-serve Uniqki";

		my $server = IO::Socket::INET->new(
			Proto=>"tcp",
			LocalPort=>$opt{p},
			Listen=>SOMAXCONN(),
			Reuse=>1) || die "Cannot create a socket";

		if($opt{c} ne ""){
			$ENV{HTTPS} = "on";
			eval "use IO::Socket::SSL;1" or
				die "The IO::Socket::SSL module is required to self-serve Uniqki";
		}else{
			$ENV{HTTPS} = "off";
		}

		if($win){
			print "Close this window to terminate the service.\n";
			$foreground = 1;
		}else{
			$pid = fork();
			# $pid > 0 on Unix: Background process
			# $pid < 0 on Windows: Multi-threaded
			if(defined $pid && $pid > 0){
				# Parent of successful fork on Unix
				local *FH;
				print "Running in the background. Kill process $pid later to terminate the service.\n";
				print "The process ID $pid is stored in $pid_file.\n";
				print "Log messages are being written to $log_file.\n";

				open FH, ">$pid_file";
				print FH "$pid\n";
				close FH;
				exit;
			}elsif(!defined $pid){
				# Unsuccessful fork
				print "Cannot fork the server. Running in the foreground.\n";
				$foreground = 1;
			} # else child of successful fork on Unix
		}
		while(my $client = $server->accept()){
			$pid = fork();
			die_logger "Cannot fork the client.\n"
				unless defined $pid;
			if($pid){
				# Parent closes the client and listens again
				close $client;
				next;
			}
			if($opt{c} ne ""){
				IO::Socket::SSL->start_SSL($client,
					SSL_server=>1,
					SSL_cert_file=>$opt{c},
					SSL_key_file=>$opt{k}) ||
				die_logger "Failed to SSL handshake.\n";
			}
			$client->autoflush(1);
			$ENV{REMOTE_ADDR} = $client->peerhost();
			logger "========== %s ==========\n", scalar localtime;
			logger "Request from %s\n", $ENV{REMOTE_ADDR};

			while(<$client>){
				logger $_;
				s/\r\n//;
				if(m#^([A-Z]+) (.*?)(?:\?(.*))? HTTP\/[0-9.]+$#){
					$ENV{REQUEST_METHOD} = $1;
					$ENV{REQUEST_URI} = $2;
					$ENV{QUERY_STRING} = $3;
				}elsif(/^([^:]+): (.*)$/){
					my $field = uc $1;
					if($field eq "HOST"){
						$ENV{HTTP_HOST} = $2;
						($ENV{SERVER_NAME} = $2) =~ s/:[0-9]+$//;
					}elsif($field eq "CONTENT-TYPE"){
						$ENV{CONTENT_TYPE} = $2;
					}elsif($field eq "CONTENT-LENGTH"){
						$ENV{CONTENT_LENGTH} = $2;
					}elsif($field eq "COOKIE"){
						$ENV{HTTP_COOKIE} = $2;
					}
				}elsif($_ eq ""){
					last;
				}
			}

			logger "Processing $ENV{REQUEST_URI}...\n";

			$ENV{REQUEST_URI} =~ s#^/+#/#;
			(my $request_uri = $ENV{REQUEST_URI}) =~ s#^/##;
			my $request_file = $request_uri eq "" ? $opt{i} :
				decode_url($request_uri);
			if(($ENV{REQUEST_METHOD} ne "GET" &&
			    $ENV{REQUEST_METHOD} ne "POST") ||
			   "/" ne substr($ENV{REQUEST_URI}, 0, 1) ||
			   ($ENV{REQUEST_METHOD} eq "POST" &&
			    $request_uri !~ m#^$u(?:/.*)?$#)){
				respond_error($client, "400 Bad Request");
			}elsif(($win &&
			   (($opt{c} ne "" && lc $request_file eq lc $opt{c}) ||
			    ($opt{k} ne "" && lc $request_file eq lc $opt{k}) ||
			    $request_file =~ /$opt{f}/i)) ||
				(!$win &&
				 (($opt{c} ne "" && $request_file eq $opt{c}) ||
				  ($opt{k} ne "" && $request_file eq $opt{k}) ||
				  $request_file =~ /$opt{f}/))){
				respond_error($client, "403 Forbidden");
			}elsif($request_uri =~ m#^$u(/.*)?$#){
				logger "Executing $u...\n\n";

				$ENV{SCRIPT_NAME} = "/$u";
				$ENV{PATH_INFO} = decode_url($1);

				*STDIN = $client
					if $ENV{REQUEST_METHOD} eq "POST";
				local *OUTPUT;
				my $output;
				open OUTPUT, ">", \$output;
				select OUTPUT;
				do $u;
				close OUTPUT;

				select $client;
				my @items = split /\n\n/, $output;
				if($items[0] =~ /^Location: /m){
					print "HTTP/1.1 302 Found\n";
				}else{
					print "HTTP/1.1 200 OK\n";
				}
				print $output;
			}elsif($opt{r} && ".html" eq substr($request_file, -5)
				&& !-f $request_file){
				my $url = "/$u/".substr($request_uri, 0,
					length($request_uri) - 5);
				respond_location($client, $url);
			}elsif($opt{r} && ".html" ne substr($request_file, -5)
				&& -f "$request_file.html"){
				my $url = "/$request_uri.html";
				respond_location($client, $url);
			}elsif($opt{s}){
				(my $page = $request_uri) =~ s/\.html$//;
				my $url = "/$u";
				$url .= "/$page" if $page ne "";
				respond_location($client, $url);
			}elsif(-f $request_file){
				respond_file($client, $request_file);
			}else{
				respond_error($client, "404 Not Found");
			}
			close $client;
			exit;
		}
		exit;
	}elsif($cmd eq "stop"){
		stop_server();
		exit;
	}elsif($cmd eq "password"){
		eval "use Digest::HMAC_SHA1 qw(hmac_sha1);1" or
			die "The Digest::HMAC_SHA1 module is required to hash passwords";
		printf "my \$tmp_adminpw = 'admin:%s:admin:\@:Administrator:';\n", hash_password("admin", "admin");
		exit;
	}
	print <<EOT;
Usage: $u COMMAND [OPTIONS]
  start		     Start the server
    -p <port>	     Port number (default: 80 for HTTP and 443 for HTTPS)
    -c <cert.pem>    SSL certificate file
    -k <key.pem>     SSL key file
    -i <index.html>  Index HTML
    -f <forbidden>   Regular expression for forbidden files (default:
		     (^u\\.(cfg|pw|msg|pid|log)|^\\.sessions|\\.(tpl|txt|txt\\.v))\$)
    -r		     Redirect non-existing HTML requests to $u and non-HTML
		     requests to existing HTML files
    -s		     Secure the server by redirecting all requests to $u; Any
		     of \$READ_ACCESS or \$WRITE_ACCESS must be closed to avoid
		     infinite redirections
EOT
	unless($win){
		print <<EOT;
  restart	     Restart the server
  stop		     Stop the server
EOT
	}
	print <<EOT;
  password	     Print a new admin password hash

Please run this script from a web browser or with one of the above commands.
EOT
	exit;
}

################################################################################
# CGI variables
$CFG = $ENV{HTTP_UNIQKI_CONFIG};
$HTTPS = $ENV{HTTPS};
$HTTP_COOKIE = $ENV{HTTP_COOKIE};
$HTTP_HOST = $ENV{HTTP_HOST};
$SERVER_NAME = $ENV{SERVER_NAME};
$SCRIPT_NAME = $ENV{SCRIPT_NAME};
$PATH_INFO = $ENV{PATH_INFO};
$QUERY_STRING = $ENV{QUERY_STRING};
$REQUEST_METHOD = $ENV{REQUEST_METHOD};
$CONTENT_TYPE = $ENV{CONTENT_TYPE};
$CONTENT_LENGTH = $ENV{CONTENT_LENGTH};
$REMOTE_ADDR = $ENV{REMOTE_ADDR};

################################################################################
# Useful variables
# Supported URLs:
# This script outside cgi-bin: $doc_root = ""
# * https?://host/~user/dir/u/page/path/to/file?query
#   * CGI: u
#   * DOC_BASE: https?://host/~user/dir
# This script inside cgi-bin: $doc_root != ""
# * https?://host/~user/cgi-bin/u/page/path/to/file?query
#   * CGI: /~user/cgi-bin/u
#   * DOC_BASE: https?://host/~user/doc_root
# * HTTP_BASE: https?://host
# * PAGE: page
# * FILE: path/to/file
$CGI = $SCRIPT_NAME;
$HTTP_BASE = ($HTTPS eq "on" ? "https" : "http")."://$HTTP_HOST";
$DOC_BASE = "$HTTP_BASE$CGI"; $DOC_BASE =~ s#/[^/]*$##;
$PAGE = substr $PATH_INFO, 1; $PAGE =~ s#/.*$##;
$PAGE =~ s#\.(?:html|txt|txt\.v)$##;
$FILE = $PATH_INFO; $FILE =~ s#^/[^/]+##; $FILE =~ s#^/##;

################################################################################
# Awardspace.com free web hosting
my $hosting = "";
if(-d "/home/www/$SERVER_NAME"){
	$hosting = "awardspace";
	$_ = "/home/www/$SERVER_NAME$SCRIPT_NAME";
	s#/[^/]*$##;
	chdir $_;
}
if($doc_root eq ""){
	$CGI =~ s#^.*/##;
}else{
	($_ = $CGI) =~ s#/[^/]+$##;
	s#^/~[^/]+##;
	if($_ eq ""){
		chdir $doc_root;
	}else{
		s#^/##; s#[^/]+#..#g;
		chdir "$_/$doc_root";
	}
	$DOC_BASE = $HTTP_BASE.($CGI =~ m#(^/~[^/]+)# ? $1 : "")."/$doc_root";
}

################################################################################
# Prepare the default parser
prepare_parser();

################################################################################
# Read the config file
process_cfg();
$INDEX_PAGE = "index" if $INDEX_PAGE eq "";
if($TIME_ZONE ne ""){
	if($TIME_ZONE =~ /^gmt([+-])([0-9]+)$/i){
		$TIME_ZONE = "GMT".($1 eq "+" ? "-" : "+").$2;
	}
	$ENV{TZ} = $TIME_ZONE;
}

eval "use POSIX qw(setlocale LC_ALL tzset strftime);";
my $use_posix = $@ ? 0 : 1;
if($use_posix){
	setlocale(LC_ALL(), $LOCALE) if $LOCALE ne "";
	tzset() if $TIME_ZONE ne "";
	$TIME_FORMAT =~ s/%e/%#d/g if $win;
}

my $smtp_server = "";
my $smtp_port;
my $smtp_username;
my $smtp_password;
if($SMTP =~ /^([a-z0-9.-]+\.[a-z]{2,}):([0-9]*):([^:]*):(.*)$/i){
	$smtp_server = $1;
	$smtp_port = $2;
	$smtp_username = $3;
	$smtp_password = $4;
}

my ($page_name_case, $page_name_dots, $page_name_spaces) =
	config_page_name_style();
my ($nonwiki_read_access, $wiki_read_access) = config_access($READ_ACCESS);
my ($nonwiki_comment_access, $wiki_write_access) = config_access($WRITE_ACCESS);

################################################################################
# Messages
process_msg();

################################################################################
# hmac_sha1 subroutine for password hashing
eval "use Digest::HMAC_SHA1 qw(hmac_sha1);1" or
	die_message("perl_module_not_installed", "Digest::HMAC_SHA1");

################################################################################
# Initialization
$USER = "";
$NAME = "Visitor";
my $admin = 0;
my $rebuild = 0;
my $insecure_pw = 1;
my $sessions_file = $SESSIONS_FILE eq "" ? ".sessions" : $SESSIONS_FILE;
my $debug_started = 0;
my %locked_files = ();
my $cookie_attributes = get_cookie_attributes();
my $strip_query_string = 1;

################################################################################
# Non-user-replaceable subroutines
sub debug{
	my $msg = shift;
	unless($debug_started){
		$debug_started = 1;
		print "Content-Type: text/plain\n\n";
	}
	printf "%s\n", $msg;
}

sub format_time{
	my $time = shift;
	my $ftime;
	if($use_posix && $TIME_FORMAT ne ""){
		$ftime = strftime($TIME_FORMAT, localtime $time);
	}else{
		$ftime = scalar localtime $time;
	}
	return $ftime;
}

sub config_page_name_style{
	my ($case, $dots, $spaces);

	foreach my $item (split /:/, $PAGE_NAME_STYLE){
		if("_case" eq substr $item, -5){
			$case = $item;
			if($case eq "lower_camel_case"){
				$dots = "no_dots";
				$spaces = "no_spaces";
			}elsif($case eq "upper_camel_case"){
				$case = "start_case";
				$dots = "no_dots";
				$spaces = "no_spaces";
			}
		}elsif("dots" eq substr $item, -4){
			$dots = $item;
		}else{
			$spaces = $item;
		}
	}

	if($case ne "upper_case" && $case ne "mixed_case" &&
	   $case ne "start_case" && $case ne "lower_camel_case" &&
	   $case ne "upper_camel_case"){
		# default lower_case
		$case = "lower_case";
	}

	if($dots ne "no_dots"){
		# default dots
		$dots = "dots";
	}
	if($spaces ne "no_spaces" && $spaces ne "underscores"){
		# default hyphens
		$spaces = "hyphens";
	}
	return ($case, $dots, $spaces);
}

sub config_access{
	my $access = shift;
	my @items = split /:/, $access;
	my $nonwiki_access = $items[0] ne "open" && $items[0] ne "closed" ?
		"admin" : $items[0];
	my $wiki_access = index($access, ":") == -1 ?
		$nonwiki_access :
		($items[1] ne "open" && $items[1] ne "closed" ?
			"admin" : $items[1]);
	return ($nonwiki_access, $wiki_access);
}

sub run_file_mime_type{
	my $file = shift;
	return "" if $MIME_TYPE_COMMAND eq "" || !-f $file;
	(my $mime_type = `$MIME_TYPE_COMMAND $file`) =~ y/\r\n//d;
	return $mime_type;
}

sub get_mime_type{
	my $file = shift;
	return "" unless -f $file;
	my $mime_type;
	eval "use MIME::Types;";
	if($@){
		$mime_type = run_file_mime_type($file);
	}else{
		$mime_type = MIME::Types->new(only_iana=>1)->mimeTypeOf($file);
		$mime_type = run_file_mime_type($file) if $mime_type eq "";
	}
	$mime_type = "application/octet-stream" if $mime_type eq "";
	return $mime_type;
}

sub die_path{
	my $path = shift;
	die_message("path_not_found", $path) unless -e $path;

	if(-d $path){
		my $parent = "$path/" if($path !~ s#/+$##);
		my $title = get_msg("page_files", $path);
		(local $TITLE = $title) =~ s/<[^>]*>//g;
		print_header();
		print qq(<div id="list">\n<h1>$title</h1>\n<ul>\n);
		foreach(<$path/*>){
			my $file = $_;
			s#^[^/]*/##;
			my $url = $parent.encode_url_safe($_);
			s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g;
			my $name = $_;
			my @t = localtime((stat $file)[9]);
			my $time = sprintf "%d-%02d-%02d %02d:%02d:%02d",
				$t[5]+1900, $t[4]+1, $t[3], $t[2], $t[1], $t[0];
			print qq(<li><a href="$url">$name</a> <span class="list-time">$time</span></li>\n);
		}
		print qq(</ul></div>\n);
		print_footer();
		die;
	}

	my $mime_type = get_mime_type($path);
	(my $file = $path) =~ s#^.*/##;
	print <<EOT;
Content-Type: $mime_type
Content-Disposition: inline; filename="$file"

EOT
	local *FH;
	open FH, $path;
	print <FH>;
	close FH;
	die;
}

sub die_message{
	local $MESSAGE = get_msg(@_);
	(local $TITLE = $MESSAGE) =~ s/<[^>]*>//g;
	print_message();
	die;
}

sub die_rebuild{
	my $PAGE = shift;
	if(-f "$PAGE.txt"){
		make_html($PAGE);
		die_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE");
	}
	die_redirect("$HTTP_BASE$SCRIPT_NAME/$INDEX_PAGE");
}

sub die_redirect{
	printf "Location: %s\n\n", shift;
	die;
}

sub die_text{
	print "Content-Type: text/plain\n\n";
	print shift;
	die;
}

sub start_html{
	return if $html_started;
	$html_started = 1;
	print "Content-Type: text/html\n\n";
}

sub convert_page_name{
	my $page_name = shift;
	my $forbidden_chars = q(`~!@#\$%^&*=+\\\\|;:'",\/?()\[\]{}<>);

	# from parse_line
	# escaped html codes
	$page_name =~ s/(\x00?&[^;]*;)+/ /g;
	$page_name =~ y/\x01/&/;
	$page_name =~ y/\x02/</;
	$page_name =~ y/\x03/>/;

	$page_name =~ s/[$forbidden_chars \t_-]+/ /og;
	if($page_name_dots eq "dots"){
		$page_name =~ s/\.+/./g;
		$page_name =~ s/(?:\.? \.?)+/ /g;
	}else{
		$page_name =~ y/.//d;
		$page_name =~ s/ +/ /g;
	}
	# Allow page names starting with a dot
	$page_name =~ s/^ |[. ]$//g;
	return "" if $page_name eq "";

	if($page_name_case eq "mixed_case"){
		# case as is
	}elsif($page_name_case eq "upper_case"){
		$page_name = uc $page_name;
	}elsif($page_name_case eq "start_case"){
		$page_name =~ s/(?:^|(?<=[ .]))([^ .])([^ .]*)/@{[(uc $1).(lc $2)]}/g;
	}elsif($page_name_case eq "lower_camel_case"){
		$page_name =~ s/^([^ .]*)/@{[lc $1]}/;
		$page_name =~ s/(?<=[ .])([^ .])([^ .]*)/@{[(uc $1).(lc $2)]}/g;
	}else{
		# default: lower_case
		$page_name = lc $page_name;
	}

	if($page_name_spaces eq "no_spaces"){
		$page_name =~ y/ //d;
	}elsif($page_name_spaces eq "underscores"){
		$page_name =~ y/ /_/;
	}else{
		# default: hyphens
		$page_name =~ y/ /-/;
	}

	return $page_name;
}

sub unescape_comment{
	my $text = shift;
	$text =~ y/\x00//d;
	return $text;
}

sub escape_comment{
	my $text = shift;
	$text =~ s/^([#%])/\x00$1/mg;
	$text =~ s/``(.*?)``/`\x00`$1`\x00`/g;
	$text =~ s/^(---+)$/\x00$1/mg;
	$text =~ s/^\x00(---+)\n(.*?)\n\x00\1$/$1\n@{[unescape_comment($2)]}\n$1/smg;
	$text =~ s/\x00/''''/g;
	return $text;
}

sub link_page{
	my ($page, $section, $title) = @_;

	$page =~ s/^[ \t]+|[ \t]+$//g;
	$section =~ s/^[ \t]+|[ \t]+$//g;
	$title =~ s/^[ \t]+|[ \t]+$//g;

	my $enc_page = encode_url_safe(convert_page_name($page));
	my $enc_section = encode_url_safe(convert_page_name($section));

	if($enc_page eq ""){
		return "" if $enc_section eq "";
		return qq(<a class="auto-title" href="#$enc_section">$section</a>) if $title eq "";
		return qq(<a href="#$enc_section">$title</a>);
	}
	if($enc_section eq ""){
		return qq(<a class="auto-title" href="$enc_page.html">$page</a>) if $title eq "";
		return qq(<a href="$enc_page.html">$title</a>);
	}
	return qq(<a class="auto-title" href="$enc_page.html#$enc_section">$section</a>) if $title eq "";
	return qq(<a href="$enc_page.html#$enc_section">$title</a>);
}

sub link_image{
	# file: current page's file
	# ./file: current page's file
	# page/file: page's file
	# /file: DOC_BASE's file
	my ($path, $title, $style) = @_;

	$path =~ s/^[ \t]+|[ \t]+$//g;
	$title =~ s/^[ \t]+|[ \t]+$//g;
	$style =~ s/^[ \t]+|[ \t]+$//g;
	return "" if $path eq "." || $path eq "";

	$style = qq( style="$style") if $style ne "";

	my $page = $PAGE;
	my $file = "";

	my $i = rindex($path, "/");
	if($i >= 0){
		my $p = substr $path, 0, $i;
		if($p eq ""){
			# /file
			$page = ".";
		}elsif($p ne "."){
			# page/file
			$page = convert_page_name($p);
			return "" if $page eq "";
		}
		# else ./file
		$file = substr $path, $i + 1;
		return "" if $file eq "";
	}else{
		# file
		$file = $path;
	}

	my $enc_path = encode_url_safe("$page/$file");
	return qq(<img class="auto-title" src="$enc_path" alt="$file" title="$file"$style />) if $title eq "";
	return qq(<img src="$enc_path" alt="$title" title="$title"$style />);
}

sub link_file{
	# .: current page's directory
	# ./: current page's directory
	# file: current page's file
	# ./file: current page's file
	# page/: page's directory
	# page/file: page's file
	# /: DOC_BASE
	# /file: DOC_BASE's file
	my ($path, $title) = @_;

	$path =~ s/^[ \t]+|[ \t]+$//g;
	$title =~ s/^[ \t]+|[ \t]+$//g;

	my $page = $PAGE;
	my $file = "";

	my $i = rindex($path, "/");
	if($i >= 0){
		my $p = substr $path, 0, $i;
		if($p eq ""){
			# /, /file
			$page = ".";
		}elsif($p ne "."){
			# page/, page/file
			$page = convert_page_name($p);
			return "" if $page eq "";
		}
		# else ./, ./file
		$file = substr $path, $i + 1;
	}elsif($path eq "."){
		# .
		$file = "";
	}else{
		# file
		$file = $path;
	}

	if($file eq ""){
		return qq(<a class="auto-title" href="$page/">$page/</a>) if $title eq "";
		return qq(<a href="$page/">$title</a>);
	}

	my $enc_path = encode_url_safe("$page/$file");
	return qq(<a class="auto-title" href="$enc_path">$file</a>) if $title eq "";
	return qq(<a href="$enc_path">$title</a>);
}

sub link_url_image{
	my ($url, $title, $style) = @_;

	$url =~ s/^[ \t]+|[ \t]+$//g;
	$title =~ s/^[ \t]+|[ \t]+$//g;
	$style =~ s/^[ \t]+|[ \t]+$//g;
	$style = qq( style="$style") if $style ne "";

	return qq(<img class="auto-title" src="$url" alt="$url" title="$url"$style />) if $title eq "";
	return qq(<img src="$url" alt="$title" title="$title"$style />);
}

sub link_url{
	my ($url, $title) = @_;

	$url =~ s/^[ \t]+|[ \t]+$//g;
	$title =~ s/^[ \t]+|[ \t]+$//g;

	return qq(<a class="auto-title" href="$url">$url</a>) if $title eq "";
	return qq(<a href="$url">$title</a>);
}

sub is_url{
	my $url = shift;

	# from parse_line
	$url =~ y/\x01/&/;
	$url =~ y/\x02/</;
	$url =~ y/\x03/>/;

	# https://en.wikipedia.org/wiki/Percent-encoding
	return $url =~ m#^(?:[a-z]+://)[%!\#\$&'()*+,/:;=?@\[\]a-z0-9_.~-]+$#i;
}

sub protect_urls{
	my $text = shift;
	$text =~ s#([a-z]+://)#\x00$1#gi;
	return $text;
}

sub encode_url_safe{
	# Percent-encode characters that are not reserved nor unreserved; Avoid
	# percent-encoding reserved characters to retain their special meanings
	my $url = shift;

	# from parse_line
	$url =~ y/\x01/&/;
	$url =~ y/\x02/</;
	$url =~ y/\x03/>/;

	# https://en.wikipedia.org/wiki/Percent-encoding
	$url =~ s/([^!#\$&'()*+,\/:;=?@\[\]a-zA-Z0-9_.~-])/@{[sprintf "%%%02X", ord($1)]}/g;
	$url =~ s/&/&amp;/g;
	return $url;
}

sub encode_url_most{
	# Percent-encode characters that are not unreserved
	my $url = shift;

	# from parse_line
	$url =~ y/\x01/&/;
	$url =~ y/\x02/</;
	$url =~ y/\x03/>/;

	# https://en.wikipedia.org/wiki/Percent-encoding
	$url =~ s/([^a-zA-Z0-9_.~-])/@{[sprintf "%%%02X", ord($1)]}/g;
	return $url;
}

sub encode_url_utf8{
	# Percent-encode UTF-8 characters outside ASCII
	my $url = shift;

	# from parse_line
	$url =~ y/\x01/&/;
	$url =~ y/\x02/</;
	$url =~ y/\x03/>/;

	$url =~ s/([\x80-\xff])/@{[sprintf "%%%02X", ord($1)]}/g;
	$url =~ s/&/&amp;/g;
	return $url;
}

sub encode_url_reserved{
	# Percent-encode reserved characters to lose their special meanings
	my $url = shift;

	# from parse_line
	$url =~ y/\x01/&/;
	$url =~ y/\x02/</;
	$url =~ y/\x03/>/;

	# https://en.wikipedia.org/wiki/Percent-encoding
	$url =~ s/([!#\$&'()*+,\/:;=?@\[\]])/@{[sprintf "%%%02X", ord($1)]}/g;
	return $url;
}

sub decode_url{
	my $url = shift;
	$url =~ s/%(..)/@{[pack "c", hex($1)]}/g;
	return $url;
}

sub is_admin{
	return $admin;
}

sub is_logged_in{
	return $USER ne "";
}

sub has_read_access{
	return 1 if $admin;
	if($wiki){
		return 1 if $wiki_read_access eq "open";
		return 1 if $wiki_read_access eq "closed" && is_logged_in();
		return 0;
	}
	return 1 if $nonwiki_read_access eq "open";
	return 1 if $nonwiki_read_access eq "closed" && is_logged_in();
	return 0;
}

sub has_write_access{
	my $comment = shift;
	return 1 if $admin;
	if($wiki){
		return 1 if $wiki_write_access eq "open";
		return 1 if $wiki_write_access eq "closed" && is_logged_in();
		return 0;
	}
	if($comment){
		return 1 if $nonwiki_comment_access eq "open";
		return 1 if $nonwiki_comment_access eq "closed" &&
			    is_logged_in();
	}
	return 0;
}

sub page_exists{
	my $page = shift;
	$page = $PAGE unless defined $page;
	return -f "$page.txt";
}

sub is_wiki{
	my $page = shift;
	local *FH;
	open FH, "$page.txt";
	my $wiki = <FH> eq "#!wiki\n" ? 1 : 0;
	close FH;
	return $wiki;
}

#-------------------------------------------------------------------------------
# Password file
sub write_pw{
	my $file = $PASSWORD_FILE eq "" ? "u.pw" : $PASSWORD_FILE;
	write_file($file, "$adminpw\n") unless -f $file;
}

#-------------------------------------------------------------------------------
# Default config
sub process_cfg{
	# $mode=undef: eval
	# $mode=1: write
	my $mode = shift;
	my $cfg = <<'EOT_UNIQKI';
# Site information: HTML tags are allowed.
$SITE_TITLE = 'Uniqki: A Personal Wiki Builder';
$SITE_DESCRIPTION = 'A <a href="https://uniqki.isnew.info">Uniqki</a> site';

# Index page
$INDEX_PAGE = 'index';

# Language
$LANG = 'en';

# Character set
$CHARSET = 'utf-8';

# Locale: Setting this variable to an empty string uses the default locale.
$LOCALE = '';

# Set time zone if different from the system time
$TIME_ZONE = '';

# Time format interpreted by the POSIX::strftime function
$TIME_FORMAT = '%a %b %e %H:%M:%S %Y %Z';

# Share cookies: [subdomains:][EMPTY|subpaths|all_paths]
# * subdomains: http://example.com/u shares cookies with
#		http://www.example.com/u.
# * EMPTY: http://example.com/path1/u does not share cookies with
#	   http://example.com/u, http://example.com/path2/u, nor
#	   http://example.com/path1/subpath1/u.
# * subpaths: http://example.com/path1/u shares cookies with
#	      http://example.com/path1/subpath1/u, but not with
#	      http://example.com/u nor http://example.com/path2/u.
# * all_paths: http://example.com/path1/u shares cookies with
#	       http://example.com/u, http://example.com/path2/u, and
#	       http://example.com/path1/subpath1/u.
#
# It is possible to combine subdomains and one of EMPTY, subpaths, and
# all_paths.  For example,
# * subdomains:all_paths: http://example.com/path1/u shares cookies with
#			  http://www.example.com/u.
#
# An empty setting '' means that cookies are not shared with other subdomains
# nor paths.  Subdomains and specified paths have to use the password and
# sessions files in the current domain and path to share login sessions.
# Subpaths does not work with $doc_root because the script and document
# directories are different.
$SHARE_COOKIES = '';

# WARNING: Make sure to protect these files and directories from the user using
# the following directives in .htaccess:
# <Files ~ "(^u\.(cfg|pw|msg)|^\.sessions|\.(tpl|txt|txt\.v))$">
#	Deny from all
# </Files>

# Password file: The admin password can be embedded in the script as $adminpw.
$PASSWORD_FILE = 'u.pw';

# Sessions file: The default sessions file is .sessions.
$SESSIONS_FILE = '.sessions';

# Messages file: The default messages will be printed if missing.
$MESSAGES_FILE = 'u.msg';

# Template directory: The default template will be served by the script if
# missing.
$TEMPLATE_DIRECTORY = 'u.tpl';

# Page name style: case[:dots|:no_dots][:hyphens|:underscores|:no_spaces]
# * lower_case (default): All lower case (e.g., page in a uniqki site)
# * upper_case: All upper case (e.g., PAGE IN A UNIQKI SITE)
# * mixed_case: No special handling of letter case (e.g., Page in a Uniqki site)
# * start_case: Start case (e.g., Page In A Uniqki Site)
# * lower_camel_case: Lower camel case (e.g., pageInAUniqkiSite)
# * upper_camel_case: Upper camel case (e.g., PageInAUniqkiSite)
#
# Dots
# * dots (default): Replace a series of dots with a dot.  Dots separate words
#		    for a case conversion.
# * no_dots: Remove dots.  The lower_camel_case and upper_camel_case styles
#	     imply this option.  For example, upper_camel_case is the same as
#	     start_case:no_dots:no_spaces.
#
# Spaces
# * hyphens (default): Replace a series of whitespaces with a hyphen
# * underscores: Replace a series of whitespaces with an underscore
# * no_spaces: Remove whitespaces.  The lower_camel_case and upper_camel_case
#	       styles imply this option.  For example, lower_camel_case is the
#	       same as lower_camel_case:no_dots:no_spaces.
#
# The following special characters will be replaced with spaces and separate
# words before a case conversion: `~!@#$%^&*=+\|;:'",/?()[]{}<>
#
# Hyphens (-) and underscores (_) will be converted to spaces and may be
# converted back to hyphens or underscores depending on the page name style.
#
# For example, "'page' in a uniqki site!!!" excluding double quotes in the
# start_case style will create and link to Page-In-A-Uniqki-Site.html.  The
# same page name in the upper_camel_case style will use PageInAUniqkiSite.html.
$PAGE_NAME_STYLE = 'lower_case:dots:hyphens';

# Section number style in headings and the table of contents: The default style
# is "1.1&nbsp;&nbsp;&nbsp;".
$SECTION_NUMBER_PREFIX = '';
$SECTION_NUMBER_SEPARATOR = '.';
$SECTION_NUMBER_SUFFIX = '&nbsp;&nbsp;&nbsp;';

# Section reference style in text: The default style is "Section 1.1".
$SECTION_REFERENCE_PREFIX = 'Section ';
$SECTION_REFERENCE_SUFFIX = '';

# Table number style in captions and the list of tables: The default style is
# "Table 1: ".
$TABLE_NUMBER_PREFIX = 'Table ';
$TABLE_NUMBER_SUFFIX = ': ';

# Table reference style in text: The default style is "Table 1".
$TABLE_REFERENCE_PREFIX = 'Table ';
$TABLE_REFERENCE_SUFFIX = '';

# Figure number style in captions and the list of tables: The default style is
# "Figure 1: ".
$FIGURE_NUMBER_PREFIX = 'Figure ';
$FIGURE_NUMBER_SUFFIX = ': ';

# Figure reference style in text: The default style is "Figure 1".
$FIGURE_REFERENCE_PREFIX = 'Figure ';
$FIGURE_REFERENCE_SUFFIX = '';

# Login session will be extended by this number of minutes whenever any action
# is taken by the user.
$INACTIVE_TIMEOUT = 24*60;

# Change password timeout in minutes
$SET_PASSWORD_TIMEOUT = 60;

# Reset password timeout in minutes
$RESET_PASSWORD_TIMEOUT = 1;

# Email address from which user notifications are sent: 'Your Name
# <you@example.com>' is not supported.  Enter your email address only as in
# 'you@example.com'.  Make sure to use single quotes instead of double quotes.
$EMAIL_ADDRESS = '';

# SMTP settings for user notifications: If this variable is empty, email will
# be sent using sendmail.  The format of this variable is
# 'server:port:username:password'.  The password may contain colons (:), but
# the username cannot.
$SMTP = '';

# Fallback MIME type command: This command will be used to determine the MIME
# type of files when the MIME::Types module is not installed or fails to
# determine the type.  Setting this variable to an empty string will return an
# empty MIME type.
$MIME_TYPE_COMMAND = '/usr/bin/file --brief --mime-type';

# Read access control
# * open (default): Opens both non-wiki and wiki pages to the public and anyone
#		    will be able to read those pages with or without a login.
# * closed: Requires a login to perform any read actions including search,
#	    diff, etc.  The directives in .htaccess shown below are required to
#	    prevent direct access to *.html files, effectively making the
#	    entire site read-secured.
# * admin: Allows only admin users access to non-wiki and wiki pages.  The
#	   .htaccess directives below are required.
#
# Non-wiki and wiki pages can have different settings separated by a colon.
# For example, closed:open means closed non-wiki and open wiki pages.  One
# setting applies to both non-wiki and wiki pages.  That is, open is the same
# as open:open (open non-wiki and open wiki).
#
# Unless this variable is open or open:open, the following .htaccess directives
# are required to secure *.html files:
# RewriteEngine On
# RewriteBase /
# RewriteRule ^$ u [R,L]
# RewriteRule ^([^/]*)\.html$ u/$1 [R,L]
# RewriteRule ^(u/[^/]*)\.html$ $1 [R,L]
# RewriteCond %{REQUEST_URI} !^/u($|[/?])
# RewriteRule .* "-" [F]
$READ_ACCESS = 'open';

# Write access control
# * open (default): Allows anyone to comment in non-wiki pages and edit or
#		    create wiki pages with or without a login.
# * closed: Requires a login to comment in non-wiki pages and edit or create
#	    wiki pages.
# * admin: Requires admin rights to comment in non-wiki pages and edit or
#	   create wiki pages.
#
# Commenting in non-wiki pages and accessing wiki pages can have different
# settings separated by a colon.  Creating new wiki pages also depends on
# $WIKI_PAGES_ALLOWED.  For security reasons, non-wiki pages are writable only
# by admin users and this variable cannot affect that behavior.
$WRITE_ACCESS = 'open';

# Regular expression for page names that are not allowed
$PAGES_NOT_ALLOWED = q();

# User parsers file
$USER_PARSERS_FILE = '';

# Header and footer files for the non-wiki and wiki parsers
$HEADER_FILE = '';
$FOOTER_FILE = '';

# Header and footer files for the non-wiki parser
$NONWIKI_HEADER_FILE = '';
$NONWIKI_FOOTER_FILE = '';

# Header and footer files for the wiki parser
$WIKI_HEADER_FILE = '';
$WIKI_FOOTER_FILE = '';

# Regular expression for wiki page names that are allowed to be created by
# non-admin users
$WIKI_PAGES_ALLOWED = q();

# Regular expression for file names that are allowed to be uploaded by
# non-admin users to a wiki page
$WIKI_FILES_ALLOWED = q(\.(png|gif|jpg|jpeg|txt|zip)$);

# Minimum time in seconds required for commenting to block massive spam attacks
# in a short period of time.  Any comments submitted within this threshold time
# will be treated as a spam message.
$MINIMUM_COMMENT_TIME = 15;
EOT_UNIQKI
	my $file = $CFG eq "" ? "u.cfg" : $CFG;
	if($mode == 1){
		write_file($file, $cfg) unless -f $file;
	}else{
		eval $cfg;
		do $file if -f $file;
	}
}

#-------------------------------------------------------------------------------
# Default messages
sub process_msg{
	# $mode=undef: eval if file does not exist, do file otherwise
	# $mode=1: write
	my $mode = shift;
	my $msg = <<'EOT_UNIQKI';
%MESSAGES = (
################################################################################
# Template messages: These messages don't support printf format specifiers such
# as %s because there is no way to pass arguments to these messages from the
# template.  However, the [[PAGE]] tag can be used to generate dynamic text.
powered_by_uniqki => q(Powered by <a href="https://uniqki.isnew.info">Uniqki</a>!),

username => q(Username),
password => q(Password),
logout_from_other_computers => q(Logout from other computers),
view => q(View),

manage_pages => q(Manage pages),
backup => q(Backup),
restore => q(Restore),

all_users => q(All users),
manage_users => q(Manage users),
add_user => q(Add user),
update_user => q(Update user),
block_user => q(Block user),
unblock_user => q(Unblock user),
delete_user => q(Delete user),
email_address => q(Email address),
full_name => q(Full name),
non_admin => q(Non-admin),
admin => q(Admin),
dont_change => q(Don't change),
type_password_again => q(Type password again),
username_requirements => q(Username requirements: 4 or more letters (a-z, A-Z) and digits (0-9).),
full_name_requirements => q(Full name requirements: 5 or more letters without digits (0-9) and special characters.),
password_requirements => q(Password requirements: 8 or more characters with at least one letter (a-z, A-Z), one digit (0-9), and one special character excluding spaces and tabs.),
leave_password_blank_for_email_notification => q(Leave the password field blank for an email notification with a temporary link for resetting the password.),

manage_myself => q(Manage myself),
update_myself => q(Update myself),
delete_myself => q(Delete myself),

forgot_password => q(Forgot password),
enter_username_or_email_address => q(Please enter a username or an email address.),
user_info_mismatch => q(User information mismatch!),
email_address_not_found => q(%s: Email address not found.),
user_blocked => q(%s: User blocked.),

reset_password => q(Reset password),
password_reset_token_expired => q(Password reset token expired.),
password_reset_token_still_valid => q(You still have a valid password reset token. Please refer to the last email notification.),
invalid_password_reset_token => q(Invalid password reset token.),
password_reset_token_not_found => q(Password reset token not found.),

refresh => q(Refresh),
edit => q(Edit),
index => q(Index),
loginout => q(Loginout),
login => q(Login),
logout => q(Logout),
diff => q(Diff),
backlinks => q(Backlinks),
last_modified => q([[TIME]] by [[AUTHOR]]),
unknown_author => q(Unknown),
parsing_time => q(Parsing time: [[PARSING_TIME]] seconds),
html5 => q(HTML5),
css => q(CSS),

preview => q(Preview),
save => q(Save),
save_edit => q(Save & Edit),
live_preview => q(Live Preview),
file_upload => q(File upload: ),
paste_image => q(Type filename and paste image.),
type_filename => q(Please type filename.),
characters_not_allowed_in_filename => q(\\\\ / : * ? " < > | are not allowed in filename.),
cancel => q(Cancel),
preview_warning => q(This document is preview. Please make sure to save your changes.),

page_updated => q([[PAGE]] updated!),
save_your_changes_and_read_latest_version => q(Please save your changes and read <a href="[[PAGE]].html">the latest version</a>!),

edit_page => q(Edit [[PAGE]]),
wiki_edit_page => q(WikiEdit [[PAGE]]),

edit_lines => q(Edit [[PAGE]] (lines [[START]]+[[COUNT]])),
wiki_edit_lines => q(WikiEdit [[PAGE]] (lines [[START]]+[[COUNT]])),

################################################################################
# Non-template messages: These messages support printf format specifiers such
# as %s, but [[...]] tags cannot be used.
internal_errors => q(Internal errors),
session_errors => q(Session errors),
perl_module_not_installed => q(%s: Perl module not installed.),

change_admin_password => q(The admin password cannot be the same as the temporary password. <a href="?manage_myself">Change your password.</a>),

read_secured => q(You are not allowed to read this page.),
login_not_allowed => q(Login is not allowed.),
login_failed => q(Login failed.),
admin_actions_not_allowed => q(Admin actions are not allowed. Please <a href="?login">login</a> first.),

cannot_add_yourself => q(You cannot add yourself.),
cannot_block_yourself => q(You cannot block yourself.),
cannot_unblock_yourself => q(You cannot unblock yourself.),
cannot_delete_yourself => q(You cannot delete yourself.),
cannot_delete_only_admin => q(You cannot delete yourself because you are the only admin.),
user_already_blocked => q(%s: User already blocked.),
user_already_unblocked => q(%s: User already unblocked.),
user_already_exists => q(%s: User already exists.),
email_address_already_registered => q(%s: Email address already registered.),
enter_user_info_to_update => q(%s: Please enter user information to update.),
user_not_found => q(%s: User not found.),

enter_username => q(Please enter a username to manage.),
check_username => q(Please enter a username that meets character requirements.),
enter_email_address => q(Please enter an email address.),
check_email_address => q(Please enter a valid email address.),
leave_email_address_blank => q(Please leave the email address blank.),
enter_full_name => q(Please enter the user's full name.),
check_full_name => q(Please enter a full name that meets character requirements.),
check_password => q(Please enter a password that meets the length and character requirements.),
confirm_password => q(Please confirm the password.),
leave_password_blank => q(Please leave the password blank.),

new_user_email_subject => q(%s: Registered),
new_user_email_text => q(Your username %s is registered at %s. Please set your password by visiting %s within %d minutes.),
unblocked_user_email_subject => q(%s: Unblocked),
unblocked_user_email_text => q(Your username %s is unblocked at %s. Please set your password by visiting %s within %d minutes.),
reset_password_email_subject => q(%s: Reset password),
reset_password_email_text => q(Please reset your password for username %s at %s by visiting %s within %d minutes.),
email_notification_failed => q(Email notification failed for user %s <%s>.),

page_not_allowed => q(%s: Page not allowed.),
page_not_found => q(%s: Page not found.),
page_already_exists => q(%s: Page already exists.),
create_page => q(%s: Page not found. Create a new <a href="?edit">non-wiki</a> or <a href="?wiki_edit">wiki</a> page),
not_wiki_page => q(%s: This page is not a wiki page.),
not_allowed_to_create_nonwiki_page => q(%s: You are not allowed to create this non-wiki page.),
not_allowed_to_comment_in_nonwiki_page => q(%s: You are not allowed to comment in this non-wiki page.),
not_allowed_to_create_wiki_page => q(%s: You are not allowed to create this wiki page.),
not_allowed_to_edit_wiki_page => q(%s: You are not allowed to edit this wiki page.),
path_not_found => q(%s: Path not found.),

recent_changes => q(Recent changes),
recent_changes_matching => q(Recent changes matching %s pattern),
old_changes => q(Old changes),
old_changes_matching => q(Old changes matching %s pattern),
all_pages => q(All pages),
all_pages_matching => q(All pages matching %s pattern),
all_pages_reversed => q(All pages in reversed order),
all_pages_reversed_matching => q(All pages matching %s pattern in reverse order),
refresh_pages => q(Refresh pages),
refresh_pages_matching => q(Refresh pages matching %s pattern),
search => q(Search for %s),
search_matching => q(Search %s for %s),
differences => q(Differences of <a href="%s">%1$s</a> between versions %d and %d),

goto_form => q(Goto form),
goto_form_goto => q(Go to),
rename_form_rename => q(Rename),
search_form => q(Search form),
search_form_search => q(Search),
search_form_simple => q(Simple),
search_form_ignore_case => q(Ignore case),
search_form_links => q(Links),
search_form_print_titles => q(Print titles),
search_form_dont_print_matches => q(Don't print matches),
comment_form => q(Comment form),
comment_form_leave_this_field_blank => q(Please leave this field blank: ),
comment_form_write => q(Write),
specify_comment_page => q(Please specify a comment page.),
comment_tag_not_found => q(%s: Comment tag not found.),
invalid_comment_tag => q(%s: Invalid comment tag.),

current_version => q(The current version of <a href="%s">%1$s</a> is %d.),
wiki_file_not_allowed => q(%s: File not allowed.),
wiki_files_uploaded => q(Files uploaded. Copy and paste the links below:<pre id="file-links-example">%s</pre>),
files_uploaded => q(Files uploaded. Copy and paste the links below:<pre id="file-links-example">%s</pre>),
image_uploaded => q(Image uploaded. Copy and paste the link below:<pre id="file-links-example"></pre>),
page_files => q(Files belonging to <a href="../%s">%1$s</a>),

table_of_contents => q(Contents),
list_of_tables => q(Tables),
list_of_figures => q(Figures),
);
EOT_UNIQKI
	my $file = $MESSAGES_FILE eq "" ? "u.msg" : $MESSAGES_FILE;
	if($mode == 1){
		write_file($file, $msg) unless -f $file;
	}else{
		eval $msg;
		do $file if -f $file;
	}
}

sub get_msg{
	my $msg_id = shift;
	return sprintf $MESSAGES{$msg_id}, @_;
}

sub is_username{
	my $user = shift;
	my $len = length($user);
	return $len >= 4 && $len <= 64 && $user =~ /^[a-zA-Z0-9]+$/;
}

sub is_password{
	my $pw = shift;
	my $len = length($pw);
	return $len >= 8 && $len <= 128 &&
	       $pw =~ /[a-zA-Z]/ && $pw =~ /[0-9]/ &&
	       $pw =~ /[`~!@#\$%^&*_+=\\|;:'",.\/?()\[\]{}<>]/;
}

sub is_email_address{
	# Regex: http://www.regular-expressions.info/email.html
	my $email = shift;
	my $len = length($email);
	return $len >= 6 && $len <= 254 &&
	       $email =~ /^[a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,}$/i;
}

sub is_full_name{
	my $name = shift;
	$name =~ s/[ \t]+/ /g;
	$name =~ s/^ | $//g;
	my $len = length($name);
	return $len >= 5 && $name !~ /[`~!@#\$%^&*_=+\\|;:'",\/?()\[\]{}<>0-9-]/;
}

sub is_session_id{
	my $session_id = shift;
	my $len = length($session_id);
	return $len == 64 && $session_id =~ /^[a-zA-Z0-9]+$/;
}

sub is_password_reset_token_valid{
	my $token = shift;
	if($token !~ /^[a-zA-Z0-9]{64}\.([0-9]+)$/){
		return 0;
	}
	my $expires = $1;
	my $time = time;
	return $time < $expires;
}

#-------------------------------------------------------------------------------
# Default template
sub process_tpl_tag{
	my $tag = shift;
	local *FH;
	my $txt = "";

	open FH, ">", \$txt; my $fh = select FH;
	if($tag eq "HEADER"){
		print_header();
	}elsif($tag eq "FOOTER"){
		print_footer();
	}elsif($tag eq "EDIT"){
		print_edit();
	}elsif($tag eq "WIKI_EDIT"){
		print_wiki_edit();
	}elsif($tag eq "EDIT_LINES"){
		print_edit_lines();
	}elsif($tag eq "WIKI_EDIT_LINES"){
		print_wiki_edit_lines();
	}elsif($tag =~ /^[A-Z_]+$/){
		my @tags = qw(
			SITE_TITLE SITE_DESCRIPTION INDEX_PAGE TITLE LANG
			CHARSET PAGE VERSION TEXT START COUNT HTTP_BASE DOC_BASE
			PREVIEW TIME CGI MESSAGE PASSWORD_RESET_TOKEN NAME
			AUTHOR PARSING_TIME
		);
		my %hash;
		@hash{@tags} = undef;

		no strict;
		$txt = $$tag if exists $hash{$tag};
	}elsif($tag eq "parsing_time" && !$show_parsing_time){
		$txt = "";
	}elsif($tag =~ /^[a-z0-9_]+$/){
		$txt = get_msg($tag);
		my @tags = qw(
			PAGE START COUNT TIME AUTHOR PARSING_TIME
		);

		no strict;
		foreach(@tags){
			$txt =~ s/\[\[$_\]\]/$$_/g;
		}
	}
	close FH; select $fh;

	return $txt;
}

sub process_tpl{
	# $mode=undef: print
	# $mode=1: write
	# $mode=2: print for CSS and JavaScript only
	my ($file, $mode, $tpl) = @_;
	my $path = "$TEMPLATE_DIRECTORY/$file";

	start_html() unless defined $mode;
	if($mode == 2){
		if(".css" eq substr $file, -4){
			print "Content-Type: text/css\n\n";
		}elsif(".js" eq substr $file, -3){
			print "Content-Type: text/javascript\n\n";
		}
	}

	if($mode == 1){
		write_file($path, $tpl) if -d $TEMPLATE_DIRECTORY && !-f $path;
		return;
	}elsif(-f $path){
		$tpl = read_file($path);
	}

	$tpl =~ s/\[\[([A-Za-z0-9_]*)\]\]/@{[process_tpl_tag($1)]}/g;
	chomp $tpl;
	print $tpl;
}

sub print_header{
	my $mode = shift;
	return if !defined $mode && $header_printed;

	$header_printed = 1;
	process_tpl("header.tpl", $mode, <<'EOT_UNIQKI');
<!DOCTYPE html>
<html lang="[[LANG]]">
<head>
<title>[[TITLE]]</title>
<meta charset="[[CHARSET]]" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="stylesheet" href="[[CGI]]?css" />
<link rel="alternate" type="application/rss+xml" title="[[recent_changes]]" href="[[CGI]]?rss" />
<script src="[[CGI]]?js"></script>
<script>
windowOnLoad(function(){
	if(!window.location.href.match(/^file:/))
		ajaxRequest('[[CGI]]/[[PAGE]]?user_info', null, processMenu,
			'text/plain');
});
</script>
</head>
<body>
<header id="top">
<div id="site-title"><a href="[[DOC_BASE]]">[[SITE_TITLE]]</a></div>
<div id="site-description">[[SITE_DESCRIPTION]]</div>
</header>
<main id="main">
EOT_UNIQKI
}

sub print_footer{
	my $mode = shift;
	return if !defined $mode && $footer_printed;

	$footer_printed = 1;
	process_tpl("footer.tpl", $mode, <<'EOT_UNIQKI');
</main>
<footer id="bottom">
<span id="validators">
<a href="https://validator.w3.org/check?uri=referer">[[html5]]</a> .
<a href="https://jigsaw.w3.org/css-validator/check/referer">[[css]]</a>
</span> .
[[powered_by_uniqki]]
</footer>
</body>
</html>
EOT_UNIQKI
}

sub print_login{
	process_tpl("login.tpl", shift, <<'EOT_UNIQKI');
[[HEADER]]
<section id="login">
<h1>[[login]]</h1>
<form action="[[PAGE]]?login" method="post">
<div>
<input accesskey="u" type="text" id="user" name="user" placeholder="[[username]]" />
<input accesskey="p" type="password" id="pw" name="pw" placeholder="[[password]]" />
<input accesskey="l" type="submit" value="[[login]]" />
<br />
<input type="checkbox" id="logout_others" name="logout_others" value="1" /> [[logout_from_other_computers]]
</div>
</form>
</section>
<nav id="menu">
<hr />
<span class="read-access"><a accesskey="v" href="[[PAGE]].html">[[view]]</a> .</span>
<a accesskey="i" href="[[INDEX_PAGE]].html">[[index]]</a>
</nav>
[[FOOTER]]
EOT_UNIQKI
}

sub print_manage_pages{
	process_tpl("manage_pages.tpl", shift, <<'EOT_UNIQKI');
[[HEADER]]
<section id="manage-pages">
<h1>[[manage_pages]]</h1>
<form action="?restore" method="post" enctype="multipart/form-data">
<div>
[[backup]]: <a href="[[CGI]]?backup">[[all_pages]]</a> .
<a href="?backup">[[PAGE]]</a>
<br />
[[restore]]: <input accesskey="f" type="file" id="file" name="file" />
<input accesskey="r" type="submit" value="[[restore]]" />
</div>
</form>
</section>
<nav id="menu">
<hr />
<span class="read-access"><a accesskey="v" href="[[PAGE]].html">[[view]]</a> .</span>
<a accesskey="i" href="[[INDEX_PAGE]].html">[[index]]</a> .
<a accesskey="l" href="[[PAGE]]?logout">[[logout]]</a>
</nav>
[[FOOTER]]
EOT_UNIQKI
}

sub print_manage_users{
	process_tpl("manage_users.tpl", shift, <<'EOT_UNIQKI');
[[HEADER]]
<section id="manage-users">
<h1>[[manage_users]]</h1>
<ul>
<li>[[username_requirements]]</li>
<li>[[full_name_requirements]]</li>
<li>[[password_requirements]]</li>
<li>[[leave_password_blank_for_email_notification]]</li>
</ul>

<h2>[[add_user]]</h2>
<form action="?add_user" method="post">
<div>
<input accesskey="u" type="text" id="user" name="user" placeholder="[[username]]" />
<input accesskey="e" type="text" id="email" name="email" placeholder="[[email_address]]" />
<input accesskey="f" type="text" id="name" name="name" placeholder="[[full_name]]" />
<br />
<input type="radio" id="admin" name="admin" value="no" checked="checked" /> [[non_admin]]
<input type="radio" id="admin" name="admin" value="yes" /> [[admin]]
<br />
<input accesskey="p" type="password" id="pw" name="pw" placeholder="[[password]]" />
<input type="password" id="pw2" name="pw2" placeholder="[[type_password_again]]" />
<br />
<input type="submit" value="[[add_user]]" />
</div>
</form>

<h2>[[update_user]]</h2>
<form action="?update_user" method="post">
<div>
<input accesskey="u" type="text" id="user" name="user" placeholder="[[username]]" />
<input accesskey="e" type="text" id="email" name="email" placeholder="[[email_address]]" />
<input accesskey="f" type="text" id="name" name="name" placeholder="[[full_name]]" />
<br />
<input type="radio" id="admin" name="admin" value="no" /> [[non_admin]]
<input type="radio" id="admin" name="admin" value="yes" /> [[admin]]
<input type="radio" id="admin" name="admin" value="keep" checked="checked" /> [[dont_change]]
<br />
<input accesskey="p" type="password" id="pw" name="pw" placeholder="[[password]]" />
<input type="password" id="pw2" name="pw2" placeholder="[[type_password_again]]" />
<br />
<input type="submit" value="[[update_user]]" />
</div>
</form>

<h2>[[block_user]]</h2>
<form action="?block_user" method="post">
<div>
<input accesskey="u" type="text" id="user" name="user" placeholder="[[username]]" />
<br />
<input type="submit" value="[[block_user]]" />
</div>
</form>

<h2>[[unblock_user]]</h2>
<form action="?unblock_user" method="post">
<div>
<input accesskey="u" type="text" id="user" name="user" placeholder="[[username]]" />
<br />
<input accesskey="p" type="password" id="pw" name="pw" placeholder="[[password]]" />
<input type="password" id="pw2" name="pw2" placeholder="[[type_password_again]]" />
<br />
<input type="submit" value="[[unblock_user]]" />
</div>
</form>

<h2>[[delete_user]]</h2>
<form action="?delete_user" method="post">
<div>
<input accesskey="u" type="text" id="user" name="user" placeholder="[[username]]" />
<br />
<input type="submit" value="[[delete_user]]" />
</div>
</form>
</section>
<nav id="menu">
<hr />
<span class="read-access"><a accesskey="v" href="[[PAGE]].html">[[view]]</a> .</span>
<a accesskey="i" href="[[INDEX_PAGE]].html">[[index]]</a> .
<a accesskey="l" href="[[PAGE]]?logout">[[logout]]</a>
</nav>
[[FOOTER]]
EOT_UNIQKI
}

sub print_manage_myself{
	process_tpl("manage_myself.tpl", shift, <<'EOT_UNIQKI');
[[HEADER]]
<section id="manage-myself">
<h1>[[manage_myself]]</h1>

<h2>[[update_myself]]</h2>
<ul>
<li>[[full_name_requirements]]</li>
<li>[[password_requirements]]</li>
</ul>

<form action="?update_myself" method="post">
<div>
<input accesskey="e" type="text" id="email" name="email" placeholder="[[email_address]]" />
<input accesskey="f" type="text" id="name" name="name" placeholder="[[full_name]]" />
<br />
<input accesskey="p" type="password" id="pw" name="pw" placeholder="[[password]]" />
<input type="password" id="pw2" name="pw2" placeholder="[[type_password_again]]" />
<br />
<input type="submit" value="[[update_myself]]" />
</div>
</form>

<h2>[[delete_myself]]</h2>
<form action="?delete_myself" method="post">
<div>
<input type="submit" value="[[delete_myself]]" />
</div>
</form>
</section>
<nav id="menu">
<hr />
<span class="read-access"><a accesskey="v" href="[[PAGE]].html">[[view]]</a> .</span>
<a accesskey="i" href="[[INDEX_PAGE]].html">[[index]]</a> .
<a accesskey="l" href="[[PAGE]]?logout">[[logout]]</a>
</nav>
[[FOOTER]]
EOT_UNIQKI
}

sub print_forgot_password{
	process_tpl("forgot_password.tpl", shift, <<'EOT_UNIQKI');
[[HEADER]]
<section id="forgot-password">
<h1>[[forgot_password]]</h1>
<form action="?forgot_password" method="post">
<div>
<input accesskey="u" type="text" id="user" name="user" placeholder="[[username]]" />
<input accesskey="e" type="text" id="email" name="email" placeholder="[[email_address]]" />
<br />
<input type="submit" value="[[forgot_password]]" />
</div>
</form>
</section>
<nav id="menu">
<hr />
<span class="read-access"><a accesskey="v" href="[[PAGE]].html">[[view]]</a> .</span>
<a accesskey="i" href="[[INDEX_PAGE]].html">[[index]]</a>
</nav>
[[FOOTER]]
EOT_UNIQKI
}

sub print_reset_password{
	process_tpl("reset_password.tpl", shift, <<'EOT_UNIQKI');
[[HEADER]]
<section id="reset-password">
<h1>[[reset_password]]</h1>
<ul>
<li>[[password_requirements]]</li>
</ul>

<form action="?reset_password" method="post">
<div>
<input type="hidden" id="token" name="token" value="[[PASSWORD_RESET_TOKEN]]" />
<input accesskey="p" type="password" id="pw" name="pw" placeholder="[[password]]" />
<input type="password" id="pw2" name="pw2" placeholder="[[type_password_again]]" />
<br />
<input type="submit" value="[[reset_password]]" />
</div>
</form>
</section>
<nav id="menu">
<hr />
<span class="read-access"><a accesskey="v" href="[[PAGE]].html">[[view]]</a> .</span>
<a accesskey="i" href="[[INDEX_PAGE]].html">[[index]]</a>
</nav>
[[FOOTER]]
EOT_UNIQKI
}

sub print_message{
	process_tpl("message.tpl", shift, <<'EOT_UNIQKI');
[[HEADER]]
<section id="message">
[[MESSAGE]]
</section>
<nav id="menu">
<hr />
<span class="read-access"><a accesskey="v" href="[[PAGE]].html">[[view]]</a> .</span>
<span class="write-access"><a accesskey="v" href="[[PAGE]]?edit">[[edit]]</a> .</span>
<a accesskey="i" href="[[INDEX_PAGE]].html">[[index]]</a> .
<a class="visitor" accesskey="l" href="[[PAGE]]?login">[[login]]</a>
<a class="user" accesskey="l" href="[[PAGE]]?logout">[[logout]]</a>
</nav>
[[FOOTER]]
EOT_UNIQKI
}

sub print_view{
	# View templates are never served dynamically, so don't print a
	# content-type header
	$html_started = 1;
	process_tpl("view.tpl", shift, <<'EOT_UNIQKI');
[[HEADER]]
<article id="view">
<!-- start text -->
[[TEXT]]
<!-- end text -->
</article>
<nav id="menu">
<hr />
<span class="write-access"><a accesskey="r" href="[[CGI]]/[[PAGE]]?refresh">[[refresh]]</a> .</span>
<span class="write-access"><a accesskey="e" href="[[CGI]]/[[PAGE]]?edit">[[edit]]</a> .</span>
<a accesskey="l" href="[[CGI]]?search=[[PAGE]]%5C.html&amp;link=1&amp;title=1">[[backlinks]]</a> .
<a accesskey="i" href="[[INDEX_PAGE]].html">[[index]]</a> .
<a class="visitor" accesskey="l" href="[[CGI]]/[[PAGE]]?login">[[login]]</a>
<a class="user" accesskey="l" href="[[CGI]]/[[PAGE]]?logout">[[logout]]</a>
</nav>
<footer id="metadata">
<div id="last-modified">[[last_modified]]</div>
<div id="parsing-time">[[parsing_time]]</div>
</footer>
[[FOOTER]]
EOT_UNIQKI
}

sub print_edit{
	process_tpl("edit.tpl", shift, <<'EOT_UNIQKI');
[[HEADER]]
<section id="edit">
<h1>[[edit_page]]</h1>
<form action="[[PAGE]]?edit" method="post" enctype="multipart/form-data">
<div>
<input type="hidden" id="version" name="version" value="[[VERSION]]" />
<textarea accesskey="t" id="text" name="text" rows="24" cols="80">[[TEXT]]</textarea>
<br />
<input accesskey="p" type="submit" id="preview" name="preview" value="[[preview]]" />
<input accesskey="s" type="submit" id="save" name="save" value="[[save]]" />
<input accesskey="e" type="button" id="save-edit" name="save-edit" value="[[save_edit]]" onclick="saveEdit();" />
<input accesskey="l" type="checkbox" id="live-preview" name="live-preview" onclick="livePreview();" /> [[live_preview]] .
<a accesskey="c" href="[[PAGE]].html">[[cancel]]</a> .
<a accesskey="i" href="[[INDEX_PAGE]].html">[[index]]</a>
<br />
[[file_upload]] <input accesskey="f" type="file" id="file" name="file" multiple="multiple" />
<br />
<input accesskey="u" type="text" id="filename" name="filename" /> [[paste_image]]
<div id="image-uploaded" style="display:none;">[[image_uploaded]]</div>
<script>
listenToPasteImage('../[[CGI]]/[[PAGE]]?upload', [[VERSION]], '[[type_filename]]', '[[characters_not_allowed_in_filename]]');
</script>
</div>
</form>
</section>
[[FOOTER]]
EOT_UNIQKI
}

sub print_preview{
	process_tpl("preview.tpl", shift, <<'EOT_UNIQKI');
[[HEADER]]
<div id="preview-warning">[[preview_warning]]</div>
<article id="preview-main">
[[PREVIEW]]
</article>
[[EDIT]]
[[FOOTER]]
EOT_UNIQKI
}

sub print_edit_lines{
	process_tpl("edit_lines.tpl", shift, <<'EOT_UNIQKI');
[[HEADER]]
<section id="edit">
<h1>[[edit_lines]]</h1>
<form action="[[PAGE]]?edit_lines" method="post" enctype="multipart/form-data">
<div>
<input type="hidden" id="version" name="version" value="[[VERSION]]" />
<input type="hidden" id="start" name="start" value="[[START]]" />
<input type="hidden" id="count" name="count" value="[[COUNT]]" />
<textarea accesskey="t" id="text" name="text" rows="24" cols="80">[[TEXT]]</textarea>
<br />
<input accesskey="p" type="submit" id="preview" name="preview" value="[[preview]]" />
<input accesskey="s" type="submit" id="save" name="save" value="[[save]]" />
<input accesskey="e" type="button" id="save-edit" name="save-edit" value="[[save_edit]]" onclick="saveEdit();" />
<input accesskey="l" type="checkbox" id="live-preview" name="live-preview" onclick="livePreview();" /> [[live_preview]] .
<a accesskey="c" href="[[PAGE]].html">[[cancel]]</a> .
<a accesskey="i" href="[[INDEX_PAGE]].html">[[index]]</a>
<br />
[[file_upload]] <input accesskey="f" type="file" id="file" name="file" multiple="multiple" />
<br />
<input accesskey="u" type="text" id="filename" name="filename" /> [[paste_image]]
<div id="image-uploaded" style="display:none;">[[image_uploaded]]</div>
<script>
listenToPasteImage('../[[CGI]]/[[PAGE]]?upload', [[VERSION]], '[[type_filename]]', '[[characters_not_allowed_in_filename]]');
</script>
</div>
</form>
</section>
[[FOOTER]]
EOT_UNIQKI
}

sub print_preview_lines{
	process_tpl("preview_lines.tpl", shift, <<'EOT_UNIQKI');
[[HEADER]]
<div id="preview-warning">[[preview_warning]]</div>
<article id="preview-main">
[[PREVIEW]]
</article>
[[EDIT_LINES]]
[[FOOTER]]
EOT_UNIQKI
}

sub print_updated{
	process_tpl("updated.tpl", shift, <<'EOT_UNIQKI');
[[HEADER]]
<section id="updated">
<h1>[[page_updated]]</h1>
[[save_your_changes_and_read_latest_version]]
<br />
<textarea accesskey="t" id="text" name="text" rows="24" cols="80">[[TEXT]]</textarea>
</section>
[[FOOTER]]
EOT_UNIQKI
}

sub print_wiki_view{
	# View templates are never served dynamically, so don't print a
	# content-type header
	$html_started = 1;
	process_tpl("wiki_view.tpl", shift, <<'EOT_UNIQKI');
[[HEADER]]
<article id="wiki-view">
<!-- start text -->
[[TEXT]]
<!-- end text -->
</article>
<nav id="wiki-menu">
<span class="write-access"><a accesskey="e" href="[[CGI]]/[[PAGE]]?wiki_edit">[[edit]]</a> .</span>
<a accesskey="d" href="[[CGI]]/[[PAGE]]?diff=-1">[[diff]]</a> .
<a accesskey="l" href="[[CGI]]?search=[[PAGE]]%5C.html&amp;link=1&amp;title=1">[[backlinks]]</a> .
<a accesskey="i" href="[[INDEX_PAGE]].html">[[index]]</a> .
<a class="visitor" accesskey="l" href="[[CGI]]/[[PAGE]]?login">[[login]]</a>
<a class="user" accesskey="l" href="[[CGI]]/[[PAGE]]?logout">[[logout]]</a>
</nav>
<footer id="metadata">
<div id="last-modified">[[last_modified]]</div>
<div id="parsing-time">[[parsing_time]]</div>
</footer>
[[FOOTER]]
EOT_UNIQKI
}

sub print_wiki_edit{
	process_tpl("wiki_edit.tpl", shift, <<'EOT_UNIQKI');
[[HEADER]]
<section id="wiki-edit">
<h1>[[wiki_edit_page]]</h1>
<form action="[[PAGE]]?wiki_edit" method="post" enctype="multipart/form-data">
<div>
<input type="hidden" id="version" name="version" value="[[VERSION]]" />
<textarea accesskey="t" id="text" name="text" rows="24" cols="80">[[TEXT]]</textarea>
<br />
<input accesskey="p" type="submit" id="preview" name="preview" value="[[preview]]" />
<input accesskey="s" type="submit" id="save" name="save" value="[[save]]" />
<input accesskey="e" type="button" id="save-edit" name="save-edit" value="[[save_edit]]" onclick="saveEdit();" />
<input accesskey="l" type="checkbox" id="live-preview" name="live-preview" onclick="livePreview();" /> [[live_preview]] .
<a accesskey="c" href="[[PAGE]].html">[[cancel]]</a> .
<a accesskey="i" href="[[INDEX_PAGE]].html">[[index]]</a>
<br />
[[file_upload]] <input accesskey="f" type="file" id="file" name="file" multiple="multiple" />
<br />
<div id="paste-image" style="display:none;">
<input accesskey="u" type="text" id="filename" name="filename" /> [[paste_image]]
<div id="image-uploaded" style="display:none;">[[image_uploaded]]</div>
</div>
<script>
listenToPasteImage('../[[CGI]]/[[PAGE]]?upload', [[VERSION]], '[[type_filename]]', '[[characters_not_allowed_in_filename]]');
</script>
</div>
</form>
</section>
[[FOOTER]]
EOT_UNIQKI
}

sub print_wiki_preview{
	process_tpl("wiki_preview.tpl", shift, <<'EOT_UNIQKI');
[[HEADER]]
<div id="wiki-preview-warning">[[preview_warning]]</div>
<article id="wiki-preview-main">
[[PREVIEW]]
</article>
[[WIKI_EDIT]]
[[FOOTER]]
EOT_UNIQKI
}

sub print_wiki_edit_lines{
	process_tpl("wiki_edit_lines.tpl", shift, <<'EOT_UNIQKI');
[[HEADER]]
<section id="wiki-edit">
<h1>[[wiki_edit_lines]]</h1>
<form action="[[PAGE]]?wiki_edit_lines" method="post" enctype="multipart/form-data">
<div>
<input type="hidden" id="version" name="version" value="[[VERSION]]" />
<input type="hidden" id="start" name="start" value="[[START]]" />
<input type="hidden" id="count" name="count" value="[[COUNT]]" />
<textarea accesskey="t" id="text" name="text" rows="24" cols="80">[[TEXT]]</textarea>
<br />
<input accesskey="p" type="submit" id="preview" name="preview" value="[[preview]]" />
<input accesskey="s" type="submit" id="save" name="save" value="[[save]]" />
<input accesskey="e" type="button" id="save-edit" name="save-edit" value="[[save_edit]]" onclick="saveEdit();" />
<input accesskey="l" type="checkbox" id="live-preview" name="live-preview" onclick="livePreview();" /> [[live_preview]] .
<a accesskey="c" href="[[PAGE]].html">[[cancel]]</a> .
<a accesskey="i" href="[[INDEX_PAGE]].html">[[index]]</a>
<br />
[[file_upload]] <input accesskey="f" type="file" id="file" name="file" multiple="multiple" />
<br />
<div id="paste-image" style="display:none;">
<input accesskey="u" type="text" id="filename" name="filename" /> [[paste_image]]
<div id="image-uploaded" style="display:none;">[[image_uploaded]]</div>
</div>
<script>
listenToPasteImage('../[[CGI]]/[[PAGE]]?upload', [[VERSION]], '[[type_filename]]', '[[characters_not_allowed_in_filename]]');
</script>
</div>
</form>
</section>
[[FOOTER]]
EOT_UNIQKI
}

sub print_wiki_preview_lines{
	process_tpl("wiki_preview_lines.tpl", shift, <<'EOT_UNIQKI');
[[HEADER]]
<div id="wiki-preview-warning">[[preview_warning]]</div>
<article id="wiki-preview-main">
[[PREVIEW]]
</article>
[[WIKI_EDIT_LINES]]
[[FOOTER]]
EOT_UNIQKI
}

sub print_css{
	process_tpl("u.css", shift, <<'EOT_UNIQKI');
body {
	font-family:		Georgia, Batang, serif;
	line-height:		1.3;
	--h1-font-size:		1.5em;
	--h1-font-size-diff:	calc(2em - var(--h1-font-size));
}
h1 {
	margin-top:		0px;
	font-size:		var(--h1-font-size);
}
h2 {
	font-size:		calc(1.5em - var(--h1-font-size-diff) / 1.33 * 0.83);
}
h3 {
	font-size:		calc(1.17em - var(--h1-font-size-diff) / 1.33 * 0.5);
}
h4 {
	font-size:		calc(1em - var(--h1-font-size-diff) / 1.33 * 0.33);
}
h5 {
	font-size:		calc(0.83em - var(--h1-font-size-diff) / 1.33 * 0.16);
}
h6 {
	font-size:		0.67em;
}
pre {
	background-color:	#eeeeee;
	border:			1px solid #dddddd;
	overflow:		auto;
}
table {
	border-collapse:	collapse;
}
table caption {
	text-align:		left;
	font-size:		smaller;
}
table th {
	border:			1px solid #999999;
	padding:		3px;
	background-color:	#eeeeee;
}
table td {
	border:			1px solid #999999;
	padding:		3px;
	word-break:		break-all;
}
figure {
}
figure img {
}
figure figcaption {
	font-size:		smaller;
}
a {
	color:			#007700;
	text-decoration:	none;
}
a[href*='://'] {
	color:			#0000cc;
}
a:hover {
	color:			black;
	text-decoration:	underline;
}
form {
	margin:			0px;
}
textarea {
	width:			100%;
}
ol ol {
	list-style-type:	lower-alpha;
}
ol ol ol {
	list-style-type:	lower-roman;
}

/******************************************************************************/
@media screen {
	body {
		background-color:	#eeeeee;
		margin:			auto;
	}
	#top {
	}
	#site-title {
		font-weight:		bold;
		font-size:		120%;
	}
	#site-title a {
		color:			black;
		text-decoration:	none;
	}
	#site-description {
		font-size:		smaller;
	}
	#main {
		background-color:	white;
		border:			1px solid #aaaaaa;
		box-shadow:		5px 5px 5px #aaaaaa;
		padding:		5px;
	}
	#login {
	}
	#manage-pages {
	}
	#manage-users {
	}
	#manage-myself {
	}
	#forgot-password {
	}
	#reset-password {
	}
	#message {
	}
	#menu {
	}
	#metadata {
		padding-top:		2px;
		font-size:		smaller;
	}
	#last-modified {
	}
	#parsing-time {
	}
	#bottom {
		margin-top:		5px;
		text-align:		right;
		font-size:		smaller;
		font-style:		italic;
	}
	#validators {
	}

/******************************************************************************/
	#view {
	}
	#edit {
	}
	#preview-warning {
		background-color:	red;
		padding:		5px;
		margin-bottom:		10px;
	}
	#preview-main {
	}
	#updated {
	}
	#file-links-example {
		margin-bottom:		30px;
	}

/******************************************************************************/
	#wiki-view {
		color:			#000000;
		border-bottom:		1px solid #999999;
		padding:		5px;
	}
	#wiki-edit {
	}
	#wiki-preview-warning {
		background-color:	red;
		padding:		5px;
		margin-bottom:		10px;
	}
	#wiki-preview-main {
	}
	#wiki-menu {
		padding:		5px 5px 0px 5px;
	}

/******************************************************************************/
	.edit-section {
		display:		none;
		text-align:		right;
		font-size:		70%;
	}
}
@media screen and (min-width: 640px) {
	body {
		max-width:		690px;
		line-height:		1.5;
	}
	#main {
		padding:		25px;
	}
}
@media print {
	#top {
		display:		none;
	}
	#menu {
		display:		none;
	}
	#metadata {
		padding-top:		2em;
		font-size:		smaller;
	}
	#parsing-time {
		display:		none;
	}
	#bottom {
		display:		none;
	}
	.edit-section a {
		display:		none;
	}
}
.section-number {
}
#toc {
}
.toc-heading {
	font-weight:		bold;
}
.toc-list, .toc-list ul {
	list-style-type:	none;
	padding-left:		1em;
}
.lot-heading {
	font-weight:		bold;
}
.lot-list {
	list-style-type:	none;
}
.lof-heading {
	font-weight:		bold;
}
.lof-list {
	list-style-type:	none;
}
.text-left {
	text-align:		left;
}
.text-center {
	text-align:		center;
}
.text-right {
	text-align:		right;
}

/******************************************************************************/
#diff {
}
.diff-unchanged {
	font-family:		monospace;
}
.diff-added {
	background-color:	#66cccc;
	color:			#000000;
	font-family:		monospace;
}
.diff-deleted {
	background-color:	#ff99cc;
	color:			#000000;
	font-family:		monospace;
	text-decoration:	line-through;
}
.diff-modified {
	background-color:	#cccccc;
	color:			#000000;
	font-family:		monospace;
}
.diff-modified-added {
	background-color:	#66cccc;
	color:			#000000;
	font-family:		monospace;
}
.diff-modified-deleted {
	background-color:	#ff99cc;
	color:			#000000;
	font-family:		monospace;
	text-decoration:	line-through;
}

/******************************************************************************/
#list {
}
.list-time {
	font-size:		70%;
	font-style:		italic;
}
.list-author {
	font-size:		70%;
	font-style:		italic;
}

/******************************************************************************/
.goto-input {
}

/******************************************************************************/
#search {
}
.search-highlight {
	font-weight:		bold;
}
.search-input {
}

/******************************************************************************/
.comment-website {
	display:		none;
}
.comment-input {
}
.comment-input textarea {
	width:			calc(100% - 2px);
	padding:		0px;
}
EOT_UNIQKI
}

sub print_js{
	process_tpl("u.js", shift, <<'EOT_UNIQKI');
const reAbsoluteURL = /^(?:https?:\/\/|\/)/;
let head = document.getElementsByTagName('head')[0];

function getAbsoluteURL(url){
	if(!url.match(reAbsoluteURL)){
		if(window.location.pathname.match(/^.*?\/u(?:\/.*)?$/))
			url = window.location.pathname.replace(/^(.*?\/)u(?:\/.*)?$/, '$1') + url;
		else
			url = window.location.pathname.replace(/^(.*\/).*$/, '$1') + url;
	}
	return url;
}

function loadJS(js, async, callback){
	let script = document.createElement('script');
	script.src = getAbsoluteURL(js);
	if(async)
		script.async = true;
	if(callback)
		script.onload = callback;
	head.appendChild(script);
}

function loadCSS(css, media){
	let link = document.createElement('link');
	link.rel = 'stylesheet';
	link.href = getAbsoluteURL(css);
	if(media)
		link.media = media;
	head.appendChild(link);
}

/* http://developer.mozilla.org/en/docs/AJAX:Getting_Started */
function ajaxRequest(url, data, func, mimeType){
	let xhr = null;

	/* Create an XMLHTTP instance */
	if(window.XMLHttpRequest){ /* Mozilla, Safari, ... */
		xhr = new XMLHttpRequest();
		if(xhr.overrideMimeType){
			/* Some web servers return a non-standard mime type. */
			xhr.overrideMimeType(mimeType || 'text/html');
		}
	}else
	if(window.ActiveXObject){ /* IE */
		try{
			xhr = new ActiveXObject('Msxml2.XMLHTTP');
		}
		catch(e){
		try{
			xhr = new ActiveXObject('Microsoft.XMLHTTP');
		}
		catch(e){}
		}
	}
	if(!xhr){
		alert('Cannot create an XMLHTTP instance.');
		return;
	}

	/* This function has no arguments. */
	xhr.onreadystatechange = function(){
		if(xhr.readyState != 4)
			return;
		if(xhr.status != 200)
			return;
		if(func)
			func(xhr);
	}

	let method = data == null ? 'GET' : 'POST';

	/* xhr.open(method, url, asynchronous) */
	xhr.open(method, url, true);

	/* xhr.send(POST data) */
	/* required even if the method is not POST. */
	xhr.send(data);
}

/* http://forum.java.sun.com/thread.jspa?threadID=696590&tstart=105 */
function ajaxResponseXML(xhr){
	let xml = null;

	if(xhr.responseXML)
		xml = xhr.responseXML;
	else
	if(xhr.responseText){
		xml = document.createElement('div');
		xml.innerHTML = xhr.responseText;

		/* Huidae Cho <https://idea.isnew.info> */
		xml.getElementByIdRecursively = function(childNodes, id){
			let element = null;
			for(let i = 0; i < childNodes.length; i++){
				if(id == childNodes[i].id)
					element = childNodes[i];
				else
					element = this.getElementByIdRecursively(childNodes[i].childNodes, id);
				if(element)
					break;
			}
			return element;
		}
		xml.getElementById = function(id){
			return this.getElementByIdRecursively(this.childNodes, id);
		}
	}

	return xml;
}

function removeElementsByClassName(className){
	[...document.getElementsByClassName(className)].reverse().forEach(function(element){
		element.parentNode.removeChild(element);
	});
}

function setElementsDisplayByClassName(className, display){
	[...document.getElementsByClassName(className)].forEach(function(element){
		element.style.display = display;
	});
}

function processMenu(xhr){
	let items = xhr.responseText.split(':');
	let user = items[0];
	let admin = items[1];
	let hasReadAccess = items[2];
	let hasWriteAccess = items[3];

	removeElementsByClassName(user == '' ? 'user' : 'visitor');
	if(admin == 0)
		removeElementsByClassName('admin');
	if(hasReadAccess == 0)
		removeElementsByClassName('read-access');
	if(hasWriteAccess == 0)
		removeElementsByClassName('write-access');
	else
		setElementsDisplayByClassName('edit-section', 'block');
}

function addEvent(el, event, func){
	if(el.addEventListener)
		el.addEventListener(event, func);
	else
	if(el.attachEvent)
		el.attachEvent('on' + event, func);
}

function removeEvent(el, event, func){
	if(el.removeEventListener)
		el.removeEventListener(event, func);
	else
	if(el.detachEvent)
		el.detachhEvent('on' + event, func);
}

function windowOnLoad(func){
	addEvent(window, 'load', func);
}

function listenToPasteImage(requestURL, version, typeFilename, charactersNotAllowedInFilename){
	let filenameEl = document.getElementById('filename');
	if(!filenameEl)
		return;

	let wiki = requestURL.indexOf('?wiki_') != -1;

	if(wiki && version > 1)
		document.getElementById('paste-image').style.display = 'block';

	let imageUploadedEl = document.getElementById('image-uploaded');
	let fileLinkExampleEl = document.getElementById('file-links-example');
	addEvent(filenameEl, 'paste', function(e){
		if(!e.clipboardData || !e.clipboardData.items ||
		   e.clipboardData.items.length != 1 ||
		   e.clipboardData.items[0].type.indexOf('image/') == -1)
			return;

		let item = e.clipboardData.items[0];
		let extension = item.type.substr(6);
		let filename = filenameEl.value.
			replace(new RegExp('\\.' + extension + '$', 'i'), '');
		if(!filename){
			alert(typeFilename);
			return;
		}
		if(filename.match(/[\\/:*?"<>|]/)){
			alert(charactersNotAllowedInFilename);
			return;
		}

		filename += '.' + extension;
		filenameEl.value = filename;

		let blob = e.clipboardData.items[0].getAsFile();
		let formData = new FormData();
		formData.append('file', blob, filename);
		ajaxRequest(requestURL, formData, function(xhr){
			if(wiki){
				let xml = ajaxResponseXML(xhr);
				imageUploadedEl.style.display = 'block';
				fileLinkExampleEl.innerHTML = '{' + xml.getElementById('file-links-example').innerHTML + '}';
			}else{
				imageUploadedEl.style.display = 'block';
				fileLinkExampleEl.innerHTML = '{{{' + filename + '}}}';
			}
		});
	});
}

function processPreview(callback){
	let textEl = document.getElementById('text');
	let version = document.getElementById('version').value;
	let text = textEl.value;
	let preview = document.getElementById('preview').value;
	let fileEl = document.getElementById('file');

	let requestURL = textEl.form.action;
	let formData = new FormData();
	formData.append('version', version);
	formData.append('text', text);
	formData.append('preview', preview);
	[...fileEl.files].forEach(function(file){
		formData.append('file', file);
	});

	ajaxRequest(requestURL, formData, function(xhr){
		fileEl.value = null;
		let wiki = requestURL.indexOf('?wiki_') != -1;
		let preview = (wiki ? 'wiki-' : '') + 'preview';
		let previewMainId = preview + '-main';
		let previewWarningEl = document.getElementById(preview + '-warning');
		let previewMainEl = document.getElementById(previewMainId);
		let xml = ajaxResponseXML(xhr);
		previewWarningEl.style.display = 'block';
		let first = previewMainEl.childNodes.length == 0;
		while(previewMainEl.firstChild)
			previewMainEl.removeChild(previewMainEl.firstChild);
		[...xml.getElementById(previewMainId).childNodes].forEach(function(node){
			let childNode = node;
			if(node.nodeName.toLowerCase() == 'script'){
				if(!first)
					return;
				childNode = document.createElement('script');
				[...node.attributes].forEach(function(attr){
					childNode.setAttribute(attr.name, attr.value);
				});
			}
			previewMainEl.appendChild(childNode);
		});
		if(callback)
			callback();
	});
}

function saveEdit(){
	let saveEditEl = document.getElementById('save-edit');
	saveEditEl.disabled = true;
	let saveEdit = saveEditEl.value;
	saveEditEl.value = '...';

	let textEl = document.getElementById('text');
	let text = textEl.value;
	let versionEl = document.getElementById('version');
	let version = parseInt(versionEl.value);
	let startEl = document.getElementById('start');
	let countEl = document.getElementById('count');
	let save = document.getElementById('save').value;
	let fileEl = document.getElementById('file');

	let requestURL = textEl.form.action;
	let formData = new FormData();
	formData.append('version', version);
	if(startEl)
		formData.append('start', startEl.value);
	if(countEl)
		formData.append('count', countEl.value);
	formData.append('text', text);
	formData.append('save', save);
	[...fileEl.files].forEach(function(file){
		formData.append('file', file);
	});

	ajaxRequest(requestURL, formData, function(xhr){
		fileEl.value = null;
		let xml = ajaxResponseXML(xhr);
		let updatedEl = xml.getElementById('updated');
		if(!updatedEl){
			saveEditEl.disabled = false;
			saveEditEl.value = saveEdit;
			if(saveEditedText != text){
				versionEl.value = version + 1;
				saveEditedText = text;
			}
		}else{
			saveEditEl.value = '!!!';
			let editEl = textEl.form.parentNode;
			let lastNode = textEl.form;
			[...updatedEl.childNodes].reverse().forEach(function(node){
				let nodeName = node.nodeName.toLowerCase();
				if(nodeName != 'h1' && nodeName != 'br' && nodeName != 'textarea'){
					editEl.insertBefore(node, lastNode);
					lastNode = node;
				}
			});
		}
	});
}

let saveEditedText;

let uQuery = window.location.search.match(/^\?u-(([^=]+).*)$/);
if(uQuery && uQuery[2].indexOf('delete') == -1)
	window.location.href = window.location.origin + '/u' + window.location.pathname + '?' + uQuery[1];
else if(window.location.search.match(/^\?(wiki_)?edit(_lines)?(=|$)/)){
	let livePreview;
	windowOnLoad(function(){
		let textEl = document.getElementById('text');
		saveEditedText = textEl.value;
		let livePreviewEl = document.getElementById('live-preview');
		let keyupHandler;
		let callback;
		function onTextKeyup(){
			if(keyupHandler)
				clearTimeout(keyupHandler);
			keyupHandler = setTimeout(function(){
				processPreview(callback);
			}, 1000);
		}
		livePreview = function(func){
			callback = func;
			if(livePreviewEl.checked){
				addEvent(textEl, 'keyup', onTextKeyup);
				onTextKeyup();
			}else
				removeEvent(textEl, 'keyup', onTextKeyup);
		}
	});
}
EOT_UNIQKI
}

#-------------------------------------------------------------------------------
# Text file subroutines
sub lcs{
	my ($c0, $c1) = @_;
	my @lcs;
	my $s;
	for($s = 0; $s <= $#$c0 && $s <= $#$c1; $s++){
		last if $$c0[$s] ne $$c1[$s];
	}
	my ($e0, $e1);
	for($e0 = $#$c0, $e1 = $#$c1; $e0 > $s && $e1 > $s; $e0--, $e1--){
		last if $$c0[$e0] ne $$c1[$e1];
	}
	my ($m, $n);
	for($m = $s; $m <= $e0; $m++){
		for($n = $s; $n <= $e1; $n++){
			if($$c0[$m] eq $$c1[$n]){
				if($m && $n){
					$lcs[$m][$n] = $lcs[$m-1][$n-1] + 1;
				}else{
					$lcs[$m][$n] = 1;
				}
			}elsif($m && $n && $lcs[$m][$n-1]+0 > $lcs[$m-1][$n]+0){
				$lcs[$m][$n] = $lcs[$m][$n-1] + 0;
			}else{
				if($m){
					$lcs[$m][$n] = $lcs[$m-1][$n] + 0;
				}else{
					$lcs[$m][$n] = 0;
				}
			}
		}
	}
	my $i = $lcs[$e0][$e1];
	my @delta;
	$delta[$i] = ($e0+1).",".($e1+1);
	for($m = $e0, $n = $e1; $i > 0 && $m >= $s && $n >= $s; $m--, $n--){
		if($$c0[$m] eq $$c1[$n]){
			$delta[--$i] = "$m,$n";
		}elsif($lcs[$m][$n-1] > $lcs[$m-1][$n]){
			$m++;
		}else{
			$n++;
		}
	}
	return ($s, @delta);
}

sub diff{
	my @line0 = split /\n/, $_[0], -1; $#line0--;
	my @line1 = split /\n/, $_[1], -1; $#line1--;
	my ($s, @delta) = lcs(\@line0, \@line1);
	my ($m, $n) = ($s, $s);
	my $diff = "";
	for(my $i = 0; $i <= $#delta; $i++, $m++, $n++){
		my ($x, $y) = split /,/, $delta[$i];
		if($x > $m){
			for(; $m < $x; $m++){
				$diff .= "-$m\n";
			}
		}
		if($y > $n){
			for(; $n < $y; $n++){
				$diff .= "+$m $line1[$n]\n";
			}
		}
	}
	return $diff;
}

sub patch{
	my @line0 = split /\n/, $_[0], -1; $#line0--;
	my @lined = split /\n/, $_[1];
	my $line0p = "";
	for(my $i = 0; $i <= $#lined; $i++){
		if($lined[$i] =~ /^\+/){
			my $p = index $lined[$i], " ";
			my $j = substr $lined[$i], 1, $p - 1;
			my $l = substr $lined[$i], $p + 1;
			if($j){
				$line0[$j-1] .= "\n$l";
			}else{
				$line0p .= "$l\n";
			}
		}else{
			$line0[substr $lined[$i], 1] = "\x00";
		}
	}
	$line0[0] = "$line0p$line0[0]";
	my $str = join "\n", @line0;
	$str .= "\n";
	$str =~ s/\x00\n//g;
	return $str;
}

sub save{
	my ($PAGE, $TEXT) = @_;
	my $version = 1;
	my $txtv;

	if(-f "$PAGE.txt"){
		local *FH;
		if(open FH, "$PAGE.txt.v"){
			my $line = <FH>;
			local $/ = undef;
			$txtv = $line.<FH>;
			close FH;
			my @items = split /:/, $line;
			$version = $items[0];
		}else{
			my $time = (stat "$PAGE.txt")[9];
			$txtv = "${version}:${time}::\n";
		}
		my $text = read_file("$PAGE.txt");

		my $diff = diff($TEXT, $text);
		if($diff eq ""){
			$rebuild = 1;
			return;
		}

		$version++;
		my $time = time;
		$txtv = "$version:$time:$REMOTE_ADDR:$USER\n$diff\x00\n$txtv";
	}else{
		my $time = time;
		$txtv = "$version:$time:$REMOTE_ADDR:$USER\n";
	}

	write_file("$PAGE.txt.v", $txtv);
	$rebuild = 1 if write_file("$PAGE.txt", $TEXT);
}

sub save_lines{
	my ($PAGE, $START, $COUNT, $TEXT) = @_;
	my $version = 1;
	my $txtv;

	die_message("page_not_found", $PAGE) unless page_exists();

	local *FH;
	if(open FH, "$PAGE.txt.v"){
		my $line = <FH>;
		local $/ = undef;
		$txtv = $line.<FH>;
		close FH;
		my @items = split /:/, $line;
		$version = $items[0];
	}else{
		my $time = (stat "$PAGE.txt")[9];
		$txtv = "${version}::$time\n";
	}
	my $text = read_file("$PAGE.txt");

	$TEXT = edit_lines("$PAGE.txt", $START, $COUNT, $TEXT);

	my $diff = diff($TEXT, $text);
	if($diff eq ""){
		$rebuild = 1;
		return;
	}

	$version++;
	my $time = time;
	$txtv = "$version:$time:$REMOTE_ADDR:$USER\n$diff\x00\n$txtv";

	write_file("$PAGE.txt.v", $txtv);
	$rebuild = 1 if write_file("$PAGE.txt", $TEXT);
}

sub get_version{
	my $PAGE = shift;
	local *FH;
	my $version = 0;
	if(open FH, "$PAGE.txt.v"){
		my @items = split /:/, <FH>;
		close FH;
		die_message("internal_errors") unless -f "$PAGE.txt";
		$version = $items[0];
	}elsif(-f "$PAGE.txt"){
		$version = 1;
	}
	return $version;
}

sub get_page_info{
	my $PAGE = shift;
	my $v = shift;
	my $cur_ver = get_version($PAGE);
	my $ver = $v > 0 ? $v : $cur_ver + $v;
	my %page_info;
	return %page_info unless $ver > 0 && $ver <= $cur_ver;
	local *FH;
	if(open FH, "$PAGE.txt.v"){
		local $/ = "\x00\n";
		my $line;
		while(<FH>){
			/^([0-9]+):/;
			if($ver >= $1){
				($line = $_) =~ s/\n.*$//s;
				last;
			}
		}
		close FH;
		die_message("internal_errors") unless -f "$PAGE.txt";
		my @items = split /:/, $line;
		return %page_info if $ver != $items[0];
		$page_info{version} = $items[0];
		$page_info{time} = $items[1];
		$page_info{ip} = $items[2];
		$page_info{user} = $items[3];
	}
	return %page_info;
}

sub get_time{
	my $PAGE = shift;
	my $v = shift;
	my %page_info = get_page_info($PAGE, $v);
	return $page_info{time};
}

sub get_ip_address{
	my $PAGE = shift;
	my $v = shift;
	my %page_info = get_page_info($PAGE, $v);
	return $page_info{ip};
}

sub get_user{
	my $PAGE = shift;
	my $v = shift;
	my %page_info = get_page_info($PAGE, $v);
	return $page_info{user};
}

sub get_author{
	my $PAGE = shift;
	my $v = shift;
	my $author = get_msg("unknown_author");
	my $user = get_user($PAGE, $v);
	if($user ne ""){
		my %user_info = find_user_info($user);
		$author = $user_info{name};
	}
	return $author;
}

sub lock_file{
	my $file = shift;
	my $timeout = 60;
	my $i = 0;
	while(-f "$file.lock"){
		die_message("internal_errors") if ++$i > $timeout;
		sleep 1;
	}
	$locked_files{$file} = 1;
	die_message("internal_errors") unless write_file("$file.lock");
}

sub unlock_file{
	my $file = shift;
	unlink "$file.lock";
	delete $locked_files{$file};
}

sub preview{
	local $PAGE = shift;
	local $TEXT = shift;
	my $uploaded = shift;
	my $wiki_edit = shift;
	my $txt;

	# preview the entire document
	local $preview = 1;
	local $wiki;
	local $html_started = 0;
	local $header_printed = 0;
	local $footer_printed = 0;
	local $TITLE;
	local $PREVIEW;

	write_file(\$txt, ($wiki_edit ? "#!wiki\n" : "")."$TEXT\n");

	$PREVIEW = parse_file(\$txt);
	chomp $PREVIEW;

	unless(defined $TITLE){
		if($PAGE eq $INDEX_PAGE){
			($TITLE = $SITE_TITLE) =~ s/<[^>]*>//g;
		}else{
			$TITLE = $PAGE;
		}
	}
	$PREVIEW = $uploaded.$PREVIEW;
	$TEXT =~ s/&/&amp;/g; $TEXT =~ s/</&lt;/g; $TEXT =~ s/>/&gt;/g;

	if($wiki_edit){
		print_wiki_preview();
	}else{
		print_preview();
	}
}

sub preview_lines{
	local $PAGE = shift;
	local $START = shift;
	local $COUNT = shift;
	local $TEXT = shift;
	my $uploaded = shift;
	my $wiki_edit = shift;
	my $txt;

	# start previewing partially, but not the current section yet
	local $preview = 2;
	local $wiki;
	local $html_started = 0;
	local $header_printed = 0;
	local $footer_printed = 0;
	local $TITLE;
	local $PREVIEW;

	write_file(\$txt, read_lines("$PAGE.txt", 1, $START - 1)."$TEXT\n");

	$PREVIEW = parse_file(\$txt, $START);
	chomp $PREVIEW;

	unless(defined $TITLE){
		if($PAGE eq $INDEX_PAGE){
			($TITLE = $SITE_TITLE) =~ s/<[^>]*>//g;
		}else{
			$TITLE = $PAGE;
		}
	}
	$PREVIEW = $uploaded.$PREVIEW;
	$TEXT =~ s/&/&amp;/g; $TEXT =~ s/</&lt;/g; $TEXT =~ s/>/&gt;/g;

	if($wiki_edit){
		print_wiki_preview_lines();
	}else{
		print_preview_lines();
	}
}

sub make_html{
	local $PAGE = shift;

	# not preview
	local $preview = 0;
	local $wiki;
	local $html_started = 0;
	local $header_printed = 0;
	local $footer_printed = 0;
	local $AUTHOR = get_author($PAGE);
	local $TIME = format_time((stat "$PAGE.txt")[9]);
	local $TITLE;
	my $start_time = Time::HiRes::time() if $show_parsing_time;
	local $TEXT = parse_file("$PAGE.txt");
	local $PARSING_TIME = sprintf "%.3f", Time::HiRes::time() - $start_time
		if $show_parsing_time;
	local *FH;

	unless(defined $TITLE){
		if($PAGE eq $INDEX_PAGE){
			($TITLE = $SITE_TITLE) =~ s/<[^>]*>//g;
		}else{
			$TITLE = $PAGE;
		}
	}

	my $html;
	open FH, ">", \$html; my $fh = select FH;
	if($wiki){
		print_wiki_view();
	}else{
		print_view();
	}
	close FH; select $fh;
	$html =~ s/\r//g;

	lock_file("$PAGE.html");
	write_file("$PAGE.html", $html);
	chmod 0755, "$PAGE.html" if $hosting eq "awardspace";
	unlock_file("$PAGE.html");
}

sub rmrf{
	local *DH;
	foreach(@_){
		if(-f $_){
			unlink $_;
		}elsif(-d $_){
			my $dir = $_;
			opendir DH, $dir;
			my @i = map {"$dir/$_"} grep !/^\.{1,2}$/, readdir DH;
			closedir DH;
			rmrf(@i);
			rmdir $dir;
		}
	}
}

sub rmdirp{
	foreach(@_){
		my $dir = $_;
		while(index($dir, "/") >= 0){
			rmdir $dir;
			$dir =~ s#/[^/]*$##;
		}
		rmdir $dir;
	}
}

sub find{
	my $file = shift;
	if(-d $file){
		local *DH;
		my @list;
		opendir DH, $file;
		foreach(sort readdir DH){
			next if $_ eq "." || $_ eq "..";
			push @list, find("$file/$_");
		}
		closedir DH;
		return @list;
	}elsif(-f $file){
		return $file;
	}
}

sub get_var{
	my (%var, $v);
	foreach(split /&/, $QUERY_STRING){
		if(/^([^=]*)=(.*)$/){
			$v = $1; $var{$v} = $2;
			$var{$v} =~ y/+/ /; $var{$v} =~ s/%0D//g;
			$var{$v} = decode_url($var{$v});
		}
	}
	return %var if $CONTENT_LENGTH eq "" || $CONTENT_LENGTH <= 0;

	my $content = "";
	my $total_len = 0;
	while(my $buf_len = read STDIN, my $buf, $CONTENT_LENGTH - $total_len){
		$total_len += $buf_len;
		$content .= $buf;
		die_message("internal_errors") if $total_len > $CONTENT_LENGTH;
		last if $total_len == $CONTENT_LENGTH;
	}
	if($CONTENT_TYPE eq "application/x-www-form-urlencoded"){
		foreach(split /&/, $content){
			/^([^=]*)=(.*)$/;
			$v = $1; $var{$v} = $2;
			$var{$v} =~ y/+/ /; $var{$v} =~ s/%0D//g;
			$var{$v} = decode_url($var{$v});
		}
	}elsif($CONTENT_TYPE =~ m#^multipart/form-data; boundary=(.*)$#){
		my $boundary = $1;
		my $file_no = 2;
		$content = substr $content, length($boundary) + 4,
			$CONTENT_LENGTH - 2 * (length($boundary) + 4) - 4;
		foreach(split /\r\n--$boundary\r\n/, $content){
			my ($header, $body) = /^(.*?)\r\n\r\n(.*)$/s;
			$header =~ / name="(.*?)"/;
			my $name = $1;
			if($header =~ / filename="(.*?)"/){
				$name = "$name$file_no" if exists $var{$name};
				($var{$name} = $1) =~ s#^.*[/\\]##;
				$var{"$name="} = $body;
				$file_no++;
			}else{
				$body =~ s/\r//g;
				$var{$name} = $body;
			}
		}
	}
	return %var;
}

sub get_cookie_attributes{
	my $subdomains = 0;
	my $paths = "";
	foreach my $item (split /:/, $SHARE_COOKIES){
		if($item eq "subdomains"){
			$subdomains = 1;
		}elsif($item eq "subpaths" || $item eq "all_paths"){
			$paths = $item;
		}
	}
	(my $script_dir = $SCRIPT_NAME) =~ s#[^/]*$##;

	my $cookie_attributes = "";
	$cookie_attributes .= "domain=$HTTP_HOST; " if $subdomains;
	$cookie_attributes .= $paths eq "all_paths" ? "path=/; " :
		($paths eq "subpaths" && $doc_root eq "" ?
			"path=$script_dir; " : "path=$SCRIPT_NAME; ");
	$cookie_attributes .= "secure; " if $HTTPS eq "on";
	$cookie_attributes .= "httponly";

	return $cookie_attributes;
}

sub set_cookie{
	my ($session_id, $expires) = @_;

	my @t = gmtime $expires;
	my @m = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);
	my @w = qw(Sun Mon Tue Wed Thu Fri Sat);
	my $expires = sprintf "%s, %02d-%s-%d %02d:%02d:%02d GMT",
		$w[$t[6]], $t[3], $m[$t[4]], $t[5]+1900, $t[2], $t[1], $t[0];

	print "Set-Cookie: uniqki=$session_id; expires=$expires; ".
		"$cookie_attributes\n";
}

sub clear_cookie{
	print "Set-Cookie: uniqki=; expires=Tue, 01-Jan-1980 00:00:00 GMT; ".
		"$cookie_attributes\n";
}

sub print_list_users{
	my $TITLE = get_msg("all_users");

	print qq(<div id="list">\n);
	print qq(<h1>$TITLE</h1>\n);

	return unless -f $PASSWORD_FILE;

	print qq(<ul>\n);
	local *FH;
	open FH, $PASSWORD_FILE;
	while(<FH>){
		my @items = split /:/;
		my $user = $items[0];
		my $pw = $items[1];
		my $group = $items[2];
		my $email = $items[3];
		my $name = $items[4];
		my $token = $items[5];
		print qq(<li>$user ($name), $group, $email</li>\n);
	}
	close FH;
	print qq(</ul>\n</div>\n);
}

sub find_user_info{
	my $user = shift;
	my %user_info;
	local *FH;

	my $method = 0;
	# $method=0: No user found
	# $method=1: Use $PASSWORD_FILE
	# $method=2: Use $adminpw

	if($PASSWORD_FILE eq ""){
		# No password file is specified in u.cfg.  Since the password
		# file in the default config is u.pw, an empty $PASSWORD_FILE
		# was assigned by the user.
		if($adminpw eq $tmp_adminpw){
			# If $adminpw is still temporary, this situation can be
			# very dangerous because anyone can login using the
			# public temporary password.  Do not allow any login in
			# this case.
		}else{
			# If $adminpw has been changed, use this password
			$method = 2;
		}
	}elsif(-f $PASSWORD_FILE){
		# Use the password file
		$method = 1;
	}elsif($adminpw eq $tmp_adminpw){
		# Password file does not exist and $adminpw is temporary.  The
		# first run of this script is this case.  Create the password
		# file only for the login action immediately before checking
		# credentials against the temporary password to avoid timing
		# attacks.
		$method = 2;
	}else{
		# Password file does not exist and $adminpw has been changed.
		# Assume that the user deleted the password file intentionally
		# for single file operations.
		$method = 2;
	}
	return %user_info if $method == 0;

	my $userline = "";
	if($method == 1){
		open FH, $PASSWORD_FILE;
		my @lines = grep /^$user:/, <FH>;
		close FH;

		if($#lines == 0){
			$userline = $lines[0];
			$userline =~ y/\r\n//d;
		}
	}elsif($method == 2 &&
	       "$user:" eq substr $adminpw, 0, length("$user:")){
		$userline = $adminpw;
	}
	return %user_info if $userline eq "";

	my @items = split /:/, $userline;
	$user_info{user} = $items[0];
	$user_info{pw} = $items[1];
	$user_info{group} = $items[2];
	$user_info{email} = $items[3];
	$user_info{name} = $items[4];
	$user_info{token} = $items[5];

	return %user_info;
}

sub find_user_info_by_email_address{
	my $email = shift;
	my %user_info;
	local *FH;

	my $method = 0;
	# $method=0: No user found
	# $method=1: Use $PASSWORD_FILE
	# $method=2: Use $adminpw

	if($PASSWORD_FILE eq ""){
		# No password file is specified in u.cfg.  Since the password
		# file in the default config is u.pw, an empty $PASSWORD_FILE
		# was assigned by the user.
		if($adminpw eq $tmp_adminpw){
			# If $adminpw is still temporary, this situation can be
			# very dangerous because anyone can login using the
			# public temporary password.  Do not allow any login in
			# this case.
		}else{
			# If $adminpw has been changed, use this password
			$method = 2;
		}
	}elsif(-f $PASSWORD_FILE){
		# Use the password file
		$method = 1;
	}elsif($adminpw eq $tmp_adminpw){
		# Password file does not exist and $adminpw is temporary.  The
		# first run of this script is this case.  Create the password
		# file only for the login action immediately before checking
		# credentials against the temporary password to avoid timing
		# attacks.
		$method = 2;
	}else{
		# Password file does not exist and $adminpw has been changed.
		# Assume that the user deleted the password file intentionally
		# for single file operations.
		$method = 2;
	}
	return %user_info if $method == 0;

	(my $escaped_email = $email) =~ s/\./\\./g;

	my $userline = "";
	if($method == 1){
		open FH, $PASSWORD_FILE;
		my @lines = grep /:$escaped_email(?::[^:]*){2}$/i, <FH>;
		close FH;

		if($#lines == 0){
			$userline = $lines[0];
			$userline =~ y/\r\n//d;
		}
	}elsif($method == 2 &&
	       $adminpw =~ /:$escaped_email(?::[^:]*){2}$/i){
	       $userline = $adminpw;
	}
	return %user_info if $userline eq "";

	my @items = split /:/, $userline;
	$user_info{user} = $items[0];
	$user_info{pw} = $items[1];
	$user_info{group} = $items[2];
	$user_info{email} = $items[3];
	$user_info{name} = $items[4];
	$user_info{token} = $items[5];

	return %user_info;
}

sub find_user_info_by_password_reset_token{
	my $token = shift;
	my %user_info;
	local *FH;

	my $method = 0;
	# $method=0: No user found
	# $method=1: Use $PASSWORD_FILE
	# $method=2: Use $adminpw

	if($PASSWORD_FILE eq ""){
		# No password file is specified in u.cfg.  Since the password
		# file in the default config is u.pw, an empty $PASSWORD_FILE
		# was assigned by the user.
		if($adminpw eq $tmp_adminpw){
			# If $adminpw is still temporary, this situation can be
			# very dangerous because anyone can login using the
			# public temporary password.  Do not allow any login in
			# this case.
		}else{
			# If $adminpw has been changed, use this password
			$method = 2;
		}
	}elsif(-f $PASSWORD_FILE){
		# Use the password file
		$method = 1;
	}elsif($adminpw eq $tmp_adminpw){
		# Password file does not exist and $adminpw is temporary.  The
		# first run of this script is this case.  Create the password
		# file only for the login action immediately before checking
		# credentials against the temporary password to avoid timing
		# attacks.
		$method = 2;
	}else{
		# Password file does not exist and $adminpw has been changed.
		# Assume that the user deleted the password file intentionally
		# for single file operations.
		$method = 2;
	}
	return %user_info if $method != 1;

	(my $escaped_token = $token) =~ s/\./\\./g;

	my $userline = "";
	open FH, $PASSWORD_FILE;
	my @lines = grep /:$escaped_token$/, <FH>;
	close FH;

	if($#lines == 0){
		$userline = $lines[0];
		$userline =~ y/\r\n//d;
	}
	return %user_info if $userline eq "";

	my @items = split /:/, $userline;
	$user_info{user} = $items[0];
	$user_info{pw} = $items[1];
	$user_info{group} = $items[2];
	$user_info{email} = $items[3];
	$user_info{name} = $items[4];
	$user_info{token} = $items[5];

	return %user_info;
}

sub authenticate_user{
	my ($user, $pw, $logout_others) = @_;

	my $method = 0;
	# $method=0: Login not allowed
	# $method=1: Create $PASSWORD_FILE and force to change the password
	# $method=2: Use $PASSWORD_FILE
	# $method=3: Use $adminpw

	if($PASSWORD_FILE eq ""){
		# No password file is specified in u.cfg.  Since the password
		# file in the default config is u.pw, an empty $PASSWORD_FILE
		# was assigned by the user.
		if($adminpw eq $tmp_adminpw){
			# If $adminpw is still temporary, this situation can be
			# very dangerous because anyone can login using the
			# public temporary password.  Do not allow any login in
			# this case.
			die_message("login_not_allowed");
		}else{
			# If $adminpw has been changed, use this password
			$method = 3;
		}
	}elsif(-f $PASSWORD_FILE){
		# Use the password file
		$method = 2;
	}elsif($adminpw eq $tmp_adminpw){
		# Password file does not exist and $adminpw is temporary.  The
		# first run of this script is this case.  Create the password
		# file only for the login action immediately before checking
		# credentials against the temporary password to avoid timing
		# attacks.
		if($QUERY_STRING eq "login"){
			write_file($PASSWORD_FILE, "$adminpw\n");
			$method = 1;
		}
	}else{
		# Password file does not exist and $adminpw has been changed.
		# Assume that the user deleted the password file intentionally
		# for single file operations.
		$method = 3;
	}

	my %user_info = find_user_info($user);
	my $usr = $user_info{user};
	my $saved_pw = $user_info{pw};
	my $group = $user_info{group};
	my $email = $user_info{email};
	my $name = $user_info{name};
	my $token = $user_info{token};
	if(!defined $usr || $saved_pw eq "blocked"){
		close_session();
		die_message("login_failed");
	}

	my $salt = pack("H*", substr $saved_pw, 0, 16);
	if($saved_pw ne hash_password($user, $pw, $salt)){
		close_session();
		die_message("login_failed");
	}

	# If admin password is not temporary, the password is secure
	my $userpw = "$user:$saved_pw:";
	$insecure_pw = 0 if $userpw ne substr $tmp_adminpw, 0, length($userpw);

	clear_user_sessions($user) if $logout_others eq "1";
	start_session($user);

	# Force to change the password
	die_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE?manage_myself")
		if $insecure_pw;

	clear_password_reset_token($token);

	$USER = $user;
	$NAME = $name;
	$admin = 1 if $group eq "admin";
}

sub find_session_info{
	my $session_id = shift;
	local *FH;

	return if !-f $sessions_file || !is_session_id($session_id);

	open FH, $sessions_file;
	my @lines = grep /^$session_id:/, <FH>;
	close FH;
	return if $#lines == -1;

	return split /:/, $lines[0];
}

sub start_session{
	my $user = shift;
	my ($session_id, $expires) = generate_session_id($user);
	set_cookie($session_id, $expires);
}

sub renew_session{
	my $session_id = shift;

	my $expires = time + $INACTIVE_TIMEOUT * 60;
	my $new_sessions = "";
	my $renewed = 0;

	lock_file($sessions_file);
	local *FH;
	open FH, $sessions_file;
	while(<FH>){
		if(/^$session_id:/){
			$renewed = 1;
			my @items = split /:/;
			$_ = "$session_id:$items[1]:$items[2]:$expires\n";
		}
		$new_sessions .= $_;
	}
	close FH;

	if($renewed){
		write_file($sessions_file, $new_sessions);
		set_cookie($session_id, $expires);
	}
	unlock_file($sessions_file);
}

sub close_session{
	clear_cookie();

	my $cookie = $HTTP_COOKIE; $cookie =~ s/; /\n/g;
	return unless $cookie =~ /^uniqki=(.+)$/m;

	my $session_id = $1;
	return if !-f $sessions_file || !is_session_id($session_id);

	my $new_sessions = "";
	my $deleted = 0;

	lock_file($sessions_file);
	local *FH;
	open FH, $sessions_file;
	while(<FH>){
		if(/^$session_id:/){
			$deleted = 1;
			next;
		}
		$new_sessions .= $_;
	}
	close FH;

	write_file($sessions_file, $new_sessions) if $deleted;
	unlock_file($sessions_file);
}

sub clear_user_sessions{
	my $user = shift;

	unless(defined $user){
		clear_cookie();
		my $cookie = $HTTP_COOKIE; $cookie =~ s/; /\n/g;
		$cookie =~ /^uniqki=(.+)$/m;
		my $session_id = $1;
		(my $sess, $user) = find_session_info($session_id);
	}
	return if !-f $sessions_file || !is_username($user);

	my $new_sessions = "";
	my $deleted = 0;

	lock_file($sessions_file);
	local *FH;
	open FH, $sessions_file;
	while(<FH>){
		if(/^[^:]*:$user:/){
			$deleted = 1;
			next;
		}
		$new_sessions .= $_;
	}
	close FH;

	write_file($sessions_file, $new_sessions) if $deleted;
	unlock_file($sessions_file);
}

sub clear_expired_sessions{
	return if !-f $sessions_file;

	my $new_sessions = "";
	my $deleted = 0;
	my $time = time;

	lock_file($sessions_file);
	local *FH;
	open FH, $sessions_file;
	while(<FH>){
		if(/:([0-9]+)$/ && $time > $1){
			$deleted = 1;
			next;
		}
		$new_sessions .= $_;
	}
	close FH;

	write_file($sessions_file, $new_sessions) if $deleted;
	unlock_file($sessions_file);
}

sub handle_session{
	my $cookie = $HTTP_COOKIE; $cookie =~ s/; /\n/g;
	unless($cookie =~ /^uniqki=(.+)$/m){
		clear_cookie();
		return;
	}

	my $session_id = $1;
	my ($sess, $user, $status, $expires) = find_session_info($session_id);

	unless(defined $sess){
		clear_cookie();
		return;
	}
	if($status ne "active" || time > $expires){
		close_session();
		return;
	}
	my %user_info = find_user_info($user);
	my $usr = $user_info{user};
	my $pw = $user_info{pw};
	my $group = $user_info{group};
	my $email = $user_info{email};
	my $name = $user_info{name};
	my $token = $user_info{token};
	unless(defined $usr){
		close_session();
		return;
	}

	renew_session($session_id);

	# If admin password is not temporary, the password is secure
	my $userpw = "$user:$pw:";
	$insecure_pw = 0 if $userpw ne substr $tmp_adminpw, 0, length($userpw);

	$USER = $user;
	$NAME = $name;
	$admin = 1 if $group eq "admin";
}

sub clear_password_reset_token{
	my $token = shift;
	return if !-f $PASSWORD_FILE || $token !~ /^[a-zA-Z0-9]{64}\.[0-9]+$/;

	my $new_pw = "";
	my $cleared = 0;

	lock_file($PASSWORD_FILE);
	local *FH;
	open FH, $PASSWORD_FILE;
	while(<FH>){
		if(":$token\n" eq substr $_, length($_) - length(":$token\n")){
			my @items = split /:/;
			$cleared = 1;
			$_ = "$items[0]:$items[1]:$items[2]:$items[3]:$items[4]:\n";
		}
		$new_pw .= $_;
	}
	close FH;

	write_file($PASSWORD_FILE, $new_pw) if $cleared;
	unlock_file($PASSWORD_FILE);
}

sub generate_random_string{
	my $len = shift;
	# http://www.perlmonks.org/?node_id=233023
	my @chars = ("a".."z", "A".."Z", "0".."9");
	my $str;
	$str .= $chars[rand @chars] for 1..$len;
	return $str;
}

sub generate_salt{
	# salt length: 8
	return generate_random_string(8);
}

sub generate_session_id{
	my $user = shift;
	my $session_id;
	my $i = 0;
	my $found;
	do{
		$session_id = generate_random_string(64);
		my @session = find_session_info($session_id);
		$found = defined $session[0] ? 1 : 0;
		$i++;
	}while $found && $i<10;

	die_message("session_errors") if $found;

	my $expires = time + $INACTIVE_TIMEOUT * 60;

	lock_file($sessions_file);
	local *FH;
	die_message("session_errors") unless open FH, ">>$sessions_file";
	print FH "$session_id:$user:active:$expires\n";
	close FH;
	unlock_file($sessions_file);

	return ($session_id, $expires);
}

# http://www.perlmonks.org/?node_id=631963
# Thanks to Jochen Hoenicke <hoenicke@gmail.com>
# (one of the authors of Palm Keyring)
sub pbkdf2{
	my ($prf, $password, $salt, $iter, $keylen) = @_;
	my ($k, $t, $u, $ui, $i);
	$t = "";
	for($k = 1; length($t) < $keylen; $k++){
		$u = $ui = $prf->($salt.pack('N', $k), $password);
		for($i = 1; $i < $iter; $i++){
			$ui = $prf->($ui, $password);
			$u ^= $ui;
		}
		$t .= $u;
	}
	return substr $t, 0, $keylen;
}

# PBKDF2 for password hashing
# http://www.ict.griffith.edu.au/anthony/software/pbkdf2.pl
# Anthony Thyssen
sub get_pbkdf2_key{
	# key length: 128
	my ($password, $salt) = @_;
	my $prf = \&hmac_sha1;
	my $iter = 8192;
	my $keylen = 64;
	return unpack("H*", pbkdf2($prf, $password, $salt, $iter, $keylen));
}

sub hash_password{
	# hashed password length: 2*8+128=144
	my ($user, $pw, $salt) = @_;
	$salt = generate_salt() unless defined $salt;
	return unpack("H*", $salt).get_pbkdf2_key("$user:$salt:$pw", $salt);
}

sub generate_password_set_token{
	# password set token length: 64+1+...
	my $user = shift;
	return generate_random_string(64).".".
		(time + $SET_PASSWORD_TIMEOUT * 60);
}

sub generate_password_reset_token{
	# password reset token length: 64+1+...
	my $user = shift;
	return generate_random_string(64).".".
		(time + $RESET_PASSWORD_TIMEOUT * 60);
}

sub send_email{
	my ($email, $subject, $text) = @_;
	eval "use MIME::Lite;1" or
		die_message("perl_module_not_installed", "MIME::Lite");

	if($smtp_server ne ""){
		if($smtp_port ne ""){
			if($smtp_username ne "" && $smtp_password ne ""){
				MIME::Lite->send("smtp", $smtp_server,
					Port=>$smtp_port,
					AuthUser=>$smtp_username,
					AuthPass=>$smtp_password);
			}else{
				MIME::Lite->send("smtp", $smtp_server,
					Port=>$smtp_port);
			}
		}else{
			if($smtp_username ne "" && $smtp_password ne ""){
				MIME::Lite->send("smtp", $smtp_server,
					AuthUser=>$smtp_username,
					AuthPass=>$smtp_password);
			}else{
				MIME::Lite->send("smtp", $smtp_server);
			}
		}
	}
	MIME::Lite->quiet(1);

	my $msg = MIME::Lite->new(
		From=>$EMAIL_ADDRESS,
		To=>$email,
		Subject=>$subject,
		Data=>$text);
	$msg->send();
	return $msg->last_send_successful();
}

sub create_goto_form{
	# $mode=undef: return
	# $mode=1: print
	my $mode = shift;
	my $goto = get_msg("goto_form_goto");
	my $form = <<EOT;
<form class="goto-input" action="$SCRIPT_NAME" method="get">
<div>
<input accesskey="g" id="goto" name="goto" />
<input type="submit" value="$goto" />
</div>
</form>
EOT
	if($mode == 1){
		print $form;
		return;
	}
	# Forms are not allowed inside a <p> block
	close_paragraph();
	return $form;
}

sub create_rename_form{
	# $mode=undef: return
	# $mode=1: print
	my $mode = shift;
	my $rename = get_msg("rename_form_rename");
	my $form = <<EOT;
<form class="rename-input" action="$SCRIPT_NAME/$PAGE" method="get">
<div>
<input accesskey="g" id="rename" name="rename" />
<input type="submit" value="$rename" />
</div>
</form>
EOT
	if($mode == 1){
		print $form;
		return;
	}
	# Forms are not allowed inside a <p> block
	close_paragraph();
	return $form;
}

sub create_search_form{
	# $mode=undef: return
	# $mode=1: print
	my $mode = shift;
	my $search = get_msg("search_form_search");
	my $simple = get_msg("search_form_simple");
	my $icase = get_msg("search_form_ignore_case");
	my $link = get_msg("search_form_links");
	my $title = get_msg("search_form_print_titles");
	my $nomatch = get_msg("search_form_dont_print_matches");
	my $form = <<EOT;
<form class="search-input" action="$SCRIPT_NAME" method="get">
<div>
<input accesskey="s" id="search" name="search" />
<input type="submit" value="$search" />
<br />
<input type="checkbox" id="simple" name="simple" value="1" checked="checked" /> $simple
<input type="checkbox" id="icase" name="icase" value="1" checked="checked" /> $icase
<input type="checkbox" id="link" name="link" value="1" /> $link
<br />
<input type="checkbox" id="title" name="title" value="1" checked="checked" /> $title
<input type="checkbox" id="nomatch" name="nomatch" value="1" /> $nomatch
</div>
</form>
EOT
	if($mode == 1){
		print $form;
		return;
	}
	# Forms are not allowed inside a <p> block
	close_paragraph();
	return $form;
}

sub create_comment_form{
	# $mode=undef: return
	# $mode=1: print
	my ($page, $comment, $direction, $rows, $cols, $mode) = @_;
	$page = $PAGE if $page eq "";
	$comment = "comment" if $comment eq "";
	$direction = "down" if $direction eq "";
	$rows = "6" if $rows eq "";
	$cols = "80" if $cols eq "";
	die_message("invalid_comment_tag", $comment)
		unless $comment =~ /^[a-zA-Z0-9_-]+$/;
	my $id = time;

	my $leave_this_field_blank = get_msg("comment_form_leave_this_field_blank");
	my $write = get_msg("comment_form_write");
	my $form = <<EOT;
<form class="comment-input" action="$SCRIPT_NAME?comment=$comment" method="post">
<div>
<div class="comment-website">$leave_this_field_blank<input id="website" name="website" /></div>
<input type="hidden" id="id" name="id" value="$id" />
<input type="hidden" id="page" name="page" value="$page" />
<input type="hidden" id="direction" name="direction" value="$direction" />
<textarea accesskey="t" id="text" name="text" rows="$rows" cols="$cols"></textarea>
<input type="submit" value="$write" />
</div>
</form>
EOT
	if($mode == 1){
		print $form;
		return;
	}
	# Forms are not allowed inside a <p> block
	close_paragraph();
	return $form;
}

sub read_file{
	my $file = shift;
	my $text = "";
	local *FH;

	# "<" is required for the in-memory file
	if(open FH, "<", $file){
		# sysread is faster, but it doesn't work with in-memory files
		local $/ = undef;
		$text = <FH>;
		close FH;
	}

	return $text;
}

sub write_file{
	# return 1 if successful
	# return 0 otherwise
	my ($file, $text, $binary) = @_;
	local *FH;

	# ">" is required for the in-memory file
	if(open FH, ">", $file){
		binmode FH if $binary;
		print FH $text;
		close FH;
		return 1;
	}
	return 0;
}

sub read_lines{
	my ($file, $start, $count) = @_;
	my $lines = "";
	local *FH;

	return $lines if defined $count && $count <= 0;

	# "<" is required for the in-memory file
	if(open FH, "<", $file){
		# sysread is faster, but it doesn't work with in-memory files
		<FH> while --$start;
		if(!defined $count){
			local $/ = undef;
			$lines = <FH>;
		}else{
			while(<FH>){
				last unless $count--;
				$lines .= $_;
			}
		}
		close FH;
	}

	return $lines;
}

sub edit_lines{
	# $count eq "":	edit from $start to end
	# $count == 0:	insert at $start
	my ($file, $start, $count, $lines) = @_;
	my $text = read_lines($file, 1, $start - 1).$lines;
	$text .= read_lines($file, $start + $count) if $count ne "";
	return $text;
}

sub print_list_pages{
	my ($list, $n, $title, $glob, $TITLE) = @_;

	$n = 0 if $n eq "";
	$glob = "*" if $glob eq "";

	print qq(<div id="list">\n);
	print qq(<h1>$TITLE</h1>\n) if $TITLE ne "";
	print qq(<ul>\n);

	my $tls = $list eq "taz" || $list eq "tza" ? 1 : 0;
	my $roc = $list eq "rc" || $list eq "oc" ? 1 : 0;
	my $i = 0;
	my @list;
	foreach(<$glob.txt>){
		next if substr($_,0,1) eq "." || index($_,"/") >= 0 || !-f $_;
		s/\.txt$//;
		if($PAGES_NOT_ALLOWED ne "" && /$PAGES_NOT_ALLOWED/o){
			next;
		}
		my $page = $_;
		next unless -f "$page.html";
		local $wiki = is_wiki($page);
		next unless has_read_access();

		my $page_title = $page;
		my @t = localtime((stat "$page.txt")[9]);
		my $time = sprintf "%d-%02d-%02d %02d:%02d:%02d",
			$t[5]+1900, $t[4]+1, $t[3], $t[2], $t[1], $t[0];
		if($tls || $title){
			my $text = read_file("$page.html");
			if($text ne ""){
				$text =~ s#<!--.*?-->##sg;
				$text =~ s#<(script|style).*?</\1>##sgi;
				if($text =~ m#<h1[^>]*>(.+?)</h1>#si){
					$_ = $1;
					s/<[^>]*>//g; s/[<>]//g;
					$page_title = $_;
				}
			}
		}
		my $author = get_author($page);
		if($roc){
			if($title){
				$list[$i++] = "$time\x00$page_title\x00$page\x00$author";
			}else{
				$list[$i++] = "$time\x00$page\x00$page_title\x00$author";
			}
		}elsif($tls){
			$list[$i++] = "$page_title\x00$page\x00$time\x00$author";
		}else{
			$list[$i++] = "$page\x00$page_title\x00$time\x00$author";
		}
	}
	@list = sort @list;
	@list = reverse @list if($list eq "rc" || $list eq "za" ||
				 $list eq "tza");
	$n = $i if $n > $i || !$n;
	$i = 0;
	foreach(@list){
		my ($page, $page_title, $time, $author);
		/^(.*)\x00(.*)\x00(.*)\x00(.*)$/;
		$author = $4;
		if($roc){
			if($title){
				$page = $3;
				$page_title = $2;
			}else{
				$page = $2;
				$page_title = $3;
			}
			$time = $1;
		}else{
			if($tls){
				$page = $2;
				$page_title = $title ? $1 : $page;
			}else{
				$page = $1;
				$page_title = $2;
			}
			$time = $3;
		}
		print qq(<li><a href="$page.html">$page_title</a> <span class="list-time">$time</span> <span class="list-author">$author</span></li>\n);
		last if ++$i == $n;
	}

	print qq(</ul>\n</div>\n);
}

sub print_search_pages{
	my ($search, $simple, $icase, $link, $title, $nomatch, $glob, $TITLE) = @_;

	$_ = $search;
	if($simple){
		s/[<>\r]//g; s/[\t\n]/ /g; s/ +/ /g; s/^ //; s/ $//;
		$_ = quotemeta;
		s/\\ />/g;
		s/\\"([^"]*)\\"/\x01$1\x02/g;
		while(s/\x01([^\x02]*)>([^\x02]*)\x02/\x01$1 +$2\x02/g){}
		s/[\x01\x02]//g; s/\\"//g;
	}
	my @search = split />/;
	$glob = "*" if $glob eq "";

	print qq(<div id="search">\n);
	print qq(<h1>$TITLE</h1>\n) if $TITLE ne "";
	print qq(<ul>\n);

	foreach(<$glob.txt>){
		next if substr($_,0,1) eq "." || index($_,"/") >= 0 || !-f $_;
		s/\.txt$//;
		if($PAGES_NOT_ALLOWED ne "" && /$PAGES_NOT_ALLOWED/o){
			next;
		}
		my $page = $_;
		next unless -f "$page.html";
		local $wiki = is_wiki($page);
		next unless has_read_access();
		my $text = read_file("$page.html");
		next if $text eq "";

		my $page_name = $page;
		$text =~ s/^.*<!-- start text -->|<!-- end text -->.*$//sgi;
		$text =~ s#<!--.*?-->##sg;
		$text =~ s#<(script|style).*?</\1>##sgi;
		$text =~ y/&/\x01/;
		$text =~ y/</\x02/;
		$text =~ y/>/\x03/;
		$text =~ s/\x01amp;/&/gi;
		$text =~ s/\x01lt;/</gi;
		$text =~ s/\x01gt;/>/gi;

		if($title && $text =~ m#\x02h1[^\x03]*\x03(.+?)\x02/h1\x03#si){
			$_ = $1;
			s/\x02[^\x03]*\x03//g; s/^.*\x03|\x02.*$//mg;
			s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g;
			y/\x01/&/;
			$page_name = $_;
		}
		my ($i, $line, $word, $found, @found, @result);
		if($link){
			foreach(split /\n/, $text){
				$line = $_;
				$found = "";
				for($i = 0; $i <= $#search; $i++){
					$word = encode_url_utf8($search[$i]);
					next if $word eq "";
					$word = "(?i)$word" if $icase;
					if($line =~ m#\x02[aA][ \t][^\x03]*(?:href|HREF)[ \t]*=[ \t]*"(?:$word)"[^\x03]*\x03[^\x02]+\x02/[aA]\x03#){
						$found = $line if $found eq "";
						$found =~ s#\x02[aA][ \t][^\x03]*(?:href|HREF)[ \t]*=[ \t]*"(?:$word)"[^\x03]*\x03([^\x02]+)\x02/[aA]\x03#\x04$1\x05#g;
						$found[$i] = 1;
					}
				}
				if($found ne ""){
					$_ = $found;
					s/\x02[^\x03]*\x03//g;
					s/^.*\x03|\x02.*$//mg;
					s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g;
					y/\x01/&/;
					push @result, $_;
				}
			}
		}else{
			$text =~ s/\x02[^\x03]*\x03//g;
			$text =~ s/^.*\x03|\x02.*$//mg;
			foreach(split /\n/, $text){
				$line = $_;
				$found = "";
				for($i = 0; $i <= $#search; $i++){
					$word = $search[$i];
					next if $word eq "";
					$word = "(?i)$word" if $icase;
					if($line =~ m#$word#){
						$found = $line if $found eq "";
						$found =~ s#($word)#\x04$1\x05#g;
						$found[$i] = 1;
					}
				}
				if($found ne ""){
					$_ = $found;
					s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g;
					y/\x01/&/;
					push @result, $_;
				}
			}
		}
		for($i = 0; $i <= $#search; $i++){
			last if !$found[$i];
		}
		next if $i <= $#search;
		if($nomatch){
			print qq(<li><a href="$page.html">$page_name</a></li>\n);
			next;
		}
		print qq(<li><a href="$page.html">$page_name</a>\n<ul>\n);
		foreach(@result){
			s#\x04#<span class="search-highlight">#g;
			s#\x05#</span>#g;
			print qq(<li>$_</li>\n);
		}
		print qq(</ul>\n</li>\n);
	}

	print qq(</ul>\n</div>\n);
}

################################################################################
# Parsing subroutines
sub prepare_parser{
	@begin_parsing = \&begin_parsing;
	@parse_line = \&parse_line;
	@end_parsing = \&end_parsing;

	@process_raw_block = \&process_raw_block;
	@preprocess_line = \&preprocess_line;
	@process_block = \&process_block;
	@process_asis_lines = \&process_asis_lines;
	@skip_comment = \&skip_comment;
	@process_wiki_command = \&process_wiki_command;
	@process_nonwiki_command = \&process_nonwiki_command;
	@skip_unknown_command = \&skip_unknown_command;
	@start_block = \&start_block;
	@process_collected_lines = \&process_collected_lines;
	@process_paragraph_break = \&process_paragraph_break;
	@escape_inline_syntax = \&escape_inline_syntax;
	@process_inline_syntax = \&process_inline_syntax;
	@collect_lines = \&collect_lines;
	@process_line_syntax = \&process_line_syntax;
	@start_paragraph = \&start_paragraph;
	@postprocess_line = \&postprocess_line;
	@close_all_open = \&close_all_open;
}

sub parse{
	# parse one line $_[0] using parsers in the rest of arguments
	local $_ = shift;
	my @parsers = @_;
	foreach my $parser (@parsers){
		$_ = $parser->($_);
		return unless defined;
	}
	return $_;
}

sub parse_file{
	# parser an entire file $_[0] optionally starting from line $_[1]
	my ($file, $start) = @_;
	local *UNIQKI_FH;

	# "<" is required for the in-memory file
	return "" unless open UNIQKI_FH, "<", $file;
	$wiki = <UNIQKI_FH> eq "#!wiki\n" ? 1 : 0;
	close UNIQKI_FH;

	local ($text, $url_char, $url_punct, $fresh_block, $code_block,
		$syntax_block, @parsed_blocks, $re_block, $re_start, $re_n,
		@re, @re_sub, $p, $asis, $nosyntax, $pre, $pre_code,
		$blockquote, $list, $table, $figure, @h_lines, %h_n, $h_top,
		$h_prev, %h_secs, %secs_no, $toc, $toc_dep, $tab_no, %tabs_n,
		%tabs, $lot, $nolot, $fig_no, %figs_n, %figs, $lof, $nolof);

	my @header_files = ();
	push @header_files, $HEADER_FILE;
	push @header_files, $NONWIKI_HEADER_FILE unless $wiki;
	push @header_files, $WIKI_HEADER_FILE if $wiki;

	my @footer_files = ();
	push @footer_files, $WIKI_FOOTER_FILE if $wiki;
	push @footer_files, $NONWIKI_FOOTER_FILE unless $wiki;
	push @footer_files, $FOOTER_FILE;

	my @_begin_parsing = @begin_parsing;
	my @_parse_line = @parse_line;
	my @_end_parsing = @end_parsing;

	my @_process_raw_block = @process_raw_block;
	my @_preprocess_line = @preprocess_line;
	my @_process_block = @process_block;
	my @_process_asis_lines = @process_asis_lines;
	my @_skip_comment = @skip_comment;
	my @_process_wiki_command = @process_wiki_command;
	my @_process_nonwiki_command = @process_nonwiki_command;
	my @_skip_unknown_command = @skip_unknown_command;
	my @_start_block = @start_block;
	my @_process_collected_lines = @process_collected_lines;
	my @_process_paragraph_break = @process_paragraph_break;
	my @_escape_inline_syntax = @escape_inline_syntax;
	my @_process_inline_syntax = @process_inline_syntax;
	my @_collect_lines = @collect_lines;
	my @_process_line_syntax = @process_line_syntax;
	my @_start_paragraph = @start_paragraph;
	my @_postprocess_line = @postprocess_line;
	my @_close_all_open = @close_all_open;

	do $USER_PARSERS_FILE if -f $USER_PARSERS_FILE;

	$_->() foreach @begin_parsing;

	foreach(@header_files){
		# "<" is required for the in-memory file
		next if $_ eq "" || !open UNIQKI_FH, "<", $_;
		$text .= parse($_, @parse_line) while <UNIQKI_FH>;
		close UNIQKI_FH;
	}

	# to undefine $lineno for the last edit section
	{
		my $header = $text;

		# "<" is required for the in-memory file
		open UNIQKI_FH, "<", $file;
		my $output = !defined $start;

		local $lineno = 0;
		while(<UNIQKI_FH>){
			$lineno++;
			if(defined $start && $lineno == $start){
				close_all_sections();
				$output = $nolot = $nolof = 1;
				$toc_dep = 0;
				$text = $header;
				# preview the current section
				$preview = 3;
			}
			my $parsed_line = parse($_, @parse_line);
			$text .= $parsed_line if $output;
		}
		close UNIQKI_FH;
	}

	foreach(@footer_files){
		# "<" is required for the in-memory file
		next if $_ eq "" || !open UNIQKI_FH, "<", $_;
		$text .= parse($_, @parse_line) while <UNIQKI_FH>;
		close UNIQKI_FH;
	}

	$_->() foreach @end_parsing;

	@begin_parsing = @_begin_parsing;
	@parse_line = @_parse_line;
	@end_parsing = @_end_parsing;

	@process_raw_block = @_process_raw_block;
	@preprocess_line = @_preprocess_line;
	@process_block = @_process_block;
	@process_asis_lines = @_process_asis_lines;
	@skip_comment = @_skip_comment;
	@process_wiki_command = @_process_wiki_command;
	@process_nonwiki_command = @_process_nonwiki_command;
	@skip_unknown_command = @_skip_unknown_command;
	@start_block = @_start_block;
	@process_collected_lines = @_process_collected_lines;
	@process_paragraph_break = @_process_paragraph_break;
	@escape_inline_syntax = @_escape_inline_syntax;
	@process_inline_syntax = @_process_inline_syntax;
	@collect_lines = @_collect_lines;
	@process_line_syntax = @_process_line_syntax;
	@start_paragraph = @_start_paragraph;
	@postprocess_line = @_postprocess_line;
	@close_all_open = @_close_all_open;

	return $text;
}

sub parse_fresh_block{
	# parse a text block $_[0] in a fresh parsing environment
	my $txt = shift;
	local ($text, $url_char, $url_punct, $fresh_block, $code_block,
		$syntax_block, @parsed_blocks, $re_block, $re_start, $re_n,
		@re, @re_sub, $p, $asis, $nosyntax, $pre, $pre_code,
		$blockquote, $list, $table, $figure, @h_lines, %h_n, $h_top,
		$h_prev, %h_secs, %secs_no, $toc, $toc_dep, $tab_no, %tabs_n,
		%tabs, $lot, $nolot, $fig_no, %figs_n, %figs, $lof, $nolof);

	$_->() foreach @begin_parsing;
	$text .= parse_lines($txt);
	$_->() foreach @end_parsing;

	return $text;
}

sub parse_block{
	# parse a text block $_[0] in the parent's parsing environment
	my $txt = shift;
	local ($text, $url_char, $url_punct, $fresh_block, $code_block,
		$syntax_block, @parsed_blocks, $p, $asis, $nosyntax, $pre,
		$pre_code, $blockquote, $list, $table, $figure);

	$_->(1) foreach @begin_parsing;
	$text .= parse_lines($txt);
	$_->(1) foreach @end_parsing;

	return $text;
}

sub parse_lines{
	# parse multiple lines in $_[0]
	my $txt = shift;
	local $text;
	$text .= parse($_, @parse_line) foreach split /\n/, $txt, -1;
	return $text;
}

sub create_edit_section{
	return if $preview;
	push @h_lines, 1 + $wiki if $#h_lines == -1;
	my $edit = ($wiki ? "wiki_" : "")."edit_lines";
	my $start = $h_lines[$#h_lines];
	my $lines = $start.($lineno ? ",".($lineno-$start) : "");
	push @h_lines, $lineno;
	$text .= qq(<div class="write-access edit-section"><a href="$CGI/$PAGE?$edit=$lines">$MESSAGES{edit}</a></div>\n);
}

sub run_code_block{
	my $block = shift;
	$block =~ s/^(##[{}]_*)_$/$1/mg;
	eval $block;
	$text .= "<pre>$@</pre>" if $preview && $@;
}

sub create_fresh_block{
	my $block = shift;
	my $i = index $block, "\n";
	my $j = rindex $block, "\n";
	my $begin = substr $block, 0, $i;
	my $end = substr $block, $j + 1;
	$block = substr $block, $i + 1, $j - $i - 1;
	$block =~ s/(\(\(_*)_$/$1/mg;
	$block =~ s/^(\)\)_*)_/$1/mg;
	my $parsed_block = parse_fresh_block($block);
	return if $preview == 2;
	chomp $parsed_block;
	push @parsed_blocks, $parsed_block;
	return "$begin\x06$end";
}

sub create_syntax_block{
	my $block = shift;
	my $i = index $block, "\n";
	my $j = rindex $block, "\n";
	my $begin = substr $block, 0, $i;
	my $end = substr $block, $j + 1;
	$block = substr $block, $i + 1, $j - $i - 1;
	$block =~ s/(?<!\()(\(_*)_$/$1/mg;
	$block =~ s/^(\)_*)_/$1/mg;
	my $parsed_block = parse_block($block);
	return if $preview == 2;
	chomp $parsed_block;
	push @parsed_blocks, $parsed_block;
	return "$begin\x06$end";
}

sub create_blockquote{
	my @lines = split /\n/, shift;
	my $blockquote = "";
	my @cite = ();
	my $q_i = 0;
	my $p = 0;

	foreach(@lines){
		/^( *)(&gt;[ \t])?(.*)$/;
		my $i = length($1) / 2 + 1;
		my $start = $2 ne "" ? 1 : 0;
		my $line = $3;
		if(!$start || $line =~ /^\(.*\)$/){
			if($i - 1 < $q_i){
				if($p){
					$blockquote .= "</p>\n";
					$p = 0;
				}
				while(--$q_i >= $i - 1){
					if($cite[$q_i] ne ""){
						$blockquote .= "<footer><cite>$cite[$q_i]</cite></footer>\n";
						$cite[$q_i] = "";
					}
					$blockquote .= "</blockquote>\n";
				}
				$q_i++;
			}
			if($line eq "" || $line eq "."){
				if($p){
					$blockquote .= "</p>\n";
					$p = 0;
				}
				next;
			}
			if($line =~ /^\([ \t]*(.*?)[ \t]*\)$/){
				my $qi = $start ? $i - 1 : $q_i - 1;
				$cite[$qi] .= "\n" if $cite[$qi] ne "";
				$cite[$qi] .= $1;
			}else{
				$line =~ s#(\x06)#</p>$1<p>#g;
				if(!$p){
					$blockquote .= "<p>";
					$p = 1;
				}
				$line =~ s#([ \t])\([ \t]*(.*?)[ \t]*\)$#$1<cite>$2</cite>#;
				$line =~ s/^[ \t]*(.*?)[ \t]*$/$1/;
				$blockquote .= "$line\n";
			}
			next unless $start;
			$line = "";
		}
		if($p){
			$blockquote .= "</p>\n";
			$p = 0;
		}
		if($i > $q_i){
			for(; $q_i < $i - 1; $q_i++){
				$blockquote .= "<blockquote>\n";
			}
			$q_i++;
		}elsif($i < $q_i){
			while($q_i-- >= $i){
				if($cite[$q_i] ne ""){
					$blockquote .= "<footer><cite>$cite[$q_i]</cite></footer>\n";
					$cite[$q_i] = "";
				}
				$blockquote .= "</blockquote>\n";
			}
			$q_i += 2;
		}else{
			if($cite[$q_i-1] ne ""){
				$blockquote .= "<footer><cite>$cite[$q_i-1]</cite></footer>\n";
				$cite[$q_i-1] = "";
			}
			$blockquote .= "</blockquote>\n";
		}
		$blockquote .= "<blockquote>\n";
		if(!$p){
			$blockquote .= "<p>";
			$p = 1;
		}

		$line =~ s#([ \t])\([ \t]*(.*?)[ \t]*\)$#$1<cite>$2</cite>#;
		$line =~ s/^[ \t]*(.*?)[ \t]*$/$1/;
		$blockquote .= "$line\n" if $line ne "";
	}
	if($p){
		$blockquote .= "</p>\n";
		$p = 0;
	}
	while(--$q_i >= 0){
		if($cite[$q_i] ne ""){
			$blockquote .= "<footer><cite>$cite[$q_i]</cite></footer>\n";
			$cite[$q_i] = "";
		}
		$blockquote .= "</blockquote>\n";
	}

	# Inline perl code
	$blockquote =~ s/``(.*?)``/$1/eeg;
	# Discard none characters
	$blockquote =~ y/\x00//d;

	return $blockquote;
}

sub create_list{
	my @lines = split /\n/, shift;
	my $list = "";
	my $li_i = 0;
	my @li = ();
	my @li_attr = ();
	my $use_p = 0;
	my $p = 0;

	foreach(@lines){
		/^( *)(?:([*+-]|: [ \t]*(.*?)[ \t]*:)[ \t])?[ \t]*(.*?)[ \t]*$/;
		my $i = length($1) / 2 + 1;
		my $line = $4;
		if($2 eq ""){
			if(--$i < $li_i){
				if($p){
					$list .= "</p>\n";
					$p = 0;
				}
				while(--$li_i >= $i){
					if($li[$li_i] eq "dl"){
						$list .= "</dd>\n";
					}else{
						$list .= "</li>\n";
					}
					$list .= "</$li[$li_i]>\n";
				}
				$li_i++;
			}
			if($line eq "" || $line eq "."){
				$use_p = 1;
				if($p){
					$list .= "</p>\n";
					$p = 0;
				}
				next;
			}
			if($use_p){
				$line =~ s#(\x06)#</p>$1<p>#g;
				if(!$p){
					$list .= "<p>";
					$p = 1;
				}
			}
			$list .= "$line\n";
			next;
		}
		$use_p = 0;
		if($p){
			$list .= "</p>\n";
			$p = 0;
		}
		my $tag = substr $2, 0, 1;
		my $term = $3;
		my $attr = "";
		if($tag eq "*"){
			$tag = "ul";
		}elsif($tag eq "+"){
			$tag = "ol";
		}elsif($tag eq "-"){
			$tag = "ol";
			$attr = q( reversed="reversed");
		}else{
			$tag = "dl";
		}
		if($i > $li_i){
			for(; $li_i < $i - 1; $li_i++){
				$list .= "<$tag>\n";
				if($tag eq "dl"){
					$list .= "<dt></dt>\n<dd>";
				}else{
					$list .= "<li>";
				}
				$li[$li_i] = $tag;
				$li_attr[$li_i] = "";
			}
			$list .= "<$tag$attr>\n";
			$li[$li_i] = $tag;
			$li_attr[$li_i++] = $attr;
		}elsif($i < $li_i){
			while(--$li_i >= $i){
				if($li[$li_i] eq "dl"){
					$list .= "</dd>\n";
				}else{
					$list .= "</li>\n";
				}
				$list .= "</$li[$li_i]>\n";
			}
			if($li[$li_i] eq $tag && $li_attr[$li_i] eq $attr){
				if($li[$li_i] eq "dl"){
					$list .= "</dd>\n";
				}else{
					$list .= "</li>\n";
				}
				$li_i++;
			}else{
				for(; $li_i >= 0 && ($li[$li_i] ne $tag ||
				      $li_attr[$li_i] ne $attr); $li_i--){
					if($li[$li_i] eq "dl"){
						$list .= "</dd>\n";
					}else{
						$list .= "</li>\n";
					}
					$list .= "</$li[$li_i]>\n";
				}
				while(++$li_i < $i-1){
					$list .= "<$tag>\n";
					$li[$li_i] = $tag;
					$li_attr[$li_i] = "";
				}
				$list .= "<$tag$attr>\n";
				$li[$li_i] = $tag;
				$li_attr[$li_i++] = $attr;
			}
		}elsif($li[$li_i-1] ne $tag || $li_attr[$li_i-1] ne $attr){
			if($li[$li_i-1] eq "dl"){
				$list .= "</dd>\n";
			}else{
				$list .= "</li>\n";
			}
			$list .= "</$li[$li_i-1]>\n<$tag$attr>\n";
			$li[$li_i-1] = $tag;
			$li_attr[$li_i-1] = $attr;
		}elsif($tag eq "dl"){
			$list .= "</dd>\n";
		}else{
			$list .= "</li>\n";
		}

		if($tag eq "dl"){
			$list .= "<dt>$term</dt>\n<dd>$line\n";
		}else{
			$list .= "<li>$line\n";
		}
	}
	if($p){
		$list .= "</p>\n";
		$p = 0;
	}
	while(--$li_i >= 0){
		if($li[$li_i] eq "dl"){
			$list .= "</dd>\n";
		}else{
			$list .= "</li>\n";
		}
		$list .= "</$li[$li_i]>\n";
	}

	# Inline perl code
	$list =~ s/``(.*?)``/$1/eeg;
	# Discard none characters
	$list =~ y/\x00//d;

	return $list;
}

sub create_table{
	my @lines = split /\n/, shift;
	my $id = "";
	my $title = "";
	my $caption = "";
	my $thead = "";
	my $tfoot = "";
	my $tbodies = "";
	my $tbody = "";

	foreach(@lines){
		my $end = substr $_, -1;
		if(/^!(!)?[ \t](.*[ \t])?(!)?!$/){
			my $inc_lot = $1 eq "" ? 1 : 0;
			my $del_punct_from_title = $3 eq "" ? 1 : 0;
			(my $line = $2) =~ s/^[ \t]+|[ \t]+$//g;
			next if $line eq "";
			$caption .= "\n" if $caption ne "";
			$caption .= $line;
			if($inc_lot && $id eq ""){
				$line =~ s/<[^>]*>|\x00//g;
				$line =~ s/[`~!@#\$%^&*_=+\\|;:,.\/?-]+$//
					if $del_punct_from_title;
				if($line ne ""){
					$id = convert_page_name("table $line");
					my $j = $tabs_n{$id}++;
					if($j > 0){
						$id .= $j + 1;
						$tabs_n{$id}++;
					}
					$title = $line;
				}
			}
		}elsif($end eq "^"){
			$thead .= create_table_row($_);
		}elsif($end eq "!"){
			$tfoot .= create_table_row($_);
		}else{
			$_ = substr $_, 0, length($_) - 1 if $end eq "_";
			$tbody .= create_table_row($_);
			if($end eq "_" && $tbody ne ""){
				$tbody = update_table_rowspan($tbody);
				$tbodies .= "<tbody>\n$tbody</tbody>\n";
				$tbody = "";
			}
		}
	}
	if($tbody ne ""){
		$tbody = update_table_rowspan($tbody);
		$tbodies .= "<tbody>\n$tbody</tbody>\n";
	}

	my $table = "";
	return $table if($caption eq "" && $thead eq "" && $tbodies eq "" &&
			 $tfoot eq "");

	$thead = update_table_rowspan($thead);
	$tfoot = update_table_rowspan($tfoot);

	my $tab = "";
	if($id eq ""){
		$table = "<table>\n";
	}else{
		$tabs{$id} = ++$tab_no;
		$tab = "$TABLE_NUMBER_PREFIX$tab_no$TABLE_NUMBER_SUFFIX";
		$table = "<table id=\"$id\">\n";
		my $enc_id = encode_url_safe($id);
		$lot .= "<li><a href=\"#$enc_id\">$tab$title</a></li>\n";
	}
	$table .= "<caption>$tab$caption</caption>\n" if $caption ne "";
	$table .= "<thead>\n$thead</thead>\n" if $thead ne "";
	$table .= $tbodies if $tbodies ne "";
	$table .= "<tfoot>\n$tfoot</tfoot>\n" if $tfoot ne "";
	$table .= "</table>\n";

	# Inline perl code
	$table =~ s/``(.*?)``/$1/eeg;
	# Discard none characters
	$table =~ y/\x00//d;

	return $table;
}

sub create_table_row{
	my $row = shift;

	$row =~ s/(!+)$/@{["|" x length($1)]}/;

	# Empty cells
	$row =~ s#([|^])[ \t]+([|^]*)(?=[|^](?:[ \t]|$))#@{[create_table_cell($1, $2)]}#g;
	# Non-empty cells
	$row =~ s#([|^])[ \t]([ \t]*)([^ \t].*?)([ \t]*)[ \t]([|^]*)(?=[|^](?:[ \t]|$)|<t[hd] )#@{[create_table_cell($1, $5, $2, $3, $4)]}#g;
	$row =~ s/[|^]$//;

	return "<tr>$row</tr>\n";
}

sub create_table_cell{
	my ($type, $colspan, $left, $content, $right) = @_;

	$type = $type eq "^" ? "th" : "td";
	$colspan = length($colspan) + 1;
	$left = length($left);
	$right = length($right);

	$colspan = $colspan == 1 ? "" : qq( colspan="$colspan");
	my $align = $left == 0 ? "left" : ($right == 0 ? "right" : "center");
	return qq(<$type$colspan class="text-$align">$content</$type>);
}

sub update_table_rowspan{
	my $rows = shift;

	(my $rowspan = $rows) =~ s#</?tr>##g;
	$rowspan =~ s#<(t[hd]) [^>]+>\.</\1>#+#g;
	$rowspan =~ s#<(t[hd]) [^>]+>.*?</\1>#1#g;
	# $rowspan example:
	# 111
	# 1++
	# 11+

	my @rs = split /\n/, $rowspan;
	# Only one row
	return $rows if $#rs == 0;

	# The first row cannot be spanned from above
	$rs[0] = "1" x length($rs[0]);
	# No row spans
	return $rows if index(join("\n", @rs), "+") == -1;

	my @counts;
	for my $i (0..$#rs){
		my $c = 0;
		$counts[$i][$c++] = $_ foreach split //, $rs[$i];
	}
	# Count the number of row spans
	for my $i (0..($#rs-1)){
		for my $c (0..$#{$counts[$i]}){
			last if $counts[$i][$c] eq "+";
			for my $j (($i+1)..$#rs){
				last if $counts[$j][$c] ne "+";
				$counts[$i][$c]++;
			}
		}
	}

	# Make it easy to replace back </th> and </td> later.
	# \x01-\x03 have already been converted to &amp;, &lt;, and &gt;.
	$rows =~ s#</th>#\x01\x03#g;
	$rows =~ s#</td>#\x02\x03#g;

	my @cells;
	my @rows = split /\n/, $rows;
	for my $i (0..$#rows){
		my $c = 0;
		$cells[$i][$c++] = $_ foreach split /\x03/, $rows[$i];
	}

	for my $i (0..$#rs){
		for my $c (0..$#{$counts[$i]}){
			if($counts[$i][$c] > 1){
				$cells[$i][$c] =~ s/(<t[hd])(?=[> ])/$1 rowspan="$counts[$i][$c]"/;
			}elsif($counts[$i][$c] eq "+"){
				$cells[$i][$c] =~ s/<t[hd][> ].*[\x01\x02]//;
			}
		}
	}

	$rows = "";
	for my $i (0..$#rs){
		$rows .= join("", @{$cells[$i]})."\n";
	}
	$rows =~ s#\x01#</th>#g;
	$rows =~ s#\x02#</td>#g;

	return $rows;
}

sub create_figure{
	my @lines = split /\n/, shift;
	my $id = "";
	my $title = "";
	my $content = "";
	my $figcaption = "";
	my $figure = "";

	foreach(@lines){
		if(/^"(!)?[ \t](.*[ \t])?(!)?"$/){
			my $inc_lof = $1 eq "" ? 1 : 0;
			my $del_punct_from_title = $3 eq "" ? 1 : 0;
			(my $line = $2) =~ s/^[ \t]+|[ \t]+$//g;
			next if $line eq "";
			$figcaption .= "\n" if $figcaption ne "";
			$figcaption .= $line;
			if($inc_lof && $id eq ""){
				$line =~ s/<[^>]*>|\x00//g;
				$line =~ s/[`~!@#\$%^&*_=+\\|;:,.\/?-]+$//
					if $del_punct_from_title;
				if($line ne ""){
					$id = convert_page_name("figure $line");
					my $j = $figs_n{$id}++;
					if($j > 0){
						$id .= $j + 1;
						$figs_n{$id}++;
					}
					$title = $line;
				}
			}
		}else{
			my $line = substr $_, 2, length($_) - 4;
			$line =~ s/^[ \t]+|[ \t]+$//g;
			next if $line eq "";
			$content .= " " if $content ne "";
			$content .= $line;
		}
	}

	return $figure if $content eq "" && $figcaption eq "";

	my $fig = "";
	if($id eq ""){
		$figure = "<figure>\n";
	}else{
		$figs{$id} = ++$fig_no;
		$fig = "$FIGURE_NUMBER_PREFIX$fig_no$FIGURE_NUMBER_SUFFIX";
		$figure = "<figure id=\"$id\">\n";
		my $enc_id = encode_url_safe($id);
		$lof .= "<li><a href=\"#$enc_id\">$fig$title</a></li>\n";
	}
	$figure .= "$content\n" if $content ne "";
	$figure .= "<figcaption>$fig$figcaption</figcaption>\n"
		if $figcaption ne "";
	$figure .= "</figure>\n";

	# Inline perl code
	$figure =~ s/``(.*?)``/$1/eeg;
	# Discard none characters
	$figure =~ y/\x00//d;

	return $figure;
}

sub close_paragraph{
	if($p){
		$text .= "</p>\n";
		$p = 0;
	}
}

sub close_all_sections{
	$text .= "</section>\n" while --$h_prev > 0;
	$h_prev = 0;
}

sub process_raw_block{
	# return undef to skip to the next line
	# return the current line for further processing
	local $_ = shift;

	# Fresh block
	if(!$asis && !/^[%#]/ && "((" eq substr $_, -2){
		# Process the first line later
		$fresh_block = (substr $_, 0, length($_) - 2)."\n";
		return;
	}
	# Process fresh block
	if($fresh_block ne ""){
		if("))" eq substr($_, 0, 2) && "_" ne substr($_, 2, 1)){
			my $block = $fresh_block.substr($_, 2);
			$fresh_block = "";
			$_ = create_fresh_block($block);
		}else{
			$fresh_block .= "$_\n";
			return;
		}
	}
	if($re_block ne ""){
		if(substr($re_block, 0, 1) eq $_){
			chomp $re_block;
			$re_block =~ s/^.(.*)\n//;

			# Don't allow code embedding in a wiki page
			if($wiki && index($re_block, '@{[') != -1){
				$re_block = "";
				return;
			}

			my $i;
			for($i = 0; $i < $re_n; $i++){
				last if $re[$i] eq $1;
			}
			$re[$re_n++] = $1 if $i == $re_n;
			$_ = $re_block;
			# Treat a single backslash as an escape character
			s/(?<!\\)\\(?![\\a-zA-Z0-9])/\x00/g;
			# Don't allow access to variables
			s/([\$@%\[\]])/\\\1/g;
			$re_sub[$i] = $_;
			$re_block = "";
			return;

		}else{
			$re_block .= "$_\n";
			return;
		}
	}

	return $_;
}

sub preprocess_line{
	# return undef to skip to the next line
	# return the current line for further processing
	local $_ = shift;

	# Apply regular expressions if not asis
	if(!$asis && /^(?!#(?:no)?regex)/ && /^(?!##(?:sub |{))/ &&
	   $code_block eq "" && $syntax_block eq "" && $re_block eq ""){
		for(my $i = $re_start; $i < $re_n; $i++){
			# Need it again to avoid regexing regexed output
			if(/^(?!#(?:no)?regex)/){
				eval "s\x1e$re[$i]\x1e$re_sub[$i]\x1eg;";
			}
		}
		if(/\n/){
			local $re_start = $re_n;
			$text .= parse($_, @parse_line)
				foreach split /\n/, $_, -1;
			return;
		}
	}
	# Wiki but not asis
	if($wiki && !$asis){
		# Skip admin code
		return if "##" eq substr $_, 0, 2;
		# Escape inline perl code
		s/``(.*?)``/`\x00`$1`\x00`/g;
	}
	# Process code block
	if($code_block ne ""){
		if($_ eq "##}"){
			my $block = "$code_block}";
			$code_block = "";
			run_code_block($block);
		}else{
			$code_block .= "$_\n";
		}
		return;
	}

	return $_;
}

sub process_block{
	# return undef to skip to the next line
	# return the current line for further processing
	local $_ = shift;

	# Process syntax block
	if($syntax_block ne ""){
		if(")" eq substr($_, 0, 1) && "_" ne substr($_, 1, 1)){
			my $block = $syntax_block.substr($_, 1);
			$syntax_block = "";
			$_ = create_syntax_block($block);
		}else{
			$syntax_block .= "$_\n";
			return;
		}
	}

	return $_;
}

sub process_asis_lines{
	# return undef to skip to the next line
	# return the current line for further processing
	local $_ = shift;

	# Start or close nosyntax
	if(/^("""+)$/ && !$pre && (!$nosyntax || $nosyntax == length($1))){
		if($nosyntax){
			$asis = 0;
			$nosyntax = 0;
		}else{
			$_->() foreach @close_all_open;
			$asis = 1;
			$nosyntax = length($1);
		}
		return;
	}
	# Inside nosyntax
	if($nosyntax){
		s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g; s/\x00//g;
		$text .= "$_\n";
		return;
	}
	# Start or close pre
	if(/^(---+)(?:\[(.*)\])?$/ &&
	   (!$pre || ($pre == length($1) && ($2 eq "" || $pre_code eq $2)))){
		if($pre){
			chomp $text;
			if($pre_code eq ""){
				$text .= "</pre>\n";
			}else{
				$text .= "</code></pre>\n";
				$pre_code = "";
			}
			$asis = 0;
			$pre = 0;
		}else{
			$_->() foreach @close_all_open;
			if($2 eq ""){
				$text .= "<pre>";
			}else{
				$text .= qq(<pre><code class="language-$2">);
				$pre_code = $2;
			}
			$asis = 1;
			$pre = length($1);
		}
		return;
	}
	# Inside pre
	if($pre){
		s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g; s/\x00//g;
		$text .= "$_\n";
		return;
	}

	return $_;
}

sub skip_comment{
	# return undef to skip to the next line
	# return the current line for further processing
	local $_ = shift;

	# Skip comment
	return if "%" eq substr $_, 0, 1;

	return $_;
}

sub process_wiki_command{
	# return undef to skip to the next line
	# return the current line for further processing
	local $_ = shift;

	# Register regular expressions
	if(/^#regex (.)(.+)(?<!\\)\1(.*)(?<!\\)\1$/){
		# Don't allow code embedding in a wiki page
		return if($wiki && (index($2, '(?{') != -1 ||
				    index($2, '(??{') != -1 ||
				    index($3, '@{[') != -1));

		my $i;
		for($i = 0; $i < $re_n; $i++){
			last if $re[$i] eq $2;
		}
		$re[$re_n++] = $2 if $i == $re_n;
		$_ = $3;
		# Treat a single backslash as an escape character
		s/(?<!\\)\\(?![\\a-zA-Z0-9])/\x00/g;
		# Don't allow access to variables
		s/([\$@%\[\]])/\\\1/g;
		$re_sub[$i] = $_;
		return;
	}
	# Register multi-line regular expressions
	if(/^#regex (.)(.+)(?<!\\)\1$/){
		# Don't allow code embedding in a wiki page
		return if($wiki && (index($2, '(?{') != -1 ||
				    index($2, '(??{') != -1));

		$re_block = "$1$2\n";
		return;
	}
	# Clear regular expressions
	if(/^#noregex(?:| (.)(.+)(?<!\\)\1)$/){
		if($2 eq ""){
			$re_n = 0;
			$#re = $#re_sub = -1;
		}else{
			for(my $i = 0; $i < $re_n; $i++){
				if($re[$i] eq $2){
					$re_n--;
					for(; $i < $re_n; $i++){
						$re[$i] = $re[$i+1];
						$re_sub[$i] = $re_sub[$i+1];
					}
					$#re = $#re_sub = $re_n - 1;
					last;
				}
			}
		}
		return;
	}
	# Output verbose html code
	if(/^#html (.+)$/){
		$_->() foreach @close_all_open;
		$text .= "$1\n";
		return;
	}
	# Table of contents
	if(/^#toc ([0-5])$/){
		$toc_dep = $1 ? $1 + 1 : 0;
		return;
	}
	if("#notoc" eq $_){
		$toc_dep = 0;
		return;
	}
	# List of tables
	if("#lot" eq $_){
		$nolot = 0;
		return;
	}
	# List of figures
	if("#lof" eq $_){
		$nolof = 0;
		return;
	}

	return $_;
}

sub process_nonwiki_command{
	# return undef to skip to the next line
	# return the current line for further processing
	local $_ = shift;

	# Include another Uniqki file
	if(/^##include (.+)$/){
		local *FH;
		if(open FH, $1){
			my $line = <FH>;
			my $inc_wiki = 0;
			if($line eq "#!wiki\n"){
				$inc_wiki = 1 unless $wiki;
			}else{
				$text .= parse($line, @parse_line);
			}
			local $wiki = 1 if $inc_wiki;
			$text .= parse($_, @parse_line) while <FH>;
			close FH;
		}
		return;
	}
	# Shell command
	if(/^##shell (.+)$/){
		$_->() foreach @close_all_open;
		$text .= `$1`;
		return;
	}
	# Perl subroutine or code
	if(/^##((?:sub |{).*)$/){
		if("}" eq substr $1, -1){
			eval $1;
			$text .= "<pre>$@</pre>" if $preview && $@;
			return;
		}
		$code_block = "$1\n";
		return;
	}

	return $_;
}

sub skip_unknown_command{
	# return undef to skip to the next line
	# return the current line for further processing
	local $_ = shift;

	# Ignore other lines starting with #
	return if "#" eq substr $_, 0, 1;

	return $_;
}

sub start_block{
	# return undef to skip to the next line
	# return the current line for further processing
	local $_ = shift;

	# Syntax block
	if("(" eq substr $_, -1){
		# Process the first line later
		$syntax_block = (substr $_, 0, length($_) - 1)."\n";
		return;
	}

	return $_;
}

sub process_collected_lines{
	# return undef to skip to the next line
	# return the current line for further processing
	local $_ = shift;

	# Close blockquote
	if($blockquote ne "" && !(/^((?:  ){0,})(>[ \t])?/ && "$1$2" ne "")){
		close_paragraph();
		$text .= create_blockquote($blockquote);
		$blockquote = "";
	}
	# Close list
	if($list ne "" && !(/^((?:  ){0,})((?:[*+-]|: .*?:)[ \t])?/ &&
	   "$1$2" ne "")){
		close_paragraph();
		$text .= create_list($list);
		$list = "";
	}
	# Close table
	if($table ne "" &&
	   !/^(?:!!?[ \t](?:.*[ \t])?!?!|[|^][ \t](?:.*[ \t])?(?:[!^]+|\|+_?))$/){
		close_paragraph();
		$text .= create_table($table);
		$table = "";
	}
	# Close figure
	if($figure ne "" &&
	   !/^(?:"!?[ \t](?:.*[ \t])?!?"|@[ \t](?:.*[ \t])?@)$/){
		close_paragraph();
		$text .= create_figure($figure);
		$figure = "";
	}

	return $_;
}

sub process_paragraph_break{
	# return undef to skip to the next line
	# return the current line for further processing
	local $_ = shift;

	if("" eq $_ || /^___+$/){
		# Close the current paragraph or draw a horizontal line
		close_paragraph();
		# Horizontal line
		$text .= "<hr />\n" if $_ ne "";
		return;
	}

	return $_;
}

sub escape_inline_syntax{
	# return undef to skip to the next line
	# return the current line for further processing
	local $_ = shift;
	s#([`"/*'_!\[{<-]|[a-z]+://)#\x00$1#gi;
	return $_;
}

sub process_inline_syntax{
	# return undef to skip to the next line
	# return the current line for further processing
	# \x00: escape character
	# \x01: &
	# \x02: <
	# \x03: >
	# \x04: temporary character
	local $_ = shift;

	# Convert escaped [&<>] to \x01, \x02, and \x03
	s/\x00&/\x01/g; s/\x00</\x02/g; s/\x00>/\x03/g;

	# Escape inline syntax. \x00[&<>] may be generated.
	s/""(.)(.*?)\1""/@{[parse($2, @escape_inline_syntax)]}/g;

	# Convert \x00[&<>] from escaped inline syntax to \x04[&<>]
	s/\x00([&<>])/\x04$1/g;
	# Restore escaped [&<>] from the text
	s/\x01/\x00&/g; s/\x02/\x00</g; s/\x03/\x00>/g;
	# Restore escaped [&<>] from escaped inline syntax
	s/\x04&/\x00\x01/g; s/\x04</\x00\x02/g; s/\x04>/\x00\x03/g;
	# Regular [&<>] should not be translated to html codes at this point
	# because page names and links will be affected.  Instead, flag them so
	# that they can be converted to html later.  This flagging does not
	# apply to escaped characters (\x00[&<>]).  Escaped characters may come
	# from the #regex syntax to enter [&<>] as is without converting them
	# to &amp, &lt, and &gt.
	s/(?<!\x00)&/\x01/g; s/(?<!\x00)</\x02/g; s/(?<!\x00)>/\x03/g;

	# Pages
	s/\[\[(.*?)(?:#(.*?))?(?:\|(.*?))?\]\]/@{[link_page($1, $2, $3)]}/g;
	# Images
	s/\{\{\{(.*?)(?:\|(.*?))?}}}(?:\[(.*?)\])?/@{[link_image($1, $2, $3)]}/g;
	# Files
	s/\{\{(.*?)(?:\|(.*?))?}}/@{[link_file($1, $2)]}/g;
	# URL images
	s/\x02\x02\x02(.*?)(?:\|(.*?))?\x03\x03\x03(?:\[(.*?)\])?/@{[link_url_image($1, $2, $3)]}/g;
	# URLs
	s/\x02\x02(.*?)(?:\|(.*?))?\x03\x03/@{[link_url($1, $2)]}/g;
	# Text styles
	# Avoid conflicts with //italic//
	s#([a-z]+:/)(/)(/)?#$1\x00$2\x00$3#gi;
	s#//(.*?)//#<i>$1</i>#g;
	s#([a-z]+:/)\x00(/)\x00#$1$2#gi;
	s#\*\*(.*?)\*\*#<b>$1</b>#g;
	s#''(.*?)''(?:\[(.*?)\])?#@{[$2 eq "" ? "<code>$1</code>" : qq(<code class="language-$2">$1</code>)]}#g;
	s#--(.*?)--#<s>$1</s>#g;
	s#__(.*?)__#<u>$1</u>#g;
	s#\!\!(.*?)\!\!#<mark>$1</mark>#g;
	# Protect protocols inside tags
	s#<([^>]*(?:[a-z]+://)[^>]*)>#<@{[protect_urls($1)]}>#gi;
	# Protect protocols outside tags
	s#(<a [^>]*>)([^<]*(?:[a-z]+://)[^<]*)(</a\x00?>)#$1@{[protect_urls($2)]}$3#gi;
	# Translate non-protected protocols to links
	s#(?<![a-zA-Z\x00])((?:[a-z]+://)[\x01$url_char]+\x01[a-z]+;)(?=(?:[ \t]|$))#<a class="auto-title" href="\x00$1">\x00$1</a>#ogi;
	s#(?<![a-zA-Z\x00])((?:[a-z]+://)[\x01$url_char]+)(?=[$url_punct](?:[ \t]|$))#<a class="auto-title" href="\x00$1">\x00$1</a>#ogi;
	s#(?<![a-zA-Z\x00])((?:[a-z]+://)[\x01$url_char]+)#<a class="auto-title" href="\x00$1">\x00$1</a>#ogi;
	s/\x01/&amp;/g; s/\x02/&lt;/g; s/\x03/&gt;/g;

	return $_;
}

sub collect_lines{
	# return undef to skip to the next line
	# return the current line for further processing
	local $_ = shift;

	# Collect quote lines
	if(/^((?:  ){0,})(&gt;[ \t])?/ && "$1$2" ne "" &&
	   "$2$blockquote" ne ""){
		$blockquote .= "$_\n";
		return;
	}
	# Collect list lines
	if(/^((?:  ){0,})((?:[*+-]|: .*?:)[ \t])?/ && "$1$2" ne "" &&
	   "$2$list" ne ""){
		$list .= "$_\n";
		return;
	}
	# Collect table lines
	if(/^(?:!!?[ \t](?:.*[ \t])?!?!|[|^][ \t](?:.*[ \t])?(?:[!^]+|\|+_?))$/){
		$table .= "$_\n";
		return;
	}
	# Collect figure lines
	if(/^(?:"!?[ \t](?:.*[ \t])?!?"|@[ \t](?:.*[ \t])?@)$/){
		$figure .= "$_\n";
		return;
	}

	return $_;
}

sub process_line_syntax{
	# return undef to skip to the next line
	# return the current line for further processing
	local $_ = shift;

	# Heading
	if(/^(=+)!? (.*)$/ && length($1) <= 6){
		my $h = length($1);
		my $num_sec = "!" ne substr $_, $h, 1 ? 1 : 0;
		$_ = $2;
		# Inline perl code
		s/``(.*?)``/$1/eeg;
		s/^[ \t]+|[ \t]+$//g;
		# Discard none characters
		y/\x00//d;
		close_paragraph();
		create_edit_section();

		if($h == 1){
			if($TITLE eq ""){
				$TITLE = $_;
				$TITLE =~ s/<[^>]*>//g;
			}
			$text .= qq(<h$h>$_</h$h>\n);
			return;
		}

		$text .= "\x05" if $num_sec && $toc eq "";

		if($h > $h_prev){
			if($h_prev){
				while($h_prev++ < $h){
					$toc .= "<li><ul>"
						if $h_prev <= $toc_dep;
					$text .= "<section>\n" if $h_prev < $h;
				}
				$h_prev--;
			}else{
				while(++$h_prev + 1 < $h){
					$toc .= "<li><ul>"
						if $h_prev + 1 < $toc_dep;
					$text .= "<section>\n";
				}
				$h_prev++;
				$h_top = $h;
			}
			$toc .= "\n";
		}elsif($h < $h_prev){
			while(--$h_prev >= $h){
				$toc .= "</ul></li>" if $h_prev < $toc_dep;
				$text .= "</section>\n";
			}
			$toc .= "\n";
			$text .= "</section>\n";
			$h_prev++;
			$h_top = $h if $h < $h_top;
		}else{
			$text .= "</section>\n";
		}

		(my $title = $_) =~ s/<[^>]*>//g;
		my $id = $title;
		$id =~ s/&amp;/&/g;
		$id =~ s/&lt;/</g;
		$id =~ s/&gt;/>/g;
		$id = convert_page_name($id);
		my $sec = "";

		my $i = $h_n{$id}++;
		if($i > 0){
			$id .= $i + 1;
			$h_n{$id}++;
		}

		$secs_no{$h}++;
		for($i = $h + 1; $i <= 6; $i++){
			$secs_no{$i} = 0;
		}

		my $found = 0;
		for($i = 2; $i <= $h; $i++){
			if($secs_no{$i}){
				$found = 1;
			}elsif(!$found){
				next;
			}
			$sec .= $SECTION_NUMBER_SEPARATOR if $sec ne "";
			$sec .= $secs_no{$i};
		}
		$h_secs{$id} = $sec;
		if($num_sec){
			$sec = qq(<span class="section-number">$SECTION_NUMBER_PREFIX$sec$SECTION_NUMBER_SUFFIX</span>);
			my $enc_id = encode_url_safe($id);
			$toc .= "<li><a href=\"#$enc_id\">$sec$title</a></li>\n"
				if $h <= $toc_dep;
		}else{
			$sec = "";
		}
		$text .= qq(<section id="$id">\n<h$h>$sec$_</h$h>\n);

		return;
	}

	return $_;
}

sub start_paragraph{
	# return undef to skip to the next line
	# return the current line for further processing
	local $_ = shift;

	# Start a new paragraph
	if(!$p){
		$text .= "<p>";
		$p = 1;
	}

	return $_;
}

sub postprocess_line{
	# return undef to skip to the next line
	# return the current line for further processing
	local $_ = shift;

	# Handle <p> tags around syntax blocks
	s#(\x06)#</p>$1<p>#g;
	# Inline perl code
	s/``(.*?)``/$1/eeg;
	# Discard none characters
	y/\x00//d;

	return $_;
}

sub close_all_open{
	if($fresh_block ne ""){
		my $block = $fresh_block;
		$fresh_block = "";
		local $_ = create_fresh_block($block);
		$text .= parse($_, @parse_line);
	}
	if($code_block ne ""){
		my $block = "$code_block}";
		$code_block = "";
		run_code_block($block);
	}
	if($syntax_block ne ""){
		my $block = $syntax_block;
		$syntax_block = "";
		local $_ = create_syntax_block($block);
		$text .= parse($_, @parse_line);
	}
	if($nosyntax){
		$asis = 0;
		$nosyntax = 0;
	}
	if($pre){
		chomp $text;
		if($pre_code eq ""){
			$text .= "</pre>\n";
		}else{
			$text .= "</code></pre>\n";
			$pre_code = "";
		}
		$asis = 0;
		$pre = 0;
	}
	close_paragraph();
	if($blockquote ne ""){
		$text .= create_blockquote($blockquote);
		$blockquote = "";
	}
	if($list ne ""){
		$text .= create_list($list);
		$list = "";
	}
	if($table ne ""){
		$text .= create_table($table);
		$table = "";
	}
	if($figure ne ""){
		$text .= create_figure($figure);
		$figure = "";
	}
}

################################################################################
# User-replaceable subroutines
sub preprocess_text{
}

sub verify_input{
	# return 1 if OK
	# return 0 otherwise
	my ($query, $var) = @_;
	if($query eq "comment"){
		return 0 if($$var{website} ne "" ||
			    $$var{id} >= time - $MINIMUM_COMMENT_TIME);
		(my $text = $$var{text}) =~ s/[`~!@#\$%^&*_=+\\|;:'",.\/?()\[\]{}<>0-9-]//g;
		$text =~ s/[ \t\n]+/ /g;
		$text =~ s/^ | $//g;
		return 0 if $text eq "";

		$$var{text} =~ s/^[ \t\n]+|[ \t\n]+$//g;
	}
	return 1;
}

sub begin_parsing{
	my $block_level = shift;

	$url_char = 'a-zA-Z0-9:@/~%.,_$?=&;#+-';
	$url_punct = '.,;:!?';

	$text = "";

	$fresh_block = "";
	$code_block = "";
	$syntax_block = "";
	@parsed_blocks = ();
	$p = 0;
	$asis = 0;
	$nosyntax = 0;
	$pre = 0;
	$pre_code = "";
	$blockquote = "";
	$list = "";
	$table = "";
	$figure = "";

	if(!$block_level){
		$re_block = "";
		$re_start = 0;
		$re_n = 0;
		@re = ();
		@re_sub = ();
		@h_lines = ();
		%h_n = ();
		$h_top = 0;
		$h_prev = 0;
		%h_secs = ();
		%secs_no = ();
		$toc = "";
		$toc_dep = 6;
		$tab_no = 0;
		%tabs_n = ();
		%tabs = ();
		$lot = "";
		$nolot = 1;
		$fig_no = 0;
		%figs_n = ();
		%figs = ();
		$lof = "";
		$nolof = 1;
	}
}

sub parse_line{
	# parse one line $_[0] using the default parsers
	# \x00: none or escape character
	# \x01-\x04: temporary characters
	# \x05: place holder for TOC
	# \x06: place holder for a parsed block
	# \x1e: delimiter
	# %comment
	# #wiki command
	# ##non-wiki command
	# ``inline perl code``
	local $_ = shift;
	y/\n//d;

	foreach my $parser (
		@process_raw_block,
		@preprocess_line,
		@process_block,
		@process_asis_lines,
		@skip_comment,
		@process_wiki_command,
		@process_nonwiki_command,
		@skip_unknown_command,
		@start_block,
		@process_collected_lines,
		@process_paragraph_break,
		@process_inline_syntax,
		@collect_lines,
		@process_line_syntax,
		@start_paragraph,
		@postprocess_line){
		$_ = $parser->($_);
		return unless defined;
	}

	return "$_\n";
}

sub end_parsing{
	my $block_level = shift;

	$_->() foreach @close_all_open;

	if(!$block_level){
		create_edit_section() if $#h_lines >= 0;
		my $clean_toc = $toc_dep > 0 && $toc ne "";
		my $h = $h_prev;
		$toc = "<ul class=\"toc-list\">\n$toc" if $clean_toc;
		while(--$h_prev > 0){
			$toc .= "</ul></li>" if $clean_toc;
			$text .= "</section>\n";
		}
		if($clean_toc){
			$toc .= ($h > 1 ? "\n" : "")."</ul>\n";
			for(my $h = 0; $h < $h_top - 1; $h++){
				$toc =~ s#^(.*\n)<li><ul>#\1#;
				$toc =~ s#</ul></li>(\n.*)$#\1#;
			}
			$toc =~ s#</li>\n<li>(<ul>)#\n\1#g;
			$toc =~ s#\n+#\n#g;
			my $heading = get_msg("table_of_contents");
			$toc = "<div id=\"toc\">\n".
				"<div class=\"toc-heading\">$heading</div>\n".
				"$toc</div>\n";
			$text =~ s/(\x05)/$toc$1/g;
		}
		foreach(keys %h_secs){
			my $enc_id = encode_url_safe($_);
			my $sec = $h_secs{$_};
			$text =~ s/(<a class="auto-title" href="#$enc_id">)[^<]*(<\/a>)/\1$SECTION_REFERENCE_PREFIX$sec$SECTION_REFERENCE_SUFFIX\2/g;
		}
		if(!$nolot && $lot ne ""){
			my $heading = get_msg("list_of_tables");
			$lot = "<div id=\"lot\">\n".
				"<div class=\"lot-heading\">$heading</div>\n".
				"<ul class=\"lot-list\">\n$lot</ul>\n</div>\n";
			$text =~ s/(\x05)/$lot$1/g;
		}
		foreach(keys %tabs){
			my $enc_id = encode_url_safe($_);
			my $tab = $tabs{$_};
			$text =~ s/(<a class="auto-title" href="#$enc_id">)[^<]*(<\/a>)/\1$TABLE_REFERENCE_PREFIX$tab$TABLE_REFERENCE_SUFFIX\2/g;
		}
		if(!$nolof && $lof ne ""){
			my $heading = get_msg("list_of_figures");
			$lof = "<div id=\"lof\">\n".
				"<div class=\"lof-heading\">$heading</div>\n".
				"<ul class=\"lof-list\">\n$lof</ul>\n</div>\n";
			$text =~ s/(\x05)/$lof$1/g;
		}
		foreach(keys %figs){
			my $enc_id = encode_url_safe($_);
			my $fig = $figs{$_};
			$text =~ s/(<a class="auto-title" href="#$enc_id">)[^<]*(<\/a>)/\1$FIGURE_REFERENCE_PREFIX$fig$FIGURE_REFERENCE_SUFFIX\2/g;
		}

		$re_block = "";
		$re_start = 0;
		$re_n = 0;
		@re = ();
		@re_sub = ();
		@h_lines = ();
		%h_n = ();
		$h_top = 0;
		$h_prev = 0;
		%h_secs = ();
		%secs_no = ();
		$toc = "";
		$toc_dep = 6;
		$tab_no = 0;
		%tabs_n = ();
		%tabs = ();
		$lot = "";
		$nolot = 1;
		$fig_no = 0;
		%figs_n = ();
		%figs = ();
		$lof = "";
		$nolof = 1;
	}
	$text =~ y/\x05//d;
	my $i = 0;
	$text =~ s/\x06/@{[$parsed_blocks[$i++]]}/g;
	@parsed_blocks = ();
	$text =~ y/\x06//d;
	$text =~ s#<([ibsu]|code|mark)>([ \t\n]*)</\1>#$2#g;
	$text =~ s#[ \t\n]*(<(?:p|li|dd)>)[ \t\n]*#\n$1#g;
	$text =~ s#[ \t\n]*(</(?:p|li|dd)>)[ \t\n]*#$1\n#g;
	$text =~ s#<p></p>\n##g;
	$text =~ s#^\n+|\n+$##g;
}

################################################################################
# Clean up
END{
	while(my $file = each %locked_files){
		unlock_file($file);
	}
}

if($PAGE eq $CGI && $FILE ne ""){
################################################################################
# u/u/.../PAGE?ACTION	Called from a secured site
	die_redirect("$HTTP_BASE$SCRIPT_NAME/$FILE?$QUERY_STRING");
}

$PAGE = convert_page_name($PAGE);
die_message("page_not_allowed", $PAGE)
	if $PAGES_NOT_ALLOWED ne "" && $PAGE =~ /$PAGES_NOT_ALLOWED/o;

################################################################################
# Login, logout
if($QUERY_STRING eq "logout"){
#-------------------------------------------------------------------------------
# u/PAGE?logout		Logout
	close_session();
	die_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE");
}elsif($QUERY_STRING eq "logout_all"){
#-------------------------------------------------------------------------------
# u/PAGE?logout_all	Logout from all computers
	clear_user_sessions();
	die_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE");
}

clear_expired_sessions();
handle_session();

if(!is_logged_in()){
if($QUERY_STRING eq "login"){
	if($REQUEST_METHOD eq "GET"){
#-------------------------------------------------------------------------------
# u/PAGE?login		GET login request: Login form
		local $TITLE = $PAGE;
		print_login();
		die;
	}else{
#-------------------------------------------------------------------------------
# u/PAGE?login		POST login request: Check credentials
		my %var = get_var();
		authenticate_user($var{user}, $var{pw}, $var{logout_others});
	}
}elsif($QUERY_STRING eq "loginout"){
#-------------------------------------------------------------------------------
# u?loginout		Loginout
# u/PAGE?loginout	Loginout
	die_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE?login");
}
}elsif($QUERY_STRING eq "loginout"){
#-------------------------------------------------------------------------------
# u?loginout		Loginout
# u/PAGE?loginout	Loginout
	die_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE?logout");
}

{
#-------------------------------------------------------------------------------
# Is this page wiki?
	my $page;
	local *FH;
	if($PAGE eq "" && ($QUERY_STRING eq "login" || $QUERY_STRING eq "")){
		$page = $INDEX_PAGE;
	}else{
		$page = $PAGE;
	}
	$wiki = 0;
	if($page ne ""){
		if(-f "$page.txt"){
			$wiki = is_wiki($page);
		}elsif($WIKI_PAGES_ALLOWED ne "" &&
		       $page =~ /$WIKI_PAGES_ALLOWED/o){
			$wiki = 1;
		}
	}
}

if($QUERY_STRING eq "css"){
#-------------------------------------------------------------------------------
# u?css			Print CSS
	print_css(2);
	die;
}elsif($QUERY_STRING eq "js"){
#-------------------------------------------------------------------------------
# u?js			Print JavaScript
	print_js(2);
	die;
}elsif($QUERY_STRING eq "user_info"){
#-------------------------------------------------------------------------------
# u/PAGE?user_info	Print user information
	my $page_exists = page_exists();
	my $has_read_access = $page_exists && has_read_access() ? 1 : 0;
	my $has_write_access = $page_exists && has_write_access() ? 1 : 0;
	die_text("$USER:$admin:$has_read_access:$has_write_access");
}elsif($QUERY_STRING =~ /^goto(?:[&=].+)?$/){
#-------------------------------------------------------------------------------
# u?goto		Create the goto form
# u?goto=PAGE		Go to or create PAGE using a form
	my %var = get_var();
	if($var{goto} eq ""){
		local $TITLE = get_msg("goto_form");
		print_header();
		create_goto_form(1);
		print_footer();
		die;
	}

	$_ = $var{goto};
	s#\.html$##;
	y#[/+]# #;

	die_redirect("$HTTP_BASE$SCRIPT_NAME/".encode_url_most($_));
}elsif($QUERY_STRING =~ /^comment(?:[&=].+)?$/){
#-------------------------------------------------------------------------------
# u/PAGE?comment			Generate the comment form for PAGE
#					(id=comment, down, rows=80, cols=6)
# u/PAGE?comment&direction=(up|down)	Generate the comment form for PAGE
#					(id=comment, (up|down), rows=80, cols=6)
# u/PAGE?comment&rows=([0-9]+)		Generate the comment form for PAGE
#					(id=comment, down, rows=\1, cols=6)
# u/PAGE?comment&cols=([0-9]+)		Generate the comment form for PAGE
#					(id=comment, down, rows=80, cols=\1)
# u/PAGE?comment=COMMENT		Generate the comment form for PAGE
#					(id=COMMENT, down, rows=80, cols=6)
# u?comment&page=PAGE			Generate the comment form for PAGE
#					(id=comment, down, rows=80, cols=6)
	my %var = get_var();
	if($REQUEST_METHOD eq "GET"){
		$PAGE = $var{page} if $var{page} ne "";
		if($PAGE eq ""){
			die_message("specify_comment_page");
		}elsif(!page_exists()){
			die_message("page_not_found", $PAGE);
		}

		local $TITLE = get_msg("comment_form");
		print_header();
		create_comment_form($PAGE, $var{comment}, $var{direction},
			$var{rows}, $var{cols}, 1);
		print_footer();
		die;
	}
	$PAGE = $var{page};
	unless(has_write_access(1)){
		my $msg_id = "not_allowed_to_comment_in_nonwiki_page";
		die_message($msg_id, $PAGE);
	}
	die_rebuild($PAGE) unless verify_input("comment", \%var);

	die_message("page_not_found", $PAGE) unless page_exists();

	die_message("invalid_comment_tag", $var{comment})
		unless $var{comment} =~ /^[a-zA-Z0-9_-]+$/;

	$var{text} = escape_comment($var{text});

	my $TEXT = "";
	my $time = format_time(time);
	my $added = 0;

	lock_file("$PAGE.txt");
	local *FH;
	if(open FH, "$PAGE.txt"){
		while(<FH>){
			if(/^#%$var{comment}$/){
				if($var{direction} eq "up"){
					$TEXT .= "$_#%$time\n$var{text}\n\n";
				}else{
					$TEXT .= "#%$time\n$var{text}\n\n$_";
				}
				$added = 1;
			}else{
				$TEXT .= $_;
			}
		}
		close FH;
	}
	die_message("comment_tag_not_found", "#%$var{comment}") unless $added;
	save($PAGE, $TEXT);
	unlock_file("$PAGE.txt");
}elsif($QUERY_STRING eq "forgot_password"){
#-------------------------------------------------------------------------------
# u?forgot_password		Forgot password
# u/PAGE?forgot_password	Forgot password
	if($REQUEST_METHOD eq "GET"){
		print_forgot_password();
		die;
	}

	my %var = get_var();
	die_message("enter_username_or_email_address")
		if $var{user} eq "" && $var{email} eq "";
	my ($user, $pw, $group, $email, $name, $token);
	$user = "";
	if($var{email} ne ""){
		die_message("check_email_address")
			unless is_email_address($var{email});
		my %user_info = find_user_info_by_email_address($var{email});
		$user = $user_info{user};
		$pw = $user_info{pw};
		$group = $user_info{group};
		$email = $user_info{email};
		$name = $user_info{name};
		$token = $user_info{token};
		die_message("email_address_not_found", $var{email})
			unless defined $user;
		die_message("user_info_mismatch")
			if $var{user} ne "" && $var{user} ne $user;
	}
	if($user eq ""){
		my %user_info = find_user_info($var{user});
		$user = $user_info{user};
		$pw = $user_info{pw};
		$group = $user_info{group};
		$email = $user_info{email};
		$name = $user_info{name};
		$token = $user_info{token};
		die_message("user_not_found", $var{user}) unless defined $user;
	}

	die_message("user_blocked", $user) if $pw eq "blocked";
	die_message("password_reset_token_still_valid")
		if is_password_reset_token_valid($token);

	$token = generate_password_reset_token($user);

	my $new_pw = "";
	my $token_added = 0;

	lock_file($PASSWORD_FILE);
	if(-f $PASSWORD_FILE){
		local *FH;
		open FH, $PASSWORD_FILE;
		while(<FH>){
			if(/^$user:/){
				$token_added = 1;
				my @items = split /:/;
				$_ = "$user:$items[1]:$items[2]:$items[3]:$items[4]:$token\n";
			}
			$new_pw .= $_;
		}
		close FH;
	}elsif($adminpw =~ /^$user:/){
		$token_added = 1;
		my @items = split /:/, $adminpw;
		$new_pw = "$user:$items[1]:$items[2]:$items[3]:$items[4]:$token\n";
	}

	# Something's wrong because a username already found does not exist
	die_message("internal_errors") unless $token_added;

	my $link = "$HTTP_BASE$SCRIPT_NAME?reset_password=$token";
	my $subject = get_msg("reset_password_email_subject", $DOC_BASE);
	my $text = get_msg("reset_password_email_text", $var{user}, $DOC_BASE,
		$link, $RESET_PASSWORD_TIMEOUT);
	die_message("email_notification_failed", $user, $email)
		unless send_email($email, $subject, $text);

	write_file($PASSWORD_FILE, $new_pw);
	unlock_file($PASSWORD_FILE);

	die_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE");
}elsif($QUERY_STRING eq "reset_password" && $REQUEST_METHOD eq "POST"){
#-------------------------------------------------------------------------------
# u?reset_password	Reset password
# u/PAGE?reset_password	Reset password
	my %var = get_var();
	die_message("invalid_password_reset_token")
		unless is_password_reset_token_valid($var{token});
	my %user_info = find_user_info_by_password_reset_token($var{token});
	my $user = $user_info{user};
	my $saved_pw = $user_info{pw};
	my $group = $user_info{group};
	my $email = $user_info{email};
	my $name = $user_info{name};
	die_message("password_reset_token_not_found") unless defined $user;

	die_message("confirm_password") if $var{pw} ne $var{pw2};
	die_message("check_password") unless is_password($var{pw});

	my $new_pw = "";
	my $reset = 0;

	lock_file($PASSWORD_FILE);
	if(-f $PASSWORD_FILE){
		local *FH;
		open FH, $PASSWORD_FILE;
		while(<FH>){
			if(/^$user:/){
				$reset = 1;
				my @items = split /:/;
				my $pw = hash_password($user, $var{pw});
				my $userline = "$user:$pw:$items[2]:$items[3]:$items[4]:\n";
				$_ = $userline;
			}
			$new_pw .= $_;
		}
		close FH;
	}
	# Password reset token cannot be found this time?
	die_message("internal_errors") unless $reset;

	write_file($PASSWORD_FILE, $new_pw);
	unlock_file($PASSWORD_FILE);

	die_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE");
}elsif($QUERY_STRING =~ /^reset_password=([a-zA-Z0-9]{64}\.([0-9]+))$/){
#-------------------------------------------------------------------------------
# u?reset_password=token	Reset password
# u/PAGE?reset_password=token	Reset password
	my $token = $1;
	my $expires = $2;

	my $time = time;
	if($time >= $expires){
		clear_password_reset_token($token);
		die_message("password_reset_token_expired");
	}

	local $PASSWORD_RESET_TOKEN = $token;
	print_reset_password();
	die;
}elsif($QUERY_STRING eq "manage_myself"){
#-------------------------------------------------------------------------------
# u?manage_myself	Manage myself
# u/PAGE?manage_myself	Manage myself
	print_manage_myself();
	die;
}elsif($QUERY_STRING eq "update_myself" && $REQUEST_METHOD eq "POST" && is_logged_in()){
#-------------------------------------------------------------------------------
# u?update_myself	Update myself
# u/PAGE?update_myself	Update myself
	my %var = get_var();
	die_message("confirm_password") if $var{pw} ne $var{pw2};
	die_message("check_password")
		if $var{pw} ne "" && !is_password($var{pw});
	die_message("enter_user_info_to_update")
		if $var{pw} eq "" && $var{email} eq "" && $var{name} eq "";

	my $new_pw = "";
	my $updated = 0;

	lock_file($PASSWORD_FILE);
	if(-f $PASSWORD_FILE){
		local *FH;
		open FH, $PASSWORD_FILE;
		while(<FH>){
			if(/^$USER:/){
				$updated = 1;
				my @items = split /:/;
				my $pw = $var{pw} ne "" ?
					hash_password($USER, $var{pw}) :
					$items[1];
				my $group = $items[2];
				my $email = $var{email} ne "" ?
					$var{email} : $items[3];
				my $name = $var{name} ne "" ?
					$var{name} : $items[4];
				my $token = $items[5];
				# new line from $items[5]
				my $userline = "$USER:$pw:$group:$email:$name:$token";
				if($userline eq $_){
					close FH;
					die_message("enter_user_info_to_update",
						$USER);
				}
				$_ = $userline;
			}
			$new_pw .= $_;
		}
		close FH;
	}else{
		my @items = split /:/, $adminpw;
		# Something's wrong because you're the only user, but the user
		# line in this script is not you! How did you login?
		die_message("internal_errors") if $USER ne $items[0];

		$updated = 1;
		my $pw = $var{pw} ne "" ? hash_password($USER, $var{pw}) :
			$items[1];
		my $group = $items[2];
		my $email = $var{email} ne "" ? $var{email} : $items[3];
		my $name = $var{name} ne "" ? $var{name} : $items[4];
		my $token = $items[5];
		# new line from $items[5]
		my $userline = "$USER:$pw:$group:$email:$name:$token";
		die_message("enter_user_info_to_update", $USER)
			if $userline eq $adminpw;
		$new_pw = "$userline\n";
	}
	# How did you login when your username is not found?
	die_message("internal_errors") unless $updated;

	write_file($PASSWORD_FILE, $new_pw);
	unlock_file($PASSWORD_FILE);

	die_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE?manage_myself");
}elsif($QUERY_STRING eq "delete_myself" && $REQUEST_METHOD eq "POST" && is_logged_in()){
#-------------------------------------------------------------------------------
# u?delete_myself	Delete myself
# u/PAGE?delete_myself	Delete myself
	my $new_pw = "";
	my $deleted = 0;
	my $nadmins = 0;

	lock_file($PASSWORD_FILE);
	if(-f $PASSWORD_FILE){
		local *FH;
		open FH, $PASSWORD_FILE;
		while(<FH>){
			$nadmins++ if $admin && /^(?:[^:]*:){2}admin:/;
			if(/^$USER:/){
				$deleted = 1;
				next;
			}
			$new_pw .= $_;
		}
		close FH;
	}
	# How did you login when your username is not found?
	die_message("internal_errors") unless $deleted;

	# You cannot delete yourself when you are the only admin
	die_message("cannot_delete_only_admin") if $nadmins == 1;

	clear_user_sessions($USER);

	write_file($PASSWORD_FILE, $new_pw);
	unlock_file($PASSWORD_FILE);

	die_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE");
}elsif(!has_read_access()){
#-------------------------------------------------------------------------------
# Read-secured
	die_message("admin_actions_not_allowed") if $PAGE eq "";
	die_message("read_secured");
################################################################################
# User actions
}elsif($QUERY_STRING eq "login" || $QUERY_STRING eq ""){
#-------------------------------------------------------------------------------
# u?login		Redirect to index after a successful login
# u/PAGE?login		Show PAGE after a successful login
# u			Redirect to index
# u/PAGE		Show PAGE
# u/PAGE/		List files belonging to PAGE
# u/PAGE/FILE		Download PAGE/FILE
# u/PAGE/DIR/...	Redirect to u/DIR/...
	die_redirect("$HTTP_BASE$SCRIPT_NAME/$FILE") if $FILE =~ m#/#;
	die_path("$PAGE/$FILE") if($FILE ne "" ||
		($PAGE ne "" && "/" eq substr $PATH_INFO, -1));
	die_redirect("$HTTP_BASE$SCRIPT_NAME/$INDEX_PAGE") if $PAGE eq "";
	unless(-f "$PAGE.txt"){
		my $msg_id = has_write_access() ?
			"create_page" : "page_not_found";
		die_message($msg_id, $PAGE);
	}
	$strip_query_string = 0 if $QUERY_STRING eq "";
}elsif($QUERY_STRING eq "files"){
# u/PAGE?files		List files belonging to PAGE
	die_path($PAGE);
}elsif($QUERY_STRING ne "delete" && $FILE ne ""){
#-------------------------------------------------------------------------------
# u/PAGE/FILE?query	Redirect to u/PAGE?query
	die_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE?$QUERY_STRING");
}elsif($QUERY_STRING eq "refresh" && $PAGE ne ""){
#-------------------------------------------------------------------------------
# u/PAGE?refresh	Refresh PAGE
	if(-f "$PAGE.txt"){
		$rebuild = 1;
	}else{
		my $msg_id = has_write_access() ?
			"create_page" : "page_not_found";
		die_message($msg_id, $PAGE);
	}
}elsif($QUERY_STRING =~ /^diff(?:=(-?[0-9]+))?$/){
#-------------------------------------------------------------------------------
# u/PAGE?diff		Diff current and previous version
# u/PAGE?diff=([0-9]+)	Diff current and \1 version
# u/PAGE?diff=-([0-9]+)	Diff current and current-\1 version
	die_message("page_not_found", $PAGE) unless page_exists();

	my $current_version = get_version($PAGE);
	my $version = $1 > 0 ? $1 : $current_version + ($1 < 0 ? $1 : -1);

	die_message("current_version", $PAGE, $current_version)
		if $version >= $current_version || $version <= 0;

	my $title = get_msg("differences", $PAGE, $version, $current_version);
	(local $TITLE = $title) =~ s/<[^>]*>//g;

	my $current_text = read_file("$PAGE.txt");

	my $text = $current_text;
	open FH, "$PAGE.txt.v"; local $/ = "\x00\n";
	while(<FH>){
		/^([0-9]+):.*?\n(.*)\x00\n$/s;
		$text = patch($text, $2);
		last if $version == $1 - 1;
	}
	close FH;

	print_header();
	print qq(<div id="diff">\n<h1>$title</h1>\n);

	my @line0 = split /\n/, $text, -1; $#line0--;
	my @line1 = split /\n/, $current_text, -1; $#line1--;
	my ($s, @delta) = lcs(\@line0, \@line1);
	my $m = $s;
	my $n;
	for($n = 0; $n < $s; $n++){
		$_ = $line1[$n];
		s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g;
		print qq(<div class="diff-unchanged">= $_</div>\n);
	}
	eval "use Encode qw(decode);";
	my $encode = $@ ? 0 : 1;
	for(my $i = 0; $i <= $#delta; $i++, $m++, $n++){
		my ($x, $y) = split /,/, $delta[$i];
		if($x > $m && $y > $n){
			for(; $m < $x && $n < $y; $m++, $n++){
				print qq(<div class="diff-modified">* );
				my $l0 = $line0[$m];
				my $l1 = $line1[$n];
				if($encode){
					$l0 = decode($CHARSET, $l0);
					$l1 = decode($CHARSET, $l1);
				}
				my @l0 = split //, $l0, -1; $#l0--;
				my @l1 = split //, $l1, -1; $#l1--;
				my ($is, @idelta) = lcs(\@l0, \@l1);
				my $im = $is;
				my $in;
				for($in = 0; $in < $is; $in++){
					$_ = $l1[$in];
					s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g;
					print;
				}
				for(my $ii=0; $ii<=$#idelta; $ii++,$im++,$in++){
					my ($ix, $iy) = split /,/, $idelta[$ii];
					if($ix > $im){
						print qq(<span class="diff-modified-deleted">);
						$_ = "";
						for(; $im < $ix; $im++){
							$_ .= $l0[$im];
						}
						s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g;
						print qq($_</span>);
					}
					if($iy > $in){
						print qq(<span class="diff-modified-added">);
						$_ = "";
						for(; $in < $iy; $in++){
							$_ .= $l1[$in];
						}
						s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g;
						print qq($_</span>);
					}
					if($in <= $#l1){
						$_ = $l1[$in];
						s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g;
						print;
					}
				}
				for(; $in <= $#l1; $in++){
					$_ = $l1[$in];
					s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g;
					print;
				}
				print qq(</div>\n);
			}
		}
		if($x > $m){
			for(; $m < $x; $m++){
				$_ = $line0[$m];
				s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g;
				print qq(<div class="diff-deleted">- $_</div>\n);
			}
		}
		if($y > $n){
			for(; $n < $y; $n++){
				$_ = $line1[$n];
				s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g;
				print qq(<div class="diff-added">+ $_</div>\n);
			}
		}
		if($n <= $#line1){
			$_ = $line1[$n];
			s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g;
			print qq(<div class="diff-unchanged">= $_</div>\n);
		}
	}
	for(; $n <= $#line1; $n++){
		$_ = $line1[$n];
		s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g;
		print qq(<div class="diff-unchanged">= $_</div>\n);
	}

	print qq(</div>\n);
	print_footer();
	die;
}elsif($QUERY_STRING =~ /^list(?:[&=].+)?$/){
#-------------------------------------------------------------------------------
# u?list		List all pages in alphabetical order
# u?list=az		List all pages in alphabetical order
# u?list=za		List all pages in reverse order
# u?list=taz		List all pages in alphabetical order of titles
# u?list=tza		List all pages in reverse order of titles
# u?list=rc		Recent changes
# u?list=oc		Old changes
# u?list&n=([0-9]+)	List only \1 pages in alphabetical order
# u?list&title=1	Print page titles instead of page names
# u?list&glob=GLOB	List all GLOB pages in alphabetical order
	my %var = get_var();
	my $msg_id;
	local $TITLE;
	if($var{glob} eq ""){
		$msg_id = $var{list} eq "rc" ? "recent_changes" :
			($var{list} eq "oc" ? "old_changes" :
			($var{list} eq "za" ? "all_pages_reversed" :
			"all_pages"));
		$TITLE = get_msg($msg_id);
	}else{
		$msg_id = $var{list} eq "rc" ? "recent_changes_matching" :
			($var{list} eq "oc" ? "old_changes_matching" :
			($var{list} eq "za" ? "all_pages_reversed_matching" :
			"all_pages_matching"));
		$TITLE = get_msg($msg_id, $var{glob});
	}

	print_header();
	print_list_pages($var{list}, $var{n}, $var{title}, $var{glob}, $TITLE);
	print_footer();
	die;
}elsif($QUERY_STRING =~ /^rss(?:[&=].+)?$/){
#-------------------------------------------------------------------------------
# u?rss			RSS for recent 10 pages
# u?rss=([0-9]+)	RSS for recent \1 pages
# u?rss&glob=GLOB	RSS for recent 10 GLOB pages
	my %var = get_var();
	my $glob = $var{glob} eq "" ? "*" : $var{glob};

	my $t = time;
	my @g = gmtime $t;
	my @l = localtime $t;
	my $g = $g[5]*31536000+$g[4]*2592000+$g[3]*86400+$g[2]*3600+$g[1]*60+
		$g[0];
	my $l = $l[5]*31536000+$l[4]*2592000+$l[3]*86400+$l[2]*3600+$l[1]*60+
		$l[0];
	my $i = 0;
	my @list;
	foreach(<$glob.txt>){
		next if substr($_,0,1) eq "." || index($_,"/") >= 0 || !-f $_;
		s/\.txt$//;
		if($PAGES_NOT_ALLOWED ne "" && /$PAGES_NOT_ALLOWED/o){
			next;
		}
		my $page = $_;
		next unless -f "$page.html";
		local $wiki = is_wiki($page);
		next unless has_read_access();

		my $t = (stat "$page.txt")[9];
		my @t = split / +/, scalar gmtime($t);
		$list[$i++] = sprintf "%d %s, %02d %s %d %s GMT %s",
			$t, $t[0], $t[2], $t[1], $t[4], $t[3], $page;
	}
	my $n = 10;
	$n = $1 if $var{rss} =~ /^([0-9]+)$/;
	$n = $i if $n > $i || !$n;
	(my $site_title = $SITE_TITLE) =~ s/<[^>]*>//g;
	(my $site_description = $SITE_DESCRIPTION) =~ s/<[^>]*>//g;
	print <<EOT;
Content-Type: application/rss+xml

<?xml version="1.0" encoding="$CHARSET"?>
<rss version="2.0">
<channel>
<title>$site_title</title>
<link>$DOC_BASE</link>
<description>$site_description</description>
EOT
	undef $/;
	$i = 0;
	foreach(reverse sort @list){
		my ($time, $page) = /^[0-9]+ (.+? GMT) (.*)$/;
		local *FH;
		open FH, "$page.html";
		my $text = <FH>;
		close FH;

		$text =~ s/\r//g;
		$text =~ s/^.*<!-- start text -->|<!-- end text -->.*$//sgi;

		my $has_more = ($text =~ s/<!-- more -->.*$//s);
		my $title;
		if($text =~ m#<h1[^>]*>(.+?)</h1>(.*)$#si){
			$title = $1;
			$text = $2;
			$title =~ s/<[^>]*>//g;
			$title =~ s/&[^ ]*;/ /g;
			$title =~ s/[ \t\n]+/ /g;
			$title =~ s/^ //;
			$title =~ s/ $//;
		}else{
			$title = $page;
		}
		$text =~ s#<!--.*?-->##sg;
		$text =~ s#<(script|style).*?</\1>##sgi;
		$text =~ s/<[^>]*>//g;
		$text =~ s/&[^ ]*;/ /g;
		$text =~ s/[ \t\n]+/ /g;
		$text =~ s/^ //;
		$text =~ s/ $//;
		if($text =~ /^((?:[^ ]+ ){20})/){
			$text = "$1...";
		}elsif($has_more){
			$text .= " ...";
		}
		print <<EOT;
<item>
<title>$title</title>
<link>$DOC_BASE/$page.html</link>
<description>$text</description>
<pubDate>$time</pubDate>
</item>
EOT
		last if ++$i == $n;
	}
	print <<EOT;
</channel>
</rss>
EOT
	die;
}elsif($QUERY_STRING =~ /^search(?:[&=].+)?$/){
#-------------------------------------------------------------------------------
# u?search			Create the search form
# u?search=(.*)			Search using regular expressions
# u?search=(.*)&simple=1	Search using space separated words
# u?search=(.*)&icase=1		Case-insensitive search
# u?search=(.*)&link=1		Search for pages which link to \1 page
# u?search=(.*)&title=1		Print page titles instead of page names
# u?search=(.*)&nomatch=1	Don't print matches
# u?search=(.*)&glob=GLOB	Search GLOB pages
	my %var = get_var();
	if($var{search} eq ""){
		local $TITLE = get_msg("search_form");
		print_header();
		create_search_form(1);
		print_footer();
		die;
	}

	$_ = $var{search};
	s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g;

	local $TITLE;
	if($var{glob} eq ""){
		$TITLE = get_msg("search", $_);
	}else{
		$TITLE = get_msg("search_matching", $var{glob}, $_);
	}

	print_header();
	print_search_pages($var{search}, $var{simple}, $var{icase}, $var{link},
		$var{title}, $var{nomatch}, $var{glob}, $TITLE);
	print_footer();
	die;
}elsif($QUERY_STRING =~ /^wiki_/){
#-------------------------------------------------------------------------------
# Uniqki Wiki
	unless(has_write_access()){
		my $msg_id;
		if($wiki){
			if(-f "$PAGE.txt"){
				$msg_id = "not_allowed_to_edit_wiki_page";
			}else{
				$msg_id = "not_allowed_to_create_wiki_page";
			}
		}else{
			if(-f "$PAGE.txt"){
				$msg_id = "not_wiki_page";
			}else{
				$msg_id = "not_allowed_to_create_nonwiki_page";
			}
		}
		die_message($msg_id, $PAGE);
	}
	if($QUERY_STRING =~ /^wiki_edit(?:=(-?[0-9]+))?$/){
		if($REQUEST_METHOD eq "GET"){
#-------------------------------------------------------------------------------
# u/PAGE?wiki_edit		Create/edit PAGE
# u/PAGE?wiki_edit=([0-9]+)	Edit the version \1 of PAGE
# u/PAGE?wiki_edit=-([0-9]+)	Edit the current-\1 version of PAGE
			die_message("page_not_found", $PAGE)
				if $1 ne "" && !page_exists();

			local $TITLE = $PAGE;
			local $TEXT = "";
			local $VERSION = get_version($PAGE);

			if($1 eq "" && page_exists()){
				$TEXT = read_file("$PAGE.txt");
				die_message("internal_errors")
					if "#!wiki\n" ne substr $TEXT, 0, 7;

				$TEXT = substr $TEXT, 7;
				$TEXT =~ s/&/&amp;/g;
				$TEXT =~ s/</&lt;/g;
				$TEXT =~ s/>/&gt;/g;
			}elsif($1 ne ""){
				local *FH;

				my $version = $1 > 0 ? $1 : $VERSION + $1;

				$TEXT = read_file("$PAGE.txt");
				die_message("internal_errors")
					if "#!wiki\n" ne substr $TEXT, 0, 7;

				die_message("current_version", $PAGE, $version)
					if $version >= $VERSION || $version <= 0;

				open FH, "$PAGE.txt.v"; local $/ = "\x00\n";
				while(<FH>){
					/^([0-9]+):.*?\n(.*)\x00\n$/s;
					$TEXT = patch($TEXT, $2);
					last if $version == $1 - 1;
				}
				close FH;
				# Previous version was not a wiki page
				die_message("not_wiki_page", $PAGE)
					if "#!wiki\n" ne substr $TEXT, 0, 7;

				$TEXT = substr $TEXT, 7;
				$TEXT =~ s/&/&amp;/g;
				$TEXT =~ s/</&lt;/g;
				$TEXT =~ s/>/&gt;/g;
			}
			chomp $TEXT;
			$VERSION++;
			preprocess_text();
			print_wiki_edit();
			die;
		}else{
			my %var = get_var();
			die_rebuild($PAGE)
				unless verify_input($QUERY_STRING, \%var);

			local *FH;
			my $t = time;

			if(-f "$PAGE.txt"){
				open FH, "$PAGE.txt";
				if(<FH> ne "#!wiki\n"){
					close FH;
					die_message("internal_errors");
				}
				close FH;
			}

			local $VERSION = $var{version};
			local $TEXT = $var{text};
			if($VERSION != get_version($PAGE) + 1){
				print_updated();
				die;
			}
			my $file_links;
			foreach my $key (keys %var){
				next unless $key =~ /^file[0-9]*$/ &&
					    $var{$key} =~ /$WIKI_FILES_ALLOWED/oi;
				mkdir $PAGE, 0755 if !-d $PAGE;
				write_file("$PAGE/$t.$var{$key}", $var{"$key="}, 1);
				chmod 0755, "$PAGE/$t.$var{$key}"
					if $hosting eq "awardspace";
				$file_links .= "{{$t.$var{$key}|$var{$key}}}\n"
					if -f "$PAGE/$t.$var{$key}";
			}
			chomp $file_links;
			if($var{preview} eq ""){
				$TEXT .= "\n$file_links" if $file_links;
			}else{
				my $uploaded;
				$uploaded = get_msg("wiki_files_uploaded",
						    $file_links) if $file_links;
				preview($PAGE, $TEXT, $uploaded, 1);
				die;
			}
			lock_file("$PAGE.txt");
			save($PAGE, "#!wiki\n$TEXT\n");
			unlock_file("$PAGE.txt");
		}
	}elsif($QUERY_STRING =~ /^wiki_edit_lines(?:=([0-9]+)(?:,([0-9]+))?)?$/){
#-------------------------------------------------------------------------------
# u/PAGE?wiki_edit_lines			Save new PAGE lines
# u/PAGE?wiki_edit_lines=([0-9]+),([0-9]+)	Edit PAGE \2 lines from \1
# u/PAGE?wiki_edit_lines=([0-9]+)		Edit PAGE lines from \1 to end
		if($REQUEST_METHOD eq "GET"){
			die_message("page_not_found", $PAGE)
				unless page_exists();
			open FH, "$PAGE.txt";
			if(<FH> ne "#!wiki\n"){
				close FH;
				die_message("internal_errors");
			}
			close FH;

			local $TITLE = $PAGE;
			local $VERSION = get_version($PAGE) + 1;
			local $START = $1;
			local $COUNT = $2;
			$START = 2 if $START < 2;
			local $TEXT = read_lines("$PAGE.txt", $START, $COUNT);
			if($TEXT ne ""){
				$TEXT =~ s/&/&amp;/g;
				$TEXT =~ s/</&lt;/g;
				$TEXT =~ s/>/&gt;/g;
			}
			chomp $TEXT;
			preprocess_text();
			print_wiki_edit_lines();
			die;
		}else{
			my %var = get_var();
			die_rebuild($PAGE)
				unless verify_input($QUERY_STRING, \%var);

			local *FH;
			my $t = time;

			if(-f "$PAGE.txt"){
				open FH, "$PAGE.txt";
				if(<FH> ne "#!wiki\n"){
					close FH;
					die_message("internal_errors");
				}
				close FH;
			}

			local $VERSION = $var{version};
			local $START = $var{start};
			local $COUNT = $var{count};
			local $TEXT = $var{text};
			if($VERSION != get_version($PAGE) + 1){
				print_updated();
				die;
			}
			my $file_links;
			foreach my $key (keys %var){
				next unless $key =~ /^file[0-9]*$/ &&
					    $var{$key} =~ /$WIKI_FILES_ALLOWED/oi;
				mkdir $PAGE, 0755 if !-d $PAGE;
				write_file("$PAGE/$t.$var{$key}", $var{"$key="}, 1);
				chmod 0755, "$PAGE/$t.$var{$key}"
					if $hosting eq "awardspace";
				$file_links .= "{{$t.$var{$key}|$var{$key}}}\n"
					if -f "$PAGE/$t.var{$key}";
			}
			chomp $file_links;
			if($var{preview} eq ""){
				$TEXT .= "\n$file_links" if $file_links;
			}else{
				my $uploaded;
				$uploaded = get_msg("wiki_files_uploaded",
						    $file_links) if $file_links;
				preview_lines($PAGE, $START, $COUNT, $TEXT,
					$uploaded, 1);
				die;
			}
			lock_file("$PAGE.txt");
			save_lines($PAGE, $START, $COUNT, "$TEXT\n");
			unlock_file("$PAGE.txt");
		}
	}elsif($QUERY_STRING eq "wiki_upload"){
#-------------------------------------------------------------------------------
# u/PAGE?wiki_upload	Wiki upload
		my %var = get_var();
		die_rebuild($PAGE) unless verify_input($QUERY_STRING, \%var);

		local *FH;
		my $t = time;

		die_message("internal_errors") if $var{file} eq "";
		die_message("page_not_found", $PAGE) unless page_exists();
		die_message("wiki_file_not_allowed", $var{file})
			if($WIKI_FILES_ALLOWED eq "" ||
			   $var{file} !~ /$WIKI_FILES_ALLOWED/oi);

		open FH, "$PAGE.txt";
		if(<FH> ne "#!wiki\n"){
			close FH;
			die_message("internal_errors");
		}
		close FH;

		mkdir $PAGE, 0755 if !-d $PAGE;
		write_file("$PAGE/$t.$var{file}", $var{"file="}, 1);
		chmod 0755, "$PAGE/$t.$var{file}" if $hosting eq "awardspace";
		die_message("wiki_files_uploaded",
			"{{$t.$var{file}|$var{file}}}");
	}
################################################################################
# Admin actions
}elsif($admin && $insecure_pw){
#-------------------------------------------------------------------------------
# Admin password is still temporary. No admin actions are allowed other than
# changing the password.
	die_message("change_admin_password");
}elsif($QUERY_STRING eq "manage_pages"){
#-------------------------------------------------------------------------------
# u?manage_pages	Manage pages
# u/PAGE?manage_pages	Manage pages
	die_message("admin_actions_not_allowed") unless $admin;
	print_manage_pages();
	die;
}elsif($QUERY_STRING eq "backup"){
#-------------------------------------------------------------------------------
# u?backup		Backup all pages
# u/PAGE?backup		Backup PAGE
	die_message("admin_actions_not_allowed") unless $admin;
	eval "use Archive::Zip;1" or
		die_message("perl_module_not_installed", "Archive::Zip");

	my $zip = Archive::Zip->new();
	my $file;
	if($PAGE eq ""){
		$file = "u.zip";
		$zip->addTree(".");
	}else{
		$file = "$PAGE.zip";
		foreach("txt", "txt.v", "html"){
			$zip->addFile("$PAGE.$_") if -f "$PAGE.$_";
		}
		$zip->addTree($PAGE, $PAGE) if -d $PAGE;
	}
	print <<EOT;
Content-Type: application/zip
Content-Disposition: attachment; filename="$file"

EOT
	$zip->writeToFileHandle(*STDOUT);
	die;
}elsif($QUERY_STRING eq "restore"){
#-------------------------------------------------------------------------------
# u?restore		Restore
# u/PAGE?restore	Restore
	die_message("admin_actions_not_allowed") unless $admin;
	eval "use Archive::Zip;1" or
		die_message("perl_module_not_installed", "Archive::Zip");

	my $boundary = <STDIN>;
	my $file = <STDIN>; my $tmp = $file.<STDIN>.<STDIN>;
	$file =~ s#^.*?filename="(.*?)".*$#$1#s; $file =~ s#^.*[/\\]##;
	my $length = $CONTENT_LENGTH - length($tmp) - 2 *
		length($boundary) - 4;
	read STDIN, my $content, $length;
	my ($fh, $name) = Archive::Zip::tempFile(".");
	print $fh $content;
	my $zip = Archive::Zip->new();
	$zip->readFromFileHandle($fh);
	(my $cgi = $CGI) =~ s#^(?:/~[^/]+)?/##;
	$zip->removeMember($cgi);
	$zip->removeMember($PASSWORD_FILE);
	foreach($zip->memberNames()){
		$zip->removeMember($_) if -f $_ && !-w $_;
		if($hosting eq "awardspace" && (m#\.html$# || m#/#)){
			my $member = $zip->memberNamed($_);
			$member->unixFileAttributes(0755);
		}
	}
	$zip->extractTree();
	close $fh;
	unlink $name;

	if($hosting eq "awardspace"){
		foreach($zip->memberNames()){
			chmod 0755, $_ if m#\.html$# || m#/#;
		}
	}

	die_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE?manage_pages");
}elsif($QUERY_STRING =~ /^refresh(?:&.+)?$/){
#-------------------------------------------------------------------------------
# u?refresh		Refresh all pages
# u?refresh&glob=GLOB	Refresh GLOB pages
	die_message("admin_actions_not_allowed") unless $admin;

	my %var = get_var();
	my $glob = $var{glob};
	my $title = $glob eq "" ? get_msg("refresh_pages") :
		get_msg("refresh_pages_matching", $glob);

	local $TITLE = $title;
	print_header();
	print qq(<div id="list">\n<h1>$title</h1>\n<ul>\n);
	foreach($glob eq "" ? (<.*.txt>, <*.txt>) : <$glob.txt>){
		next if index($_, "/") >= 0 || !-f $_;
		s/\.txt$//;
		if($PAGES_NOT_ALLOWED ne "" && /$PAGES_NOT_ALLOWED/o){
			next;
		}
		$PAGE = $_;
		make_html($PAGE);
		print qq(<li><a href="$PAGE.html">$PAGE</a></li>\n);
	}
	print qq(</ul>\n</div>\n);
	print_footer();
	die;
}elsif($QUERY_STRING eq "list_users"){
#-------------------------------------------------------------------------------
# u?list_users		List users
# u/PAGE?list_users	List users
	die_message("admin_actions_not_allowed") unless $admin;
	print_header();
	print_list_users();
	print_footer();
	die;
}elsif($QUERY_STRING eq "manage_users"){
#-------------------------------------------------------------------------------
# u?manage_users	Manage users
# u/PAGE?manage_users	Manage users
	die_message("admin_actions_not_allowed") unless $admin;
	print_manage_users();
	die;
}elsif($QUERY_STRING eq "add_user" && $REQUEST_METHOD eq "POST"){
#-------------------------------------------------------------------------------
# u?add_user		Add user
# u/PAGE?add_user	Add user
	die_message("admin_actions_not_allowed") unless $admin;
	my %var = get_var();
	die_message("enter_username") if $var{user} eq "";
	die_message("check_username") unless is_username($var{user});
	die_message("cannot_add_yourself") if $var{user} eq $USER;
	die_message("enter_email_address") if $var{email} eq "";
	die_message("check_email_address") unless is_email_address($var{email});
	die_message("enter_full_name") if $var{name} eq "";
	die_message("check_full_name") unless is_full_name($var{name});
	die_message("confirm_password") if $var{pw} ne $var{pw2};
	die_message("check_password")
		if $var{pw} ne "" && !is_password($var{pw});

	(my $escaped_email = $var{email}) =~ s/\./\\./g;
	my $new_pw = "";

	lock_file($PASSWORD_FILE);
	if(-f $PASSWORD_FILE){
		local *FH;
		open FH, $PASSWORD_FILE;
		while(<FH>){
			if(/^$var{user}:/){
				close FH;
				die_message("user_already_exists", $var{user});
			}
			if(/:$escaped_email(?::[^:]*){2}$/i){
				close FH;
				die_message("email_address_already_registered",
					$var{email});
			}
			$new_pw .= $_;
		}
		close FH;
	}elsif($adminpw =~ /:$escaped_email(?::[^:]*){2}$/i){
		die_message("email_address_already_registered", $var{email});
	}else{
		$new_pw = "$adminpw\n";
	}

	# Add a new user if user was not found
	my $group = $var{admin} eq "yes" ? "admin" : "user";
	my $pw;
	my $token;
	if($var{pw} eq ""){
		$pw = "reset";
		$token = generate_password_set_token($var{user});

		my $link = "$HTTP_BASE$SCRIPT_NAME?reset_password=$token";
		my $subject = get_msg("new_user_email_subject", $DOC_BASE);
		my $text = get_msg("new_user_email_text", $var{user}, $DOC_BASE,
			$link, $SET_PASSWORD_TIMEOUT);
		die_message("email_notification_failed", $var{user},
			$var{email})
			unless send_email($var{email}, $subject, $text);
	}else{
		$pw = hash_password($var{user}, $var{pw});
		$token = "";
	}
	$new_pw .= "$var{user}:$pw:$group:$var{email}:$var{name}:$token\n";

	write_file($PASSWORD_FILE, $new_pw);
	unlock_file($PASSWORD_FILE);

	die_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE?manage_users");
}elsif($QUERY_STRING eq "update_user" && $REQUEST_METHOD eq "POST"){
#-------------------------------------------------------------------------------
# u?update_user		Update user
# u/PAGE?update_user	Update user
	die_message("admin_actions_not_allowed") unless $admin;

	my %var = get_var();
	die_message("enter_username") if $var{user} eq "";
	die_message("check_username") unless is_username($var{user});
	die_message("check_full_name")
		if $var{name} ne "" && !is_full_name($var{name});
	die_message("confirm_password") if $var{pw} ne $var{pw2};
	die_message("check_password")
		if $var{pw} ne "" && !is_password($var{pw});
	die_message("enter_user_info_to_update")
		if $var{pw} eq "" && $var{email} eq "" &&
		   $var{admin} ne "yes" && $var{admin} ne "no";

	my $new_pw = "";
	my $updated = 0;

	lock_file($PASSWORD_FILE);
	if(-f $PASSWORD_FILE){
		local *FH;
		open FH, $PASSWORD_FILE;
		while(<FH>){
			if(/^$var{user}:/){
				$updated = 1;
				my @items = split /:/;
				my $pw = $var{pw} ne "" ?
					hash_password($var{user}, $var{pw}) :
					$items[1];
				my $group = $var{admin} eq "yes" ? "admin" :
					($var{admin} eq "no" ? "user" :
						$items[2]);
				my $email = $var{email} ne "" ?
					$var{email} : $items[3];
				my $name = $var{name} ne "" ?
					$var{name} : $items[4];
				my $token = $items[5];
				# new line from $items[5]
				my $userline = "$var{user}:$pw:$group:$email:$name:$token";
				if($userline eq $_){
					close FH;
					die_message("enter_user_info_to_update",
						$var{user});
				}
				$_ = $userline;
			}
			$new_pw .= $_;
		}
		close FH;
	}else{
		my @items = split /:/, $adminpw;
		# Something's wrong because you're the only user, but the user
		# line in this script is not you! How did you login?
		die_message("internal_errors") if $var{user} ne $items[0];

		$updated = 1;
		my $pw = $var{pw} ne "" ? hash_password($var{user}, $var{pw}) :
			$items[1];
		my $group = $var{admin} eq "yes" ? "admin" :
			($var{admin} eq "no" ? "user" : $items[2]);
		my $email = $var{email} ne "" ? $var{email} : $items[3];
		my $name = $var{name} ne "" ? $var{name} : $items[4];
		my $token = $items[5];
		# new line from $items[5]
		my $userline = "$var{user}:$pw:$group:$email:$name:$token";
		die_message("enter_user_info_to_update", $var{user})
			if $userline eq $adminpw;
		$new_pw = "$userline\n";
	}
	die_message("user_not_found", $var{user}) unless $updated;

	write_file($PASSWORD_FILE, $new_pw);
	unlock_file($PASSWORD_FILE);

	die_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE?manage_users");
}elsif($QUERY_STRING eq "block_user" && $REQUEST_METHOD eq "POST"){
#-------------------------------------------------------------------------------
# u?block_user		Block user
# u/PAGE?block_user	Block user
	die_message("admin_actions_not_allowed") unless $admin;

	my %var = get_var();
	die_message("enter_username") if $var{user} eq "";
	die_message("check_username") unless is_username($var{user});
	die_message("cannot_block_yourself") if $var{user} eq $USER;

	my $new_pw = "";
	my $blocked = 0;

	lock_file($PASSWORD_FILE);
	if(-f $PASSWORD_FILE){
		local *FH;
		open FH, $PASSWORD_FILE;
		while(<FH>){
			if(/^$var{user}:/){
				my @items = split /:/;
				if($items[1] eq "blocked"){
					close FH;
					die_message("user_already_blocked",
						$var{user});
				}
				$blocked = 1;
				clear_user_sessions($var{user});
				$_ = "$var{user}:blocked:$items[2]:$items[3]:$items[4]:\n";
			}
			$new_pw .= $_;
		}
		close FH;
	}
	die_message("user_not_found", $var{user}) unless $blocked;

	write_file($PASSWORD_FILE, $new_pw);
	unlock_file($PASSWORD_FILE);

	die_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE?manage_users");
}elsif($QUERY_STRING eq "unblock_user" && $REQUEST_METHOD eq "POST"){
#-------------------------------------------------------------------------------
# u?unblock_user	Unblock user
# u/PAGE?unblock_user	Unblock user
	die_message("admin_actions_not_allowed") unless $admin;

	my %var = get_var();
	die_message("enter_username") if $var{user} eq "";
	die_message("check_username") unless is_username($var{user});
	die_message("cannot_unblock_yourself") if $var{user} eq $USER;

	die_message("confirm_password") if $var{pw} ne $var{pw2};
	die_message("check_password")
		if $var{pw} ne "" && !is_password($var{pw});

	my $new_pw = "";
	my $unblocked = 0;
	my $token = "";

	lock_file($PASSWORD_FILE);
	if(-f $PASSWORD_FILE){
		local *FH;
		open FH, $PASSWORD_FILE;
		while(<FH>){
			if(/^$var{user}:/){
				my @items = split /:/;
				if($items[1] ne "blocked"){
					close FH;
					die_message("user_already_unblocked",
						$var{user});
				}
				$unblocked = 1;
				my $pw;
				if($var{pw} eq ""){
					$pw = "reset";
					$token = generate_password_set_token($var{user});
				}else{
					$pw = hash_password($var{user},
						$var{pw});
					$token = "";
				}
				$_ = "$var{user}:$pw:$items[2]:$items[3]:$items[4]:$token\n";
			}
			$new_pw .= $_;
		}
		close FH;
	}
	die_message("user_not_found", $var{user}) unless $unblocked;

	if($token ne ""){
		my $link = "$HTTP_BASE$SCRIPT_NAME?reset_password=$token";
		my $subject = get_msg("unblocked_user_email_subject",
			$DOC_BASE);
		my $text = get_msg("unblocked_user_email_text", $var{user},
			$DOC_BASE, $link, $SET_PASSWORD_TIMEOUT);
		die_message("email_notification_failed", $var{user},
			$var{email})
			unless send_email($var{email}, $subject, $text);
	}

	write_file($PASSWORD_FILE, $new_pw);
	unlock_file($PASSWORD_FILE);

	die_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE?manage_users");
}elsif($QUERY_STRING eq "delete_user" && $REQUEST_METHOD eq "POST"){
#-------------------------------------------------------------------------------
# u?delete_user		Delete user
# u/PAGE?delete_user	Delete user
	die_message("admin_actions_not_allowed") unless $admin;

	my %var = get_var();
	die_message("enter_username") if $var{user} eq "";
	die_message("check_username") unless is_username($var{user});
	die_message("cannot_delete_yourself") if $var{user} eq $USER;

	my $new_pw = "";
	my $deleted = 0;

	lock_file($PASSWORD_FILE);
	if(-f $PASSWORD_FILE){
		local *FH;
		open FH, $PASSWORD_FILE;
		while(<FH>){
			if(/^$var{user}:/){
				$deleted = 1;
				clear_user_sessions($var{user});
				next;
			}
			$new_pw .= $_;
		}
		close FH;
	}
	die_message("user_not_found", $var{user}) unless $deleted;

	write_file($PASSWORD_FILE, $new_pw);
	unlock_file($PASSWORD_FILE);

	die_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE?manage_users");
}elsif($QUERY_STRING eq "install_password"){
#-------------------------------------------------------------------------------
# u?install_password		Install the password file, but don't overwrite
# u/PAGE?install_password	Install the password file, but don't overwrite
	die_message("admin_actions_not_allowed") unless $admin;
	write_pw();
	die_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE");
}elsif($QUERY_STRING eq "install_config"){
#-------------------------------------------------------------------------------
# u?install_config	Install the config file, but don't overwrite
# u/PAGE?install_config	Install the config file, but don't overwrite
	die_message("admin_actions_not_allowed") unless $admin;
	process_cfg(1);
	die_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE");
}elsif($QUERY_STRING eq "install_messages"){
#-------------------------------------------------------------------------------
# u?install_messages		Install the messages file, but don't overwrite
# u/PAGE?install_messages	Install the messages file, but don't overwrite
	die_message("admin_actions_not_allowed") unless $admin;
	process_msg(1);
	die_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE");
}elsif($QUERY_STRING eq "install_template"){
#-------------------------------------------------------------------------------
# u?install_template		Install the template files, but don't overwrite
# u/PAGE?install_template	Install the template files, but don't overwrite
	die_message("admin_actions_not_allowed") unless $admin;

	if($TEMPLATE_DIRECTORY ne ""){
		mkdir $TEMPLATE_DIRECTORY, 0755 unless -d $TEMPLATE_DIRECTORY;
		print_header(1);
		print_footer(1);
		print_login(1);
		print_manage_pages(1);
		print_manage_users(1);
		print_manage_myself(1);
		print_forgot_password(1);
		print_reset_password(1);
		print_message(1);
		print_view(1);
		print_edit(1);
		print_preview(1);
		print_updated(1);
		print_wiki_view(1);
		print_wiki_edit(1);
		print_wiki_preview(1);
		print_css(1);
		print_js(1);
	}
	die_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE");
}elsif($PAGE eq ""){
#-------------------------------------------------------------------------------
# u?ACTION		Redirect to index
	die_message("admin_actions_not_allowed") unless $admin;
	die_redirect("$HTTP_BASE$SCRIPT_NAME/$INDEX_PAGE");
}elsif($QUERY_STRING eq "upload"){
#-------------------------------------------------------------------------------
# u/PAGE?upload		Upload PAGE/FILE
	die_message("admin_actions_not_allowed") unless $admin;

	my %var = get_var();
	die_rebuild($PAGE) unless verify_input("upload", \%var);

	if($var{file} ne ""){
		mkdir $PAGE, 0755 if !-d $PAGE;
		write_file("$PAGE/$var{file}", $var{"file="}, 1);
		chmod 0755, "$PAGE/$var{file}" if $hosting eq "awardspace";
		$rebuild = 1;
	}
}elsif($QUERY_STRING eq "delete" && $FILE ne ""){
#-------------------------------------------------------------------------------
# u/PAGE/FILE?delete	Delete PAGE/FILE
	die_message("admin_actions_not_allowed") unless $admin;

	my $dir = "";
	if(unlink "$PAGE/$FILE"){
		$dir = "$PAGE/$FILE"; $dir =~ s#/[^/]+$##;
	}elsif(-d "$PAGE/$FILE"){
		$dir = "$PAGE/$FILE";
	}
	if($dir ne ""){
		while(index($dir, "/") >= 0){
			rmdir $dir;
			$dir =~ s#/[^/]*$##;
		}
		rmdir $dir;
	}
	$rebuild = 1;
}elsif($QUERY_STRING =~ /^edit(?:=(-?[0-9]+))?$/){
#-------------------------------------------------------------------------------
# u/PAGE?edit		Create/edit PAGE
# u/PAGE?edit=([0-9]+)	Edit the version \1 of PAGE
# u/PAGE?edit=-([0-9]+)	Edit the current-\1 version of PAGE
	die_message("admin_actions_not_allowed") unless $admin;

	local $TITLE = $PAGE;
	local ($VERSION, $TEXT);
	if($REQUEST_METHOD eq "GET"){
		$VERSION = get_version($PAGE);
		my $version = $1 > 0 ? $1 : $VERSION + $1;
		$TEXT = read_file("$PAGE.txt");
		if($TEXT ne ""){
			if($version > 0 && $version < $VERSION){
				local *FH;
				open FH, "$PAGE.txt.v"; local $/ = "\x00\n";
				while(<FH>){
					/^([0-9]+):.*?\n(.*)\x00\n$/s;
					$TEXT = patch($TEXT, $2);
					last if $version == $1 - 1;
				}
				close FH;
			}
			$TEXT =~ s/&/&amp;/g;
			$TEXT =~ s/</&lt;/g;
			$TEXT =~ s/>/&gt;/g;
		}
		chomp $TEXT;
		$VERSION++;
		preprocess_text();
		print_edit();
		die;
	}

	my %var = get_var();
	die_rebuild($PAGE) unless verify_input("edit", \%var);

	$VERSION = $var{version};
	$TEXT = $var{text};
	if($VERSION != get_version($PAGE) + 1){
		print_updated();
		die;
	}
	my $file_links;
	foreach my $key (keys %var){
		next unless $key =~ /^file[0-9]*$/ && $var{$key} ne "";
		mkdir $PAGE, 0755 if !-d $PAGE;
		write_file("$PAGE/$var{$key}", $var{"$key="}, 1);
		chmod 0755, "$PAGE/$var{$key}" if $hosting eq "awardspace";
		$file_links .= "{{$var{$key}}}\n" if -f "$PAGE/$var{$key}";
	}
	chomp $file_links;
	if($var{preview} ne ""){
		my $uploaded;
		$uploaded = get_msg("files_uploaded", $file_links)
			if $file_links;

		preview($PAGE, $TEXT, $uploaded, 0);
		die;
	}
	lock_file("$PAGE.txt");
	save($PAGE, "$TEXT\n");
	unlock_file("$PAGE.txt");
}elsif($QUERY_STRING =~ /^edit_lines(?:=([0-9]+)(?:,([0-9]+))?)?$/){
#-------------------------------------------------------------------------------
# u/PAGE?edit_lines			Save new PAGE lines
# u/PAGE?edit_lines=([0-9]+),([0-9]+)	Edit PAGE \2 lines from \1
# u/PAGE?edit_lines=([0-9]+)		Edit PAGE lines from \1 to end
	die_message("admin_actions_not_allowed") unless $admin;
	die_message("page_not_found", $PAGE) unless page_exists();

	local $TITLE = $PAGE;
	local ($VERSION, $START, $COUNT, $TEXT);
	if($REQUEST_METHOD eq "GET"){
		die_message("internal_errors") unless $1 ne "";

		$VERSION = get_version($PAGE) + 1;
		$START = $1;
		$COUNT = $2;
		$TEXT = read_lines("$PAGE.txt", $START, $COUNT);
		if($TEXT ne ""){
			$TEXT =~ s/&/&amp;/g;
			$TEXT =~ s/</&lt;/g;
			$TEXT =~ s/>/&gt;/g;
		}
		chomp $TEXT;
		preprocess_text();
		print_edit_lines();
		die;
	}

	my %var = get_var();
	die_rebuild($PAGE) unless verify_input("edit", \%var);

	$VERSION = $var{version};
	$START = $var{start};
	$COUNT = $var{count};
	$TEXT = $var{text};
	if($VERSION != get_version($PAGE) + 1){
		print_updated();
		die;
	}
	my $file_links;
	foreach my $key (keys %var){
		next unless $key =~ /^file[0-9]*$/ && $var{$key} ne "";
		mkdir $PAGE, 0755 if !-d $PAGE;
		write_file("$PAGE/$var{$key}", $var{"$key="}, 1);
		chmod 0755, "$PAGE/$var{$key}" if $hosting eq "awardspace";
		$file_links .= "{{$var{$key}}}\n" if -f "$PAGE/$var{$key}";
	}
	chomp $file_links;
	if($var{preview} ne ""){
		my $uploaded;
		$uploaded = get_msg("files_uploaded", $file_links)
			if $file_links;

		preview_lines($PAGE, $START, $COUNT, $TEXT, $uploaded, 0);
		die;
	}
	lock_file("$PAGE.txt");
	save_lines($PAGE, $START, $COUNT, "$TEXT\n");
	unlock_file("$PAGE.txt");
}elsif($QUERY_STRING =~ /^revert(?:=(-?[0-9]+))?$/){
#-------------------------------------------------------------------------------
# u/PAGE?revert			Go back to the previous version of PAGE
# u/PAGE?revert=([0-9]+)	Go back to the \1 version of PAGE
# u/PAGE?revert=-([0-9]+)	Go back to the current-\1 version of PAGE
	die_message("admin_actions_not_allowed") unless $admin;
	die_message("page_not_found", $PAGE) unless page_exists();

	lock_file("$PAGE.txt");
	my $current_version = get_version($PAGE);
	my $version = $1 > 0 ? $1 : $current_version + ($1 < 0 ? $1 : -1);
	if($version > 0 && $version < $current_version){
		local *FH;
		my $text = read_file("$PAGE.txt");
		open FH, "$PAGE.txt.v"; local $/ = "\x00\n";
		while(<FH>){
			/^([0-9]+):.*?\n(.*)\x00\n$/s;
			$text = patch($text, $2);
			if($version == $1 - 1){
				$rebuild = 1;
				last;
			}
		}
		if($rebuild){
			local $/ = "\n";
			my $line = <FH>;
			my @items = split /:/, $line;
			my $time = $items[1];

			local $/ = undef;
			my $txtv = $line.<FH>;
			close FH;

			write_file("$PAGE.txt.v", $txtv);
			write_file("$PAGE.txt", $text);
			utime $time, $time, "$PAGE.txt";
		}else{
			close FH;
		}
	}
	unlock_file("$PAGE.txt");
}elsif($QUERY_STRING =~ /^rename(?:[&=].+)?$/){
#-------------------------------------------------------------------------------
# u?rename		Create the rename form
# u?rename=PAGE		Rename to PAGE
	die_message("admin_actions_not_allowed") unless $admin;

	my %var = get_var();
	if($var{rename} eq ""){
		local $TITLE = get_msg("rename_form");
		print_header();
		create_rename_form(1);
		print_footer();
		die;
	}

	$_ = $var{rename};
	s#\.html$##;
	y#[/+]# #;

	my $page = convert_page_name($_);

	die_message("page_not_found", $PAGE) unless page_exists();
	die_message("page_already_exists", $page) if page_exists($page);

	if(-f "$PAGE.html"){
		local *OLD, *NEW;
		open OLD, "$PAGE.html";
		open FH, ">$page.html";
		while(<OLD>){
			s!(["/=>])$PAGE(\.html[#?"]|["/%<?])!\1$page\2!g;
			print FH;
		}
		close FH;
		close OLD;
		unlink "$PAGE.html";
	}
	foreach("txt", "txt.v"){
		rename "$PAGE.$_", "$page.$_" if -f "$PAGE.$_";
	}
	rename $PAGE, $page if -d $PAGE;

	die_redirect("$HTTP_BASE$SCRIPT_NAME/".encode_url_safe($page));
}elsif($QUERY_STRING eq "delete"){
#-------------------------------------------------------------------------------
# u/PAGE?delete		Delete PAGE
	die_message("admin_actions_not_allowed") unless $admin;

	unlink "$PAGE.txt", "$PAGE.txt.v", "$PAGE.html";
	rmrf($PAGE);
	$PAGE = $INDEX_PAGE;
}else{
#-------------------------------------------------------------------------------
# Unhandled query string; $QUERY_STRING eq "" is handled earlier
	$strip_query_string = 0;
}

#-------------------------------------------------------------------------------
# Rebuild, if requested, and redirect
make_html($PAGE) if $rebuild;

if($nonwiki_read_access ne "open" || $wiki_read_access ne "open"){
	die_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE") if $strip_query_string;
	die_message("page_not_found", $PAGE) unless -f "$PAGE.html";

	local *FH;
	start_html();
	open FH, "$PAGE.html";
	print <FH>;
	close FH;
	die;
}

die_redirect("$DOC_BASE/$PAGE.html".
	($strip_query_string ? "" : "?$QUERY_STRING"));
