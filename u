#!/usr/bin/env perl
################################################################################
# Uniqki:	Unique Wiki <http://uniqki.isnew.info>
# Author:	Huidae Cho
# Since:	May 23, 2007
#
# Copyright (C) 2007-2008, 2010-2011, 2016-2017, Huidae Cho
# <http://geni.isnew.info>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
################################################################################
use strict;

# The document root directory relative to the server's URL including /~user, if
# any.  For example, if the full URL path to index.html is
# http://example.com/~user/index.html, $doc_root should be set to ".".  Leave
# it blank if you can run this script outside of the cgi-bin directory.
my $doc_root = "";

# Temporary admin user: admin, password: admin.  DO NOT CHANGE THIS VARIABLE.
my $tmp_adminpw = 'admin:7352327a53727a65613d7a4cb055d722c21f1a0f17ad676daccd4ad8bf728134c9ee739e5f51c9af822da15b69985908148c55b6fdea4bc0bcd5aff660a53db428a9898c12743c7d:admin:@:Administrator:';
# Running this script for the first time will create the password file u.pw
# using the $adminpw credential, which is set to $temporary_adminpw by default.
# Since this password is public, make sure to change the admin password after
# the first login to update the password file.  If $adminpw in the following
# line is not the same as $temporary_adminpw, Uniqki will assume that you have
# changed $adminpw to remove the password file and use this script instead for
# login, and will not create the password file again.  Using this feature, it
# is possible to operate a Uniqki site with this file alone by removing the
# password file after setting the $adminpw variable to your new credential in
# u.pw.  Make sure to back up this variable when updating the script.
# Optionally, you can create u.cfg and template files in u.tpl by running
# u?install_config and u?install_template, respectively, but these files are
# only used for customizations and are not required.
my $adminpw = $tmp_adminpw;

################################################################################
# HTTP server environment variables
use vars qw(
	$CFG
	$HTTPS $HTTP_COOKIE $HTTP_HOST $SERVER_NAME $SCRIPT_NAME $PATH_INFO
	$QUERY_STRING $REQUEST_METHOD $CONTENT_TYPE $CONTENT_LENGTH
);

# Useful variables
use vars qw(
	$HTTP_BASE $DOC_BASE $CGI $PAGE $FILE $USER $NAME $AUTHOR
);

# Template variables
use vars qw(
	$TITLE $TEXT $PREVIEW $VERSION $TIME $PASSWORD_RESET_TOKEN $MESSAGE
	$PARSING_TIME
);

# Config and messages variables
use vars qw(
	$SITE_TITLE $SITE_DESCRIPTION $INDEX_PAGE $LANG $CHARSET $LOCALE
	$TIME_ZONE $TIME_FORMAT
	$SHARE_COOKIES
	$PASSWORD_FILE $SESSIONS_FILE $MESSAGES_FILE $TEMPLATE_DIRECTORY
	$PAGE_NAME_STYLE
	$SECTION_NUMBER_PREFIX $SECTION_NUMBER_SEPARATOR $SECTION_NUMBER_SUFFIX
	$SECTION_REFERENCE_PREFIX $SECTION_REFERENCE_SUFFIX
	$TABLE_NUMBER_PREFIX $TABLE_NUMBER_SUFFIX
	$TABLE_REFERENCE_PREFIX $TABLE_REFERENCE_SUFFIX
	$FIGURE_NUMBER_PREFIX $FIGURE_NUMBER_SUFFIX
	$FIGURE_REFERENCE_PREFIX $FIGURE_REFERENCE_SUFFIX
	$INACTIVE_TIMEOUT $SET_PASSWORD_TIMEOUT $RESET_PASSWORD_TIMEOUT
	$EMAIL_ADDRESS $SMTP $MIME_TYPE_COMMAND
	$READ_ACCESS $WRITE_ACCESS
	$PAGES_NOT_ALLOWED
	$USER_PARSERS_FILE
	$HEADER_FILE $FOOTER_FILE
	$NONWIKI_HEADER_FILE $NONWIKI_FOOTER_FILE
	$WIKI_HEADER_FILE $WIKI_FOOTER_FILE
	$WIKI_PAGES_ALLOWED $WIKI_FILES_ALLOWED

	%MESSAGES
);

# parse_file() global variables
use vars qw(
	@begin_parsing
	@parse_line
	@end_parsing
	@process_child_block
	@preprocess_line
	@process_syntax_block
	@process_asis_lines
	@skip_comment
	@process_wiki_command
	@process_nonwiki_command
	@skip_unknown_command
	@start_syntax_block
	@process_collected_lines
	@process_paragraph_break
	@escape_inline_syntax
	@process_inline_syntax
	@collect_lines
	@process_line_syntax
	@start_paragraph
	@postprocess_line
	@close_all_open
);

# parse_file() local variables
use vars qw(
	$text $url_char $url_punct $child_block $code_block $syntax_block
	@parsed_blocks $re_start $re_n @re @re_sub $p $asis $nosyntax $pre
	$pre_code $blockquote $list $table $figure %h_n $h_top $h_prev %h_secs
	%secs_no $toc $notoc $tab_no %tabs_n %tabs $lot $nolot $fig_no %figs_n
	%figs $lof $nolof
);

# Other global variables
use vars qw(
	$verify_input
	$wiki
	$html_started
	$header_printed $footer_printed
);

umask 022;

my $win = $^O eq "MSWin32" ? 1 : 0;
eval "use Time::HiRes";
my $show_parsing_time = $@ ? 0 : 1;

if(!defined $ENV{GATEWAY_INTERFACE}){
	my $cmd = "";
	my %opt;
	for(my $i = 0; $i <= $#ARGV; $i++){
		if("-" eq substr $ARGV[$i], 0, 1){
			my $name = substr $ARGV[$i], 1;
			if($name eq "p" || $name eq "c" || $name eq "k" ||
				$name eq "i" || $name eq "f"){
				die "$ARGV[$i] option requires a value"
					if($i + 1 > $#ARGV);
				$opt{$name} = $ARGV[++$i];
			}else{
				$opt{$name} = 1;
			}
		}elsif($cmd eq ""){
			$cmd = $ARGV[$i];
		}else{
			die "Provide only one command";
		}
	}
	if($opt{p} ne "" && $opt{p} !~ m/^[0-9]+$/){
		die "Port must be a number";
	}
	if($opt{p} eq ""){
		$opt{p} = $opt{c} eq "" ? 80 : 443;
	}
	if($opt{c} ne "" && !-f $opt{c}){
		die "$opt{c}: File not found";
	}
	if($opt{k} ne "" && !-f $opt{k}){
		die "$opt{k}: File not found";
	}
	if(($opt{c} eq "" && $opt{k} ne "") ||
	   ($opt{c} ne "" && $opt{k} eq "")){
		die "Both cert and key files must be specified";
	}
	if($opt{i} eq ""){
		$opt{i} = "index.html";
	}
	if($opt{f} eq ""){
		$opt{f} = '(?:^u\.(?:cfg|pw|msg|pid|log)|^\.sessions|\.(?:tpl|txt|txt\.v))$';
	}
	if($opt{r} && $opt{s}){
		die "-r and -s are mutually exclusive";
	}
	my $u = $0;
	if($u =~ m#^(.*)[\\/](.+)#){
		chdir $1;
		$u = $2;
	}
	my $pid_file = "u.pid";
	my $log_file = "u.log";
	my $foreground = 0;

	sub logger{
		my @msg = @_;

		local *FH;
		open FH, ">>$log_file";
		printf FH @msg;
		close FH;

		printf @msg if($foreground);
	}

	sub die_logger{
		logger @_;
		die;
	}

	sub get_pid{
		return 0 unless(-f $pid_file);

		local *FH;
		open FH, $pid_file;
		my $pid = <FH>;
		close FH;
		chomp $pid;

		my $alive = kill 0, $pid;
		unlink $pid_file unless($alive);

		return $alive ? $pid : 0;
	}

	sub stop_server{
		my $pid = get_pid();
		if($pid > 0){
			kill 9, $pid;
			logger "Stopped by the user.\n";
		}
		unlink $pid_file;
	}

	sub respond_error{
		my ($client, $code_msg) = @_;
		(my $msg = $code_msg) =~ s/^[0-9]+ //;

		logger "$code_msg\n\n";
		select $client;
		print "HTTP/1.1 $code_msg\n";
		print "Content-Type: text/plain\n\n";
		print "$msg\n";
	}

	sub respond_location{
		my ($client, $url) = @_;
		logger "Redirecting to $url...\n\n";
		select $client;
		print "HTTP/1.1 302 Found\n";
		print "Location: $url\n\n";
	}

	sub respond_file{
		my ($client, $file) = @_;
		logger "Sending $file...\n\n";
		my $mime_type = get_mime_type($file);
		select $client;
		print "HTTP/1.1 200 OK\n";
		print "Content-Type: $mime_type\n\n";

		local *FH;
		open FH, $file;
		binmode FH;
		print <FH>;
		close FH;
	}

	if($cmd eq "start" || $cmd eq "restart"){
################################################################################
# Tiny HTTP server to self-serve Uniqki
		my $pid;
		unless($win){
			$pid = get_pid();
			if($pid > 0){
				if($cmd eq "start"){
					die "Process $pid is still running";
				}else{
					stop_server();
				}
			}
		}

		$ENV{GATEWAY_INTERFACE} = "CGI/1.1";
		eval "use IO::Socket::INET;";
		die "The IO::Socket::INET module is required to self-serve Uniqki" if($@);

		my $server = IO::Socket::INET->new(
			Proto=>"tcp",
			LocalPort=>$opt{p},
			Listen=>SOMAXCONN(),
			Reuse=>1) || die "Cannot create a socket";

		if($opt{c} ne ""){
			$ENV{HTTPS} = "on";
			eval "use IO::Socket::SSL;";
			die "The IO::Socket::SSL module is required to self-serve Uniqki" if($@);
		}else{
			$ENV{HTTPS} = "off";
		}

		if($win){
			print "Close this window to terminate the service.\n";
			$foreground = 1;
		}else{
			$pid = fork();
			# $pid > 0 on Unix: Background process
			# $pid < 0 on Windows: Multi-threaded
			if(defined $pid && $pid > 0){
				# Parent of successful fork on Unix
				local *FH;
				print "Running in the background. Kill process $pid later to terminate the service.\n";
				print "The process ID $pid is stored in $pid_file.\n";
				print "Log messages are being written to $log_file.\n";

				open FH, ">$pid_file";
				print FH "$pid\n";
				close FH;
				exit;
			}elsif(!defined $pid){
				# Unsuccessful fork
				print "Cannot fork the server. Running in the foreground.\n";
				$foreground = 1;
			} # else child of successful fork on Unix
		}
		while(my $client = $server->accept()){
			$pid = fork();
			die_logger "Cannot fork the client.\n"
				unless defined $pid;
			if($pid){
				# Parent closes the client and listens again.
				close $client;
				next;
			}
			if($opt{c} ne ""){
				IO::Socket::SSL->start_SSL($client,
					SSL_server=>1,
					SSL_cert_file=>$opt{c},
					SSL_key_file=>$opt{k}) ||
				die_logger "Failed to SSL handshake.\n";
			}
			$client->autoflush(1);
			logger "========== %s ==========\n", scalar localtime;
			logger "Request from %s\n", $client->peerhost();

			while(<$client>){
				logger $_;
				s/\r\n//;
				if(m#^([A-Z]+) (.*?)(?:\?(.*))? HTTP\/[0-9.]+$#){
					$ENV{REQUEST_METHOD} = $1;
					$ENV{REQUEST_URI} = $2;
					$ENV{QUERY_STRING} = $3;
				}elsif(m/^([^:]+): (.*)$/){
					my $field = uc $1;
					if($field eq "HOST"){
						$ENV{HTTP_HOST} = $2;
						($ENV{SERVER_NAME} = $2) =~ s/:[0-9]+$//;
					}elsif($field eq "CONTENT-TYPE"){
						$ENV{CONTENT_TYPE} = $2;
					}elsif($field eq "CONTENT-LENGTH"){
						$ENV{CONTENT_LENGTH} = $2;
					}elsif($field eq "COOKIE"){
						$ENV{HTTP_COOKIE} = $2;
					}
				}elsif($_ eq ""){
					last;
				}
			}

			logger "Processing $ENV{REQUEST_URI}...\n";

			$ENV{REQUEST_URI} =~ s#^/+#/#;
			(my $request_uri = $ENV{REQUEST_URI}) =~ s#^/##;
			my $request_file = $request_uri eq "" ? $opt{i} :
				decode_url($request_uri);
			if(($ENV{REQUEST_METHOD} ne "GET" &&
				$ENV{REQUEST_METHOD} ne "POST") ||
				"/" ne substr($ENV{REQUEST_URI}, 0, 1) ||
				($ENV{REQUEST_METHOD} eq "POST" &&
					$request_uri !~ m#^$u(?:/.*)?$#)){
				respond_error($client, "400 Bad Request");
			}elsif(($win &&
			   (($opt{c} ne "" && lc $request_file eq lc $opt{c}) ||
			    ($opt{k} ne "" && lc $request_file eq lc $opt{k}) ||
			    $request_file =~ m/$opt{f}/i)) ||
	    			(!$win &&
				 (($opt{c} ne "" && $request_file eq $opt{c}) ||
				  ($opt{k} ne "" && $request_file eq $opt{k}) ||
				  $request_file =~ m/$opt{f}/))){
				respond_error($client, "403 Forbidden");
			}elsif($request_uri =~ m#^$u(/.*)?$#){
				logger "Executing $u...\n\n";

				$ENV{SCRIPT_NAME} = "/$u";
				$ENV{PATH_INFO} = decode_url($1);

				*STDIN = $client
					if($ENV{REQUEST_METHOD} eq "POST");
				local *OUTPUT;
				my $output;
				open OUTPUT, ">", \$output;
				select OUTPUT;
				do $u;
				close OUTPUT;

				select $client;
				my @items = split /\n\n/, $output;
				if($items[0] =~ m/^Location: /m){
					print "HTTP/1.1 302 Found\n";
				}else{
					print "HTTP/1.1 200 OK\n";
				}
				print $output;
			}elsif($opt{r} && ".html" eq substr($request_file, -5)
				&& !-f $request_file){
				my $url = "/$u/".substr($request_uri, 0,
					length($request_uri) - 5);
				respond_location($client, $url);
			}elsif($opt{r} && ".html" ne substr($request_file, -5)
				&& -f "$request_file.html"){
				my $url = "/$request_uri.html";
				respond_location($client, $url);
			}elsif($opt{s}){
				(my $page = $request_uri) =~ s/\.html$//;
				my $url = "/$u";
				$url .= "/$page" if($page ne "");
				respond_location($client, $url);
			}elsif(-f $request_file){
				respond_file($client, $request_file);
			}else{
				respond_error($client, "404 Not Found");
			}
			close $client;
			exit;
		}
		exit;
	}elsif($cmd eq "stop"){
		stop_server();
		exit;
	}elsif($cmd eq "password"){
		eval "use Digest::HMAC_SHA1 qw(hmac_sha1);";
		die "The Digest::HMAC_SHA1 module is required to hash passwords" if($@);
		printf "my \$tmp_adminpw = 'admin:%s:admin:\@:Administrator:';\n", hash_password("admin", "admin");
		exit;
	}
	print <<EOT;
Usage: $u COMMAND [OPTIONS]
  start		     Start the server
    -p <port>	     Port number (default: 80 for HTTP and 443 for HTTPS)
    -c <cert.pem>    SSL certificate file
    -k <key.pem>     SSL key file
    -i <index.html>  Index HTML
    -f <forbidden>   Regular expression for forbidden files (default:
    		     (^u\\.(cfg|pw|msg|pid|log)|^\\.sessions|\\.(tpl|txt|txt\\.v))\$)
    -r		     Redirect non-existing HTML requests to $u and non-HTML
		     requests to existing HTML files
    -s		     Secure the server by redirecting all requests to $u; Any
		     of \$READ_ACCESS or \$WRITE_ACCESS must be closed to avoid
		     infinite redirections
EOT
	unless($win){
		print <<EOT;
  restart	     Restart the server
  stop		     Stop the server
EOT
	}
	print <<EOT;
  password	     Print a new admin password hash

Please run this script from a web browser or with one of the above commands.
EOT
	exit;
}

################################################################################
# CGI variables
$CFG = $ENV{HTTP_UNIQKI_CONFIG};
$HTTPS = $ENV{HTTPS};
$HTTP_COOKIE = $ENV{HTTP_COOKIE};
$HTTP_HOST = $ENV{HTTP_HOST};
$SERVER_NAME = $ENV{SERVER_NAME};
$SCRIPT_NAME = $ENV{SCRIPT_NAME};
$PATH_INFO = $ENV{PATH_INFO};
$QUERY_STRING = $ENV{QUERY_STRING};
$REQUEST_METHOD = $ENV{REQUEST_METHOD};
$CONTENT_TYPE = $ENV{CONTENT_TYPE};
$CONTENT_LENGTH = $ENV{CONTENT_LENGTH};

################################################################################
# Useful variables
# Supported URLs:
# This script outside cgi-bin: $doc_root = ""
# * https?://host/~user/dir/u/page/path/to/file?query
#   * CGI: u
#   * DOC_BASE: https?://host/~user/dir
# This script inside cgi-bin: $doc_root != ""
# * https?://host/~user/cgi-bin/u/page/path/to/file?query
#   * CGI: /~user/cgi-bin/u
#   * DOC_BASE: https?://host/~user/doc_root
# * HTTP_BASE: https?://host
# * PAGE: page
# * FILE: path/to/file
$CGI = $SCRIPT_NAME;
$HTTP_BASE = ($HTTPS eq "on" ? "https" : "http")."://$HTTP_HOST";
$DOC_BASE = "$HTTP_BASE$CGI"; $DOC_BASE =~ s#/[^/]*$##;
$PAGE = substr $PATH_INFO, 1; $PAGE =~ s#/.*$##;
$PAGE =~ s#\.(?:html|txt|txt\.v)$##;
$FILE = $PATH_INFO; $FILE =~ s#^/[^/]+##; $FILE =~ s#^/##;

################################################################################
# Awardspace.com free web hosting
my $hosting = "";
if(-d "/home/www/$SERVER_NAME"){
	$hosting = "awardspace";
	$_ = "/home/www/$SERVER_NAME$SCRIPT_NAME";
	s#/[^/]*$##;
	chdir $_;
}
if($doc_root eq ""){
	$CGI =~ s#^.*/##;
}else{
	($_ = $CGI) =~ s#/[^/]+$##;
	s#^/~[^/]+##;
	if($_ eq ""){
		chdir $doc_root;
	}else{
		s#^/##; s#[^/]+#..#g;
		chdir "$_/$doc_root";
	}
	$DOC_BASE = $HTTP_BASE.($CGI =~ m#(^/~[^/]+)# ? $1 : "")."/$doc_root";
}

################################################################################
# Prepare the default parser
prepare_parser();

################################################################################
# Read the config file
process_cfg();
$INDEX_PAGE = "index" if($INDEX_PAGE eq "");
if($TIME_ZONE ne ""){
	if($TIME_ZONE =~ m/^gmt([+-])([0-9]+)$/i){
		$TIME_ZONE = "GMT".($1 eq "+" ? "-" : "+").$2;
	}
	$ENV{TZ} = $TIME_ZONE;
}

eval "use POSIX qw(setlocale LC_ALL tzset strftime);";
my $use_posix = $@ ? 0 : 1;
if($use_posix){
	setlocale(LC_ALL(), $LOCALE) if($LOCALE ne "");
	tzset() if($TIME_ZONE ne "");
	$TIME_FORMAT =~ s/%e/%#d/g if($win);
}

my $smtp_server = "";
my $smtp_port;
my $smtp_username;
my $smtp_password;
if($SMTP =~ m/^([a-z0-9.-]+\.[a-z]{2,}):([0-9]*):([^:]*):(.*)$/i){
	$smtp_server = $1;
	$smtp_port = $2;
	$smtp_username = $3;
	$smtp_password = $4;
}

my ($page_name_case, $page_name_dots, $page_name_spaces) =
	config_page_name_style();
my ($nonwiki_read_access, $wiki_read_access, $wiki_write_access) =
	config_read_write_access();

################################################################################
# Messages
process_msg();

################################################################################
# hmac_sha1 subroutine for password hashing
eval "use Digest::HMAC_SHA1 qw(hmac_sha1);";
die_message("perl_module_not_installed", "Digest::HMAC_SHA1") if($@);

################################################################################
# Initialization
$USER = "";
$NAME = "Visitor";
my $admin = 0;
my $rebuild = 0;
my $insecure_pw = 1;
my $sessions_file = $SESSIONS_FILE eq "" ? ".sessions" : $SESSIONS_FILE;
my $debug_started = 0;
my %locked_files = ();
my $cookie_attributes = get_cookie_attributes();

################################################################################
# Non-user-replaceable subroutines
sub debug{
	my $msg = shift;
	unless($debug_started){
		$debug_started = 1;
		print "Content-Type: text/plain\n\n";
	}
	printf "%s\n", $msg;
}

sub format_time{
	my $time = shift;
	my $ftime;
	if($use_posix && $TIME_FORMAT ne ""){
		$ftime = strftime($TIME_FORMAT, localtime $time);
	}else{
		$ftime = scalar localtime $time;
	}
	return $ftime;
}

sub config_page_name_style{
	my ($case, $dots, $spaces);

	foreach my $item (split /:/, $PAGE_NAME_STYLE){
		if("_case" eq substr $item, -5){
			$case = $item;
			if($case eq "lower_camel_case"){
				$dots = "no_dots";
				$spaces = "no_spaces";
			}elsif($case eq "upper_camel_case"){
				$case = "start_case";
				$dots = "no_dots";
				$spaces = "no_spaces";
			}
		}elsif("dots" eq substr $item, -4){
			$dots = $item;
		}else{
			$spaces = $item;
		}
	}

	if($case ne "upper_case" && $case ne "mixed_case" &&
		$case ne "start_case" && $case ne "lower_camel_case" &&
		$case ne "upper_camel_case"){
		# default lower_case
		$case = "lower_case";
	}

	if($dots ne "no_dots"){
		# default dots
		$dots = "dots";
	}
	if($spaces ne "no_spaces" && $spaces ne "underscores"){
		# default hyphens
		$spaces = "hyphens";
	}
	return ($case, $dots, $spaces);
}

sub config_read_write_access{
	my @items = split /:/, $READ_ACCESS;
	my $nonwiki_read_access = $items[0] ne "open" && $items[0] ne "closed" ?
		"admin" : $items[0];
	my $wiki_read_access = index($READ_ACCESS, ":") == -1 ?
		$nonwiki_read_access :
		($items[1] ne "open" && $items[1] ne "closed" ?
			"admin" : $items[1]);
	my $wiki_write_access = $WRITE_ACCESS ne "open" &&
		$WRITE_ACCESS ne "closed" ? "admin" : $WRITE_ACCESS;
	return ($nonwiki_read_access, $wiki_read_access, $wiki_write_access);
}

sub run_file_mime_type{
	my $file = shift;
	return "" if($MIME_TYPE_COMMAND eq "" || !-f $file);
	(my $mime_type = `$MIME_TYPE_COMMAND $file`) =~ y/[\r\n]//d;
	return $mime_type;
}

sub get_mime_type{
	my $file = shift;
	return "" unless(-f $file);
	my $mime_type;
	eval "use MIME::Types;";
	if($@){
		$mime_type = run_file_mime_type($file);
	}else{
		$mime_type = MIME::Types->new(only_iana=>1)->mimeTypeOf($file);
		$mime_type = run_file_mime_type($file) if($mime_type eq "");
	}
	$mime_type = "application/octet-stream" if($mime_type eq "");
	return $mime_type;
}

sub die_path{
	my $path = shift;
	die_message("path_not_found", $path) unless(-e $path);

	if(-d $path){
		$path =~ s#/+$##;
		my $title = get_msg("page_files", $path);
		(local $TITLE = $title) =~ s/<[^>]*>//g;
		print_header();
		print qq(<div id="ls">\n<h1>$title</h1>\n<ul>\n);
		foreach(<$path/*>){
			my $file = $_;
			s#^[^/]*/##;
			my $url = encode_url($_);
			s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g;
			my $name = $_;
			my @t = localtime((stat $file)[9]);
			my $time = sprintf "%d-%02d-%02d %02d:%02d:%02d",
				$t[5]+1900, $t[4]+1, $t[3], $t[2], $t[1], $t[0];
			print qq(<li><a href="$url">$name</a> <span class="ls-time">$time</span></li>\n);
		}
		print qq(</ul></div>\n);
		print_footer();
		die;
	}

	my $mime_type = get_mime_type($path);
	(my $file = $path) =~ s#^.*/##;
	print <<EOT;
Content-Type: $mime_type
Content-Disposition: inline; filename="$file"

EOT
	local *FH;
	open FH, $path;
	print <FH>;
	close FH;
	die;
}

sub die_message{
	local $MESSAGE = get_msg(@_);
	(local $TITLE = $MESSAGE) =~ s/<[^>]*>//g;
	print_message();
	die;
}

sub die_rebuild{
	my $PAGE = shift;
	if(-f "$PAGE.txt"){
		make_html($PAGE);
		die_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE");
	}
	die_redirect("$HTTP_BASE$SCRIPT_NAME/$INDEX_PAGE");
}

sub die_redirect{
	printf "Location: %s\n\n", shift;
	die;
}

sub die_text{
	print "Content-Type: text/plain\n\n";
	print shift;
	die;
}

sub start_html{
	return if($html_started);
	$html_started = 1;
	print "Content-Type: text/html\n\n";
}

sub convert_page_name{
	my $page_name = shift;
	my $forbidden_chars = q(`~!@#\$%^&*=+\\|;:'",\/?()\[\]{}<>);

	# from parse_line
	# escaped html codes
	$page_name =~ s/(\x00&[^;]*;)+/ /g;
	$page_name =~ y/\x01/&/;
	$page_name =~ y/\x02/</;
	$page_name =~ y/\x03/>/;

	$page_name =~ s/[$forbidden_chars \t_-]+/ /og;
	if($page_name_dots eq "dots"){
		$page_name =~ s/\.+/./g;
		$page_name =~ s/(?:\.? \.?)+/ /g;
	}else{
		$page_name =~ y/.//d;
		$page_name =~ s/ +/ /g;
	}
	# Allow page names starting with a dot.
	$page_name =~ s/^ |[. ]$//g;
	return "" if($page_name eq "");

	if($page_name_case eq "mixed_case"){
		# case as is
	}elsif($page_name_case eq "upper_case"){
		$page_name = uc $page_name;
	}elsif($page_name_case eq "start_case"){
		$page_name =~ s/(?:^|(?<=[ .]))([^ .])([^ .]*)/@{[(uc $1).(lc $2)]}/g;
	}elsif($page_name_case eq "lower_camel_case"){
		$page_name =~ s/^([^ .]*)/@{[lc $1]}/;
		$page_name =~ s/(?<=[ .])([^ .])([^ .]*)/@{[(uc $1).(lc $2)]}/g;
	}else{
		# default: lower_case
		$page_name = lc $page_name;
	}

	if($page_name_spaces eq "no_spaces"){
		$page_name =~ y/ //d;
	}elsif($page_name_spaces eq "underscores"){
		$page_name =~ y/ /_/;
	}else{
		# default: hyphens
		$page_name =~ y/ /-/;
	}

	return $page_name;
}

sub unescape_comment{
	my $text = shift;
	$text =~ y/\x00//d;
	return $text;
}

sub escape_comment{
	my $text = shift;
	$text =~ s/^([#%])/\x00$1/mg;
	$text =~ s/``(.*?)``(?!`)/`\x00`$1`\x00`/g;
	$text =~ s/^(---+)$/\x00$1/mg;
	$text =~ s/^\x00(---+)\n(.*?)\n\x00\1$/$1\n@{[unescape_comment($2)]}\n$1/smg;
	$text =~ s/\x00/''''/g;
	return $text;
}

sub link_page{
	my ($page, $section, $title) = @_;

	$page =~ s/^[ \t]+|[ \t]+$//g;
	$section =~ s/^[ \t]+|[ \t]+$//g;
	$title =~ s/^[ \t]+|[ \t]+$//g;

	my $enc_page = encode_url(convert_page_name($page));
	my $enc_section = encode_url(convert_page_name($section));

	if($enc_page eq ""){
		return "" if($enc_section eq "");
		return qq(<a class="auto-title" href="#$enc_section">$section</a>) if($title eq "");
		return qq(<a href="#$enc_section">$title</a>);
	}
	if($enc_section eq ""){
		return qq(<a class="auto-title" href="$enc_page.html">$page</a>) if($title eq "");
		return qq(<a href="$enc_page.html">$title</a>);
	}
	return qq(<a class="auto-title" href="$enc_page.html#$enc_section">$section</a>) if($title eq "");
	return qq(<a href="$enc_page.html#$enc_section">$title</a>);
}

sub link_image{
	# file: current page's file
	# ./file: current page's file
	# page/file: page's file
	# /file: DOC_BASE's file
	my ($path, $title, $style) = @_;

	$path =~ s/^[ \t]+|[ \t]+$//g;
	$title =~ s/^[ \t]+|[ \t]+$//g;
	$style =~ s/^[ \t]+|[ \t]+$//g;
	return "" if($path eq "." || $path eq "");

	$style = qq( style="$style") if($style ne "");

	my $page = $PAGE;
	my $file = "";

	my $i = rindex($path, "/");
	if($i >= 0){
		my $p = substr $path, 0, $i;
		if($p eq ""){
			# /file
			$page = ".";
		}elsif($p ne "."){
			# page/file
			$page = convert_page_name($p);
			return "" if($page eq "");
		}
		# else ./file
		$file = substr $path, $i + 1;
		return "" if($file eq "");
	}else{
		# file
		$file = $path;
	}

	my $enc_path = encode_url("$page/$file");
	return qq(<img class="auto-title" src="$enc_path" alt="$file" title="$file"$style />) if($title eq "");
	return qq(<img src="$enc_path" alt="$title" title="$title"$style />);
}

sub link_file{
	# .: current page's directory
	# ./: current page's directory
	# file: current page's file
	# ./file: current page's file
	# page/: page's directory
	# page/file: page's file
	# /: DOC_BASE
	# /file: DOC_BASE's file
	my ($path, $title) = @_;

	$path =~ s/^[ \t]+|[ \t]+$//g;
	$title =~ s/^[ \t]+|[ \t]+$//g;

	my $page = $PAGE;
	my $file = "";

	my $i = rindex($path, "/");
	if($i >= 0){
		my $p = substr $path, 0, $i;
		if($p eq ""){
			# /, /file
			$page = ".";
		}elsif($p ne "."){
			# page/, page/file
			$page = convert_page_name($p);
			return "" if($page eq "");
		}
		# else ./, ./file
		$file = substr $path, $i + 1;
	}elsif($path eq "."){
		# .
		$file = "";
	}else{
		# file
		$file = $path;
	}

	if($file eq ""){
		return qq(<a class="auto-title" href="$page/">$page/</a>) if($title eq "");
		return qq(<a href="$page/">$title</a>);
	}

	my $enc_path = encode_url("$page/$file");
	return qq(<a class="auto-title" href="$enc_path">$file</a>) if($title eq "");
	return qq(<a href="$enc_path">$title</a>);
}

sub link_url_image{
	my ($url, $title, $style) = @_;

	$url =~ s/^[ \t]+|[ \t]+$//g;
	$title =~ s/^[ \t]+|[ \t]+$//g;
	$style =~ s/^[ \t]+|[ \t]+$//g;
	$style = qq( style="$style") if($style ne "");

	return qq(<img class="auto-title" src="$url" alt="$url" title="$url"$style />) if($title eq "");
	return qq(<img src="$url" alt="$title" title="$title"$style />);
}

sub link_url{
	my ($url, $title) = @_;

	$url =~ s/^[ \t]+|[ \t]+$//g;
	$title =~ s/^[ \t]+|[ \t]+$//g;

	return qq(<a class="auto-title" href="$url">$url</a>) if($title eq "");
	return qq(<a href="$url">$title</a>);
}

sub is_url{
	my $url = shift;

	# from parse_line
	$url =~ y/\x01/&/;
	$url =~ y/\x02/</;
	$url =~ y/\x03/>/;

	# https://en.wikipedia.org/wiki/Percent-encoding
	return $url =~ m#^(?:[a-z]+://)[%!*'();:@&=+\$,/?\#\[\]a-z0-9_.~-]+$#i;
}

sub protect_urls{
	my $text = shift;
	$text =~ s#([a-z]+://)#\x00$1#gi;
	return $text;
}

sub encode_url{
	my $url = shift;

	# from parse_line
	$url =~ y/\x01/&/;
	$url =~ y/\x02/</;
	$url =~ y/\x03/>/;

	# https://en.wikipedia.org/wiki/Percent-encoding
	$url =~ s/([^!*'();:@&=+\$,\/?#\[\]a-zA-Z0-9_.~-])/@{[sprintf "%%%x", ord($1)]}/g;
	$url =~ s/&/&amp;/g;
	return $url;
}

sub decode_url{
	my $url = shift;
	$url =~ s/%(..)/@{[pack "c", hex($1)]}/g;
	return $url;
}

sub is_logged_in{
	return $USER ne "";
}

sub has_read_access{
	return 1 if($admin);
	if($wiki){
		return 1 if($wiki_read_access eq "open");
		return 1 if($wiki_read_access eq "closed" && is_logged_in());
		return 0;
	}
	return 1 if($nonwiki_read_access eq "open");
	return 1 if($nonwiki_read_access eq "closed" && is_logged_in());
	return 0;
}

sub has_write_access{
	return 1 if($admin);
	return 0 unless($wiki);
	return 1 if($wiki_write_access eq "open");
	return 1 if($wiki_write_access eq "closed" && is_logged_in());
	return 0;
}

sub page_exists{
	my $page = shift;
	$page = $PAGE unless defined $page;
	return -f "$page.txt";
}

#-------------------------------------------------------------------------------
# Password file
sub write_pw{
	my $file = $PASSWORD_FILE eq "" ? "u.pw" : $PASSWORD_FILE;
	write_file($file, "$adminpw\n") unless(-f $file);
}

#-------------------------------------------------------------------------------
# Default config
sub process_cfg{
	# $mode=undef: eval
	# $mode=1: write
	my $mode = shift;
	my $cfg = <<'EOT_UNIQKI';
# Site information: HTML tags are allowed.
$SITE_TITLE = 'Uniqki: A Personal Wiki Builder';
$SITE_DESCRIPTION = 'A <a href="http://uniqki.isnew.info">Uniqki</a> site';

# Index page
$INDEX_PAGE = 'index';

# Language
$LANG = 'en';

# Character set
$CHARSET = 'utf-8';

# Locale: Setting this variable to an empty string uses the default locale.
$LOCALE = '';

# Set time zone if different from the system time
$TIME_ZONE = '';

# Time format interpreted by the POSIX::strftime function
$TIME_FORMAT = '%a %b %e %H:%M:%S %Y %Z';

# Share cookies: [subdomains:][EMPTY|subpaths|all_paths]
# * subdomains: http://example.com/u shares cookies with
#		http://www.example.com/u.
# * EMPTY: http://example.com/path1/u does not share cookies with
#	   http://example.com/u, http://example.com/path2/u, nor
#	   http://example.com/path1/subpath1/u.
# * subpaths: http://example.com/path1/u shares cookies with
#	      http://example.com/path1/subpath1/u, but not with
#	      http://example.com/u nor http://example.com/path2/u.
# * all_paths: http://example.com/path1/u shares cookies with
#	       http://example.com/u, http://example.com/path2/u, and
#	       http://example.com/path1/subpath1/u.
#
# It is possible to combine subdomains and one of EMPTY, subpaths, and
# all_paths.  For example,
# * subdomains:all_paths: http://example.com/path1/u shares cookies with
#			  http://www.example.com/u.
#
# An empty setting '' means that cookies are not shared with other subdomains
# nor paths.  Subdomains and specified paths have to use the password and
# sessions files in the current domain and path to share login sessions.
# Subpaths does not work with $doc_root because the script and document
# directories are different.
$SHARE_COOKIES = '';

# WARNING: Make sure to protect these files and directories from the user using
# the following directives in .htaccess:
# <Files ~ "(^u\.(cfg|pw|msg)|^\.sessions|\.(tpl|txt|txt\.v))$">
#	Deny from all
# </Files>

# Password file: The admin password can be embedded in the script as $adminpw.
$PASSWORD_FILE = 'u.pw';

# Sessions file: The default sessions file is .sessions.
$SESSIONS_FILE = '.sessions';

# Messages file: The default messages will be printed if missing.
$MESSAGES_FILE = 'u.msg';

# Template directory: The default template will be served by the script if
# missing.
$TEMPLATE_DIRECTORY = 'u.tpl';

# Page name style: case[:dots|:no_dots][:hyphens|:underscores|:no_spaces]
# * lower_case (default): All lower case (e.g., page in a uniqki site)
# * upper_case: All upper case (e.g., PAGE IN A UNIQKI SITE)
# * mixed_case: No special handling of letter case (e.g., Page in a Uniqki site)
# * start_case: Start case (e.g., Page In A Uniqki Site)
# * lower_camel_case: Lower camel case (e.g., pageInAUniqkiSite)
# * upper_camel_case: Upper camel case (e.g., PageInAUniqkiSite)
#
# Dots
# * dots (default): Replace a series of dots with a dot.  Dots separate words
#		    for a case conversion.
# * no_dots: Remove dots.  The lower_camel_case and upper_camel_case styles
#	     imply this option.  For example, upper_camel_case is the same as
#	     start_case:no_dots:no_spaces.
#
# Spaces
# * hyphens (default): Replace a series of whitespaces with a hyphen
# * underscores: Replace a series of whitespaces with an underscore
# * no_spaces: Remove whitespaces.  The lower_camel_case and upper_camel_case
#	       styles imply this option.  For example, lower_camel_case is the
#	       same as lower_camel_case:no_dots:no_spaces.
#
# The following special characters will be replaced with spaces and separate
# words before a case conversion: `~!@#$%^&*=+\|;:'",/?()[]{}<>
#
# Hyphens (-) and underscores (_) will be converted to spaces and may be
# converted back to hyphens or underscores depending on the page name style.
#
# For example, "'page' in a uniqki site!!!" excluding double quotes in the
# start_case style will create and link to Page-In-A-Uniqki-Site.html.  The
# same page name in the upper_camel_case style will use PageInAUniqkiSite.html.
$PAGE_NAME_STYLE = 'lower_case:dots:hyphens';

# Section number style in headings and the table of contents: The default style
# is "1.1&nbsp;&nbsp;&nbsp;".
$SECTION_NUMBER_PREFIX = '';
$SECTION_NUMBER_SEPARATOR = '.';
$SECTION_NUMBER_SUFFIX = '&nbsp;&nbsp;&nbsp;';

# Section reference style in text: The default style is "Section 1.1".
$SECTION_REFERENCE_PREFIX = 'Section ';
$SECTION_REFERENCE_SUFFIX = '';

# Table number style in captions and the list of tables: The default style is
# "Table 1: ".
$TABLE_NUMBER_PREFIX = 'Table ';
$TABLE_NUMBER_SUFFIX = ': ';

# Table reference style in text: The default style is "Table 1".
$TABLE_REFERENCE_PREFIX = 'Table ';
$TABLE_REFERENCE_SUFFIX = '';

# Figure number style in captions and the list of tables: The default style is
# "Figure 1: ".
$FIGURE_NUMBER_PREFIX = 'Figure ';
$FIGURE_NUMBER_SUFFIX = ': ';

# Figure reference style in text: The default style is "Figure 1".
$FIGURE_REFERENCE_PREFIX = 'Figure ';
$FIGURE_REFERENCE_SUFFIX = '';

# Login session will be extended by this number of minutes whenever any action
# is taken by the user.
$INACTIVE_TIMEOUT = 24*60;

# Change password timeout in minutes
$SET_PASSWORD_TIMEOUT = 60;

# Reset password timeout in minutes
$RESET_PASSWORD_TIMEOUT = 1;

# Email address from which user notifications are sent: 'Your Name
# <you@example.com>' is not supported.  Enter your email address only as in
# 'you@example.com'.  Make sure to use single quotes instead of double quotes.
$EMAIL_ADDRESS = '';

# SMTP settings for user notifications: If this variable is empty, email will
# be sent using sendmail.  The format of this variable is
# 'server:port:username:password'.  The password may contain colons (:), but
# the username cannot.
$SMTP = '';

# Fallback MIME type command: This command will be used to determine the MIME
# type of files when the MIME::Types module is not installed or fails to
# determine the type.  Setting this variable to an empty string will return an
# empty MIME type.
$MIME_TYPE_COMMAND = '/usr/bin/file --brief --mime-type';

# Read access control
# * open (default): Opens both non-wiki and wiki pages to the public and anyone
#		    will be able to read those pages with or without a login.
# * closed: Requires a login to perform any read actions including search,
#	    diff, etc.  The directives in .htaccess shown below are required to
#	    prevent direct access to *.html files, effectively making the
#	    entire site read-secured.
# * admin: Allows only admin users access to non-wiki and wiki pages.  The
#	   .htaccess directives below are required.
#
# Non-wiki and wiki pages can have different settings separated by a colon.
# For example, closed:open means closed non-wiki and open wiki pages.  One
# setting applies to both non-wiki and wiki pages.  That is, open is the same
# as open:open (open non-wiki and open wiki).
#
# Unless this variable is open or open:open, the following .htaccess directives
# are required to secure *.html files:
# RewriteEngine On
# RewriteBase /
# RewriteRule ^$ u [R,L]
# RewriteRule ^([^/]*)\.html$ u/$1 [R,L]
# RewriteRule ^(u/[^/]*)\.html$ $1 [R,L]
# RewriteCond %{REQUEST_URI} !^/u($|[/?])
# RewriteRule .* "-" [F]
$READ_ACCESS = 'open';

# Write access control
# * open (default): Allows anyone to edit or create wiki pages with or without
#		    a login.
# * closed: Requires a login to edit or create wiki pages.
# * admin: Requires admin rights to edit or create wiki pages.
#
# Creating new wiki pages also depends on $WIKI_PAGES_ALLOWED.  For security
# reasons, non-wiki pages are writable only by admin users and this variable
# cannot affect that behavior.
$WRITE_ACCESS = 'open';

# Regular expression for page names that are not allowed
$PAGES_NOT_ALLOWED = q();

# User parsers file
$USER_PARSERS_FILE = '';

# Header and footer files for the non-wiki and wiki parsers
$HEADER_FILE = '';
$FOOTER_FILE = '';

# Header and footer files for the non-wiki parser
$NONWIKI_HEADER_FILE = '';
$NONWIKI_FOOTER_FILE = '';

# Header and footer files for the wiki parser
$WIKI_HEADER_FILE = '';
$WIKI_FOOTER_FILE = '';

# Regular expression for wiki page names that are allowed to be created by
# non-admin users
$WIKI_PAGES_ALLOWED = q();

# Regular expression for file names that are allowed to be uploaded by
# non-admin users to a wiki page
$WIKI_FILES_ALLOWED = q(\.(png|gif|jpg|jpeg|txt|zip)$);
EOT_UNIQKI
	my $file = $CFG eq "" ? "u.cfg" : $CFG;
	if($mode == 1){
		write_file($file, $cfg) unless(-f $file);
	}else{
		eval $cfg;
		do $file if(-f $file);
	}
}

#-------------------------------------------------------------------------------
# Default messages
sub process_msg{
	# $mode=undef: eval if file does not exist, do file otherwise
	# $mode=1: write
	my $mode = shift;
	my $msg = <<'EOT_UNIQKI';
%MESSAGES = (
################################################################################
# Template messages: These messages don't support printf format specifiers such
# as %s because there is no way to pass arguments to these messages from the
# template.  However, the [[PAGE]] tag can be used to generate dynamic text.
powered_by_uniqki => q(Powered by <a href="http://uniqki.isnew.info">Uniqki</a>!),

username => q(Username),
password => q(Password),
logout_from_other_computers => q(Logout from other computers),
view => q(View),

manage_pages => q(Manage pages),
backup => q(Backup),
restore => q(Restore),

manage_users => q(Manage users),
add_user => q(Add user),
update_user => q(Update user),
block_user => q(Block user),
unblock_user => q(Unblock user),
delete_user => q(Delete user),
email_address => q(Email address),
full_name => q(Full name),
non_admin => q(Non-admin),
admin => q(Admin),
dont_change => q(Don't change),
type_password_again => q(Type password again),
username_requirements => q(Username requirements: 4 or more letters (a-z, A-Z) and digits (0-9).),
full_name_requirements => q(Full name requirements: 5 or more letters without digits (0-9) and special characters.),
password_requirements => q(Password requirements: 8 or more characters with at least one letter (a-z, A-Z), one digit (0-9), and one special character excluding spaces and tabs.),
leave_password_blank_for_email_notification => q(Leave the password field blank for an email notification with a temporary link for resetting the password.),

manage_myself => q(Manage myself),
update_myself => q(Update myself),
delete_myself => q(Delete myself),

forgot_password => q(Forgot password),
enter_username_or_email_address => q(Please enter a username or an email address.),
user_info_mismatch => q(User information mismatch!),
email_address_not_found => q(%s: Email address not found.),
user_blocked => q(%s: User blocked.),

reset_password => q(Reset password),
password_reset_token_expired => q(Password reset token expired.),
password_reset_token_still_valid => q(You still have a valid password reset token. Please refer to the last email notification.),
invalid_password_reset_token => q(Invalid password reset token.),
password_reset_token_not_found => q(Password reset token not found.),

refresh => q(Refresh),
edit => q(Edit),
index => q(Index),
loginout => q(Loginout),
login => q(Login),
logout => q(Logout),
diff => q(Diff),
backlinks => q(Backlinks),
last_modified => q([[TIME]] by [[AUTHOR]]),
unknown_author => q(Unknown),
parsing_time => q(Parsing time: [[PARSING_TIME]] seconds),
xhtml => q(XHTML),
css => q(CSS),

preview => q(Preview),
save => q(Save),
file_upload => q(File upload: ),
cancel => q(Cancel),
preview_warning => q(This document is preview. Please make sure to save your changes.),

page_updated => q([[PAGE]] updated!),
save_your_changes_and_read_latest_version => q(Please save your changes and read <a href="[[PAGE]].html">the latest version</a>!),

edit_page => q(Edit [[PAGE]]),
wiki_edit_page => q(WikiEdit [[PAGE]]),

################################################################################
# Non-template messages: These messages support printf format specifiers such
# as %s, but [[...]] tags cannot be used.
internal_errors => q(Internal errors),
session_errors => q(Session errors),
perl_module_not_installed => q(%s: Perl module not installed.),

change_admin_password => q(The admin password cannot be the same as the temporary password. <a href="?manage_myself">Change your password.</a>),

read_secured => q(You are not allowed to read this page.),
login_not_allowed => q(Login is not allowed.),
login_failed => q(Login failed.),
admin_actions_not_allowed => q(Admin actions are not allowed. Please <a href="?login">login</a> first.),

cannot_add_yourself => q(You cannot add yourself.),
cannot_block_yourself => q(You cannot block yourself.),
cannot_unblock_yourself => q(You cannot unblock yourself.),
cannot_delete_yourself => q(You cannot delete yourself.),
cannot_delete_only_admin => q(You cannot delete yourself because you are the only admin.),
user_already_blocked => q(%s: User already blocked.),
user_already_unblocked => q(%s: User already unblocked.),
user_already_exists => q(%s: User already exists.),
email_address_already_registered => q(%s: Email address already registered.),
enter_user_info_to_update => q(%s: Please enter user information to update.),
user_not_found => q(%s: User not found.),

enter_username => q(Please enter a username to manage.),
check_username => q(Please enter a username that meets character requirements.),
enter_email_address => q(Please enter an email address.),
check_email_address => q(Please enter a valid email address.),
leave_email_address_blank => q(Please leave the email address blank.),
enter_full_name => q(Please enter the user's full name.),
check_full_name => q(Please enter a full name that meets character requirements.),
check_password => q(Please enter a password that meets the length and character requirements.),
confirm_password => q(Please confirm the password.),
leave_password_blank => q(Please leave the password blank.),

new_user_email_subject => q(%s: Registered),
new_user_email_text => q(Your username %s is registered at %s. Please set your password by visiting %s within %d minutes.),
unblocked_user_email_subject => q(%s: Unblocked),
unblocked_user_email_text => q(Your username %s is unblocked at %s. Please set your password by visiting %s within %d minutes.),
reset_password_email_subject => q(%s: Reset password),
reset_password_email_text => q(Please reset your password for username %s at %s by visiting %s within %d minutes.),
email_notification_failed => q(Email notification failed for user %s <%s>.),

page_not_allowed => q(%s: Page not allowed.),
page_not_found => q(%s: Page not found.),
create_page => q(%s: Page not found. <a href="?edit">Create this page.</a>),
not_wiki_page => q(%s: This page is not a wiki page.),
not_allowed_to_create_nonwiki_page => q(%s: You are not allowed to create this non-wiki page.),
not_allowed_to_create_wiki_page => q(%s: You are not allowed to create this wiki page.),
not_allowed_to_edit_wiki_page => q(%s: You are not allowed to edit this wiki page.),
path_not_found => q(%s: Path not found.),

recent_changes => q(Recent changes),
recent_changes_matching => q(Recent changes matching %s pattern),
old_changes => q(Old changes),
old_changes_matching => q(Old changes matching %s pattern),
all_pages => q(All pages),
all_pages_matching => q(All pages matching %s pattern),
all_pages_reversed => q(All pages in reversed order),
all_pages_reversed_matching => q(All pages matching %s pattern in reverse order),
refresh_pages => q(Refresh pages),
refresh_pages_matching => q(Refresh pages matching %s pattern),
search => q(Search for %s),
search_matching => q(Search %s for %s),
differences => q(Differences of <a href="%s">%1$s</a> between versions %d and %d),

goto_form => q(Goto form),
goto_form_goto => q(Go to),
search_form => q(Search form),
search_form_search => q(Search),
search_form_simple => q(Simple),
search_form_ignore_case => q(Ignore case),
search_form_links => q(Links),
search_form_print_titles => q(Print titles),
search_form_dont_print_matches => q(Don't print matches),
comment_form => q(Comment form),
comment_form_leave_this_field_blank => q(Please leave this field blank: ),
comment_form_write => q(Write),
specify_comment_page => q(Please specify a comment page.),
comment_tag_not_found => q(%s: Comment tag not found.),
invalid_comment_tag => q(%s: Invalid comment tag.),

current_version => q(The current version of <a href="%s">%1$s</a> is %d.),
wiki_file_not_allowed => q(%s: File not allowed.),
wiki_file_uploaded => q(%s: File uploaded. Copy and paste the link below:<pre id="file-link-example">{{%s|%1$s}}</pre>),
file_uploaded => q(%s: File uploaded. Copy and paste the link below:<pre id="file-link-example">{{%1$s}}</pre>),
page_files => q(Files belonging to <a href="../%s">%1$s</a>),

table_of_contents => q(Contents),
list_of_tables => q(Tables),
list_of_figures => q(Figures),
);
EOT_UNIQKI
	my $file = $MESSAGES_FILE eq "" ? "u.msg" : $MESSAGES_FILE;
	if($mode == 1){
		write_file($file, $msg) unless(-f $file);
	}else{
		eval $msg;
		do $file if(-f $file);
	}
}

sub get_msg{
	my $msg_id = shift;
	return sprintf $MESSAGES{$msg_id}, @_;
}

sub is_username{
	my $user = shift;
	my $len = length($user);
	return $len >= 4 && $len <= 64 && $user =~ m/^[a-zA-Z0-9]+$/;
}

sub is_password{
	my $pw = shift;
	my $len = length($pw);
	return $len >= 8 && $len <= 128 &&
		$pw =~ m/[a-zA-Z]/ && $pw =~ m/[0-9]/ &&
		$pw =~ m/[`~!@#\$%^&*_+=\\|;:'",.\/?()\[\]{}<>]/;
}

sub is_email_address{
	# Regex: http://www.regular-expressions.info/email.html
	my $email = shift;
	my $len = length($email);
	return $len >= 6 && $len <= 254 &&
		$email =~ m/^[a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,}$/i;
}

sub is_full_name{
	my $name = shift;
	$name =~ s/[ \t]+/ /g;
	$name =~ s/^ | $//g;
	my $len = length($name);
	return $len >= 5 && $name !~ m/[`~!@#\$%^&*_=+\\|;:'",\/?()\[\]{}<>0-9-]/;
}

sub is_session_id{
	my $session_id = shift;
	my $len = length($session_id);
	return $len == 64 && $session_id =~ m/^[a-zA-Z0-9]+$/;
}

sub is_password_reset_token_valid{
	my $token = shift;
	if($token !~ m/^[a-zA-Z0-9]{8}[0-9a-f]{40}\.([0-9]+)$/){
		return 0;
	}
	my $expires = $1;
	my $time = time;
	return $time < $expires;
}

#-------------------------------------------------------------------------------
# Default template
sub process_tpl_tag{
	my $tag = shift;
	local *FH;
	my $txt = "";

	open FH, ">", \$txt; my $fh = select FH;
	if($tag eq "HEADER"){
		print_header();
	}elsif($tag eq "FOOTER"){
		print_footer();
	}elsif($tag eq "EDIT"){
		print_edit();
	}elsif($tag eq "WIKI_EDIT"){
		print_wiki_edit();
	}elsif($tag =~ m/^[A-Z_]+$/){
		my @tags = qw(
			SITE_TITLE SITE_DESCRIPTION INDEX_PAGE TITLE LANG
			CHARSET PAGE VERSION TEXT HTTP_BASE DOC_BASE PREVIEW
			TIME CGI MESSAGE PASSWORD_RESET_TOKEN NAME AUTHOR
			PARSING_TIME
		);
		my %hash;
		@hash{@tags} = undef;

		no strict;
		$txt = $$tag if(exists $hash{$tag});
	}elsif($tag eq "parsing_time" && !$show_parsing_time){
		$txt = "";
	}elsif($tag =~ m/^[a-z_]+$/){
		$txt = get_msg($tag);
		my @tags = qw(
			PAGE TIME AUTHOR PARSING_TIME
		);

		no strict;
		foreach(@tags){
			$txt =~ s/\[\[$_\]\]/$$_/g;
		}
	}
	close FH; select $fh;
	chomp $txt;

	return $txt;
}

sub process_tpl{
	# $mode=undef: print
	# $mode=1: write
	# $mode=2: print for CSS and JavaScript only
	my ($file, $mode, $tpl) = @_;
	my $path = "$TEMPLATE_DIRECTORY/$file";

	start_html() unless defined $mode;
	if($mode == 2){
		if(".css" eq substr $file, -4){
			print "Content-Type: text/css\n\n";
		}elsif(".js" eq substr $file, -3){
			print "Content-Type: text/javascript\n\n";
		}
	}

	if($mode == 1){
		write_file($path, $tpl) if(-d $TEMPLATE_DIRECTORY && !-f $path);
		return;
	}elsif(-f $path){
		$tpl = read_file($path);
	}

	$tpl =~ s/\[\[([A-Za-z_]*)\]\]/@{[process_tpl_tag($1)]}/g;
	print $tpl;
}

sub print_header{
	my $mode = shift;
	return if(!defined $mode && $header_printed);

	$header_printed = 1;
	process_tpl("header.tpl", $mode, <<'EOT_UNIQKI');
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="[[LANG]]">
<head>
<title>[[TITLE]]</title>
<meta charset="[[CHARSET]]" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="stylesheet" type="text/css" href="[[CGI]]?css" />
<link rel="alternate" type="application/rss+xml" title="[[recent_changes]]" href="[[CGI]]?rss" />
<script src="[[CGI]]/[[PAGE]]?js"></script>
</head>
<body>
<div id="container">
<div id="top">
<div id="site-title"><a href="[[DOC_BASE]]">[[SITE_TITLE]]</a></div>
<div id="site-description">[[SITE_DESCRIPTION]]</div>
</div>
<div id="main">
EOT_UNIQKI
}

sub print_footer{
	my $mode = shift;
	return if(!defined $mode && $footer_printed);

	$footer_printed = 1;
	process_tpl("footer.tpl", $mode, <<'EOT_UNIQKI');
</div>
<div id="bottom">
<span id="validators">
<a href="https://validator.w3.org/check?uri=referer">[[xhtml]]</a> .
<a href="https://jigsaw.w3.org/css-validator/check/referer">[[css]]</a>
</span> .
[[powered_by_uniqki]]
</div>
</div>
</body>
</html>
EOT_UNIQKI
}

sub print_login{
	process_tpl("login.tpl", shift, <<'EOT_UNIQKI');
[[HEADER]]
<div id="login">
<h1>[[login]]</h1>
<form action="[[PAGE]]?login" method="post">
<div>
<input accesskey="u" type="text" id="user" name="user" placeholder="[[username]]" />
<input accesskey="p" type="password" id="pw" name="pw" placeholder="[[password]]" />
<input accesskey="l" type="submit" value="[[login]]" />
<br />
<input type="checkbox" id="logout_others" name="logout_others" value="1" /> [[logout_from_other_computers]]
</div>
</form>
</div>
<hr />
<div id="menu">
<span class="read-access"><a accesskey="v" href="[[PAGE]].html">[[view]]</a> .</span>
<a accesskey="i" href="[[INDEX_PAGE]].html">[[index]]</a>
</div>
[[FOOTER]]
EOT_UNIQKI
}

sub print_manage_pages{
	process_tpl("manage_pages.tpl", shift, <<'EOT_UNIQKI');
[[HEADER]]
<div id="manage-pages">
<h1>[[manage_pages]]</h1>
<form action="?restore" method="post" enctype="multipart/form-data">
<div>
[[backup]]: <a href="[[CGI]]?backup">[[all_pages]]</a> .
<a href="?backup">[[PAGE]]</a>
<br />
[[restore]]: <input accesskey="f" type="file" id="file" name="file" />
<input accesskey="r" type="submit" value="[[restore]]" />
</div>
</form>
</div>
<hr />
<div id="menu">
<span class="read-access"><a accesskey="v" href="[[PAGE]].html">[[view]]</a> .</span>
<a accesskey="i" href="[[INDEX_PAGE]].html">[[index]]</a> .
<a accesskey="l" href="[[PAGE]]?logout">[[logout]]</a>
</div>
[[FOOTER]]
EOT_UNIQKI
}

sub print_manage_users{
	process_tpl("manage_users.tpl", shift, <<'EOT_UNIQKI');
[[HEADER]]
<div id="manage-users">
<h1>[[manage_users]]</h1>
<ul>
<li>[[username_requirements]]</li>
<li>[[full_name_requirements]]</li>
<li>[[password_requirements]]</li>
<li>[[leave_password_blank_for_email_notification]]</li>
</ul>

<h2>[[add_user]]</h2>
<form action="?add_user" method="post">
<div>
<input accesskey="u" type="text" id="user" name="user" placeholder="[[username]]" />
<input accesskey="e" type="text" id="email" name="email" placeholder="[[email_address]]" />
<input accesskey="f" type="text" id="name" name="name" placeholder="[[full_name]]" />
<br />
<input type="radio" id="admin" name="admin" value="no" /> [[non_admin]]
<input type="radio" id="admin" name="admin" value="yes" /> [[admin]]
<br />
<input accesskey="p" type="password" id="pw" name="pw" placeholder="[[password]]" />
<input type="password" id="pw2" name="pw2" placeholder="[[type_password_again]]" />
<br />
<input type="submit" value="[[add_user]]" />
</div>
</form>

<h2>[[update_user]]</h2>
<form action="?update_user" method="post">
<div>
<input accesskey="u" type="text" id="user" name="user" placeholder="[[username]]" />
<input accesskey="e" type="text" id="email" name="email" placeholder="[[email_address]]" />
<input accesskey="f" type="text" id="name" name="name" placeholder="[[full_name]]" />
<br />
<input type="radio" id="admin" name="admin" value="no" /> [[non_admin]]
<input type="radio" id="admin" name="admin" value="yes" /> [[admin]]
<input type="radio" id="admin" name="admin" value="keep" /> [[dont_change]]
<br />
<input accesskey="p" type="password" id="pw" name="pw" placeholder="[[password]]" />
<input type="password" id="pw2" name="pw2" placeholder="[[type_password_again]]" />
<br />
<input type="submit" value="[[update_user]]" />
</div>
</form>

<h2>[[block_user]]</h2>
<form action="?block_user" method="post">
<div>
<input accesskey="u" type="text" id="user" name="user" placeholder="[[username]]" />
<br />
<input type="submit" value="[[block_user]]" />
</div>
</form>

<h2>[[unblock_user]]</h2>
<form action="?unblock_user" method="post">
<div>
<input accesskey="u" type="text" id="user" name="user" placeholder="[[username]]" />
<br />
<input accesskey="p" type="password" id="pw" name="pw" placeholder="[[password]]" />
<input type="password" id="pw2" name="pw2" placeholder="[[type_password_again]]" />
<br />
<input type="submit" value="[[unblock_user]]" />
</div>
</form>

<h2>[[delete_user]]</h2>
<form action="?delete_user" method="post">
<div>
<input accesskey="u" type="text" id="user" name="user" placeholder="[[username]]" />
<br />
<input type="submit" value="[[delete_user]]" />
</div>
</form>
</div>
<hr />
<div id="menu">
<span class="read-access"><a accesskey="v" href="[[PAGE]].html">[[view]]</a> .</span>
<a accesskey="i" href="[[INDEX_PAGE]].html">[[index]]</a> .
<a accesskey="l" href="[[PAGE]]?logout">[[logout]]</a>
</div>
[[FOOTER]]
EOT_UNIQKI
}

sub print_manage_myself{
	process_tpl("manage_myself.tpl", shift, <<'EOT_UNIQKI');
[[HEADER]]
<div id="manage-myself">
<h1>[[manage_myself]]</h1>

<h2>[[update_myself]]</h2>
<ul>
<li>[[full_name_requirements]]</li>
<li>[[password_requirements]]</li>
</ul>

<form action="?update_myself" method="post">
<div>
<input accesskey="e" type="text" id="email" name="email" placeholder="[[email_address]]" />
<input accesskey="f" type="text" id="name" name="name" placeholder="[[full_name]]" />
<br />
<input accesskey="p" type="password" id="pw" name="pw" placeholder="[[password]]" />
<input type="password" id="pw2" name="pw2" placeholder="[[type_password_again]]" />
<br />
<input type="submit" value="[[update_myself]]" />
</div>
</form>

<h2>[[delete_myself]]</h2>
<form action="?delete_myself" method="post">
<div>
<input type="submit" value="[[delete_myself]]" />
</div>
</form>
</div>
<hr />
<div id="menu">
<span class="read-access"><a accesskey="v" href="[[PAGE]].html">[[view]]</a> .</span>
<a accesskey="i" href="[[INDEX_PAGE]].html">[[index]]</a> .
<a accesskey="l" href="[[PAGE]]?logout">[[logout]]</a>
</div>
[[FOOTER]]
EOT_UNIQKI
}

sub print_forgot_password{
	process_tpl("forgot_password.tpl", shift, <<'EOT_UNIQKI');
[[HEADER]]
<div id="forgot-password">
<h1>[[forgot_password]]</h1>
<form action="?forgot_password" method="post">
<div>
<input accesskey="u" type="text" id="user" name="user" placeholder="[[username]]" />
<input accesskey="e" type="text" id="email" name="email" placeholder="[[email_address]]" />
<br />
<input type="submit" value="[[forgot_password]]" />
</div>
</form>
</div>
<hr />
<div id="menu">
<span class="read-access"><a accesskey="v" href="[[PAGE]].html">[[view]]</a> .</span>
<a accesskey="i" href="[[INDEX_PAGE]].html">[[index]]</a>
</div>
[[FOOTER]]
EOT_UNIQKI
}

sub print_reset_password{
	process_tpl("reset_password.tpl", shift, <<'EOT_UNIQKI');
[[HEADER]]
<div id="reset-password">
<h1>[[reset_password]]</h1>
<ul>
<li>[[password_requirements]]</li>
</ul>

<form action="?reset_password" method="post">
<div>
<input type="hidden" id="token" name="token" value="[[PASSWORD_RESET_TOKEN]]" />
<input accesskey="p" type="password" id="pw" name="pw" placeholder="[[password]]" />
<input type="password" id="pw2" name="pw2" placeholder="[[type_password_again]]" />
<br />
<input type="submit" value="[[reset_password]]" />
</div>
</form>
</div>
<hr />
<div id="menu">
<span class="read-access"><a accesskey="v" href="[[PAGE]].html">[[view]]</a> .</span>
<a accesskey="i" href="[[INDEX_PAGE]].html">[[index]]</a>
</div>
[[FOOTER]]
EOT_UNIQKI
}

sub print_message{
	process_tpl("message.tpl", shift, <<'EOT_UNIQKI');
[[HEADER]]
<div id="message">
[[MESSAGE]]
</div>
<hr />
<div id="menu">
<span class="read-access"><a accesskey="v" href="[[PAGE]].html">[[view]]</a> .</span>
<span class="write-access"><a accesskey="v" href="[[PAGE]]?edit">[[edit]]</a> .</span>
<a accesskey="i" href="[[INDEX_PAGE]].html">[[index]]</a> .
<a class="visitor" accesskey="l" href="[[PAGE]]?login">[[login]]</a>
<a class="user" accesskey="l" href="[[PAGE]]?logout">[[logout]]</a>
</div>
[[FOOTER]]
EOT_UNIQKI
}

sub print_view{
	# View templates are never served dynamically, so don't print a
	# content-type header
	$html_started = 1;
	process_tpl("view.tpl", shift, <<'EOT_UNIQKI');
[[HEADER]]
<div id="view">
<!-- start text -->
[[TEXT]]
<!-- end text -->
</div>
<hr />
<div id="menu">
<span class="write-access"><a accesskey="r" href="[[CGI]]/[[PAGE]]?refresh">[[refresh]]</a> .</span>
<span class="write-access"><a accesskey="e" href="[[CGI]]/[[PAGE]]?edit">[[edit]]</a> .</span>
<a accesskey="i" href="[[INDEX_PAGE]].html">[[index]]</a> .
<a class="visitor" accesskey="l" href="[[CGI]]/[[PAGE]]?login">[[login]]</a>
<a class="user" accesskey="l" href="[[CGI]]/[[PAGE]]?logout">[[logout]]</a>
</div>
<div id="last-modified">[[last_modified]]</div>
<div id="parsing-time">[[parsing_time]]</div>
[[FOOTER]]
EOT_UNIQKI
}

sub print_edit{
	process_tpl("edit.tpl", shift, <<'EOT_UNIQKI');
[[HEADER]]
<div id="edit">
<h1>[[edit_page]]</h1>
<form action="[[PAGE]]?edit" method="post" enctype="multipart/form-data">
<div>
<input type="hidden" id="version" name="version" value="[[VERSION]]" />
<textarea accesskey="e" id="text" name="text" rows="24" cols="80">[[TEXT]]</textarea>
<br />
<input accesskey="p" type="submit" id="preview" name="preview" value="[[preview]]" />
<input accesskey="s" type="submit" id="save" name="save" value="[[save]]" /> .
<a accesskey="c" href="[[PAGE]].html">[[cancel]]</a> .
<a accesskey="i" href="[[INDEX_PAGE]].html">[[index]]</a>
<br />
[[file_upload]] <input accesskey="f" type="file" id="file" name="file" />
</div>
</form>
</div>
[[FOOTER]]
EOT_UNIQKI
}

sub print_preview{
	process_tpl("preview.tpl", shift, <<'EOT_UNIQKI');
[[HEADER]]
<div id="preview-warning">[[preview_warning]]</div>
<div id="preview">
[[PREVIEW]]
</div>
[[EDIT]]
[[FOOTER]]
EOT_UNIQKI
}

sub print_updated{
	process_tpl("updated.tpl", shift, <<'EOT_UNIQKI');
[[HEADER]]
<div id="updated">
<h1>[[page_updated]]</h1>
[[save_your_changes_and_read_latest_version]]
<br />
<textarea accesskey="e" id="text" name="text" rows="24" cols="80">[[TEXT]]</textarea>
</div>
[[FOOTER]]
EOT_UNIQKI
}

sub print_wiki_view{
	# View templates are never served dynamically, so don't print a
	# content-type header
	$html_started = 1;
	process_tpl("wiki_view.tpl", shift, <<'EOT_UNIQKI');
[[HEADER]]
<div id="wiki-view">
<!-- start text -->
[[TEXT]]
<!-- end text -->
</div>
<div id="wiki-menu">
<span class="write-access"><a accesskey="e" href="[[CGI]]/[[PAGE]]?wiki_edit">[[edit]]</a> .</span>
<a accesskey="d" href="[[CGI]]/[[PAGE]]?diff=-1">[[diff]]</a> .
<a accesskey="l" href="[[CGI]]?search=[[PAGE]]%5C.html&amp;link=1">[[backlinks]]</a> .
<a accesskey="i" href="[[INDEX_PAGE]].html">[[index]]</a> .
<a class="visitor" accesskey="l" href="[[CGI]]/[[PAGE]]?login">[[login]]</a>
<a class="user" accesskey="l" href="[[CGI]]/[[PAGE]]?logout">[[logout]]</a>
</div>
<div id="last-modified">[[last_modified]]</div>
<div id="parsing-time">[[parsing_time]]</div>
[[FOOTER]]
EOT_UNIQKI
}

sub print_wiki_edit{
	process_tpl("wiki_edit.tpl", shift, <<'EOT_UNIQKI');
[[HEADER]]
<div id="wiki-edit">
<h1>[[wiki_edit_page]]</h1>
<form action="[[PAGE]]?wiki_edit" method="post" enctype="multipart/form-data">
<div>
<input type="hidden" id="version" name="version" value="[[VERSION]]" />
<textarea accesskey="e" id="text" name="text" rows="24" cols="80">[[TEXT]]</textarea><br />
<input accesskey="p" type="submit" id="preview" name="preview" value="[[preview]]" />
<input accesskey="s" type="submit" id="save" name="save" value="[[save]]" /> .
<a accesskey="c" href="[[PAGE]].html">[[cancel]]</a> .
<a accesskey="i" href="[[INDEX_PAGE]].html">[[index]]</a>
<br />
[[file_upload]] <input accesskey="f" type="file" id="file" name="file" />
</div>
</form>
</div>
[[FOOTER]]
EOT_UNIQKI
}

sub print_wiki_preview{
	process_tpl("wiki_preview.tpl", shift, <<'EOT_UNIQKI');
[[HEADER]]
<div id="wiki-preview-warning">[[preview_warning]]</div>
<div id="wiki-preview">
[[PREVIEW]]
</div>
[[WIKI_EDIT]]
[[FOOTER]]
EOT_UNIQKI
}

sub print_css{
	process_tpl("uniqki.css", shift, <<'EOT_UNIQKI');
/******************************************************************************/
body {
	background-color:	#eeeeee;
}
h1 {
	margin-top:		0px;
}
pre {
	background-color:	#eeeeee;
	border:			1px solid #dddddd;
	overflow:		auto;
}
table {
	border-collapse:	collapse;
}
table caption {
	text-align:		left;
	font-size:		smaller;
}
table th {
	border:			1px solid #999999;
	padding:		3px;
	background-color:	#eeeeee;
}
table td {
	border:			1px solid #999999;
	padding:		3px;
}
figure {
}
figure img {
}
figure figcaption {
	font-size:		smaller;
}
a {
	color:			green;
	text-decoration:	none;
}
a[href*="://"] {
	color:			blue;
}
form {
	margin:			0px;
}
textarea {
	width:			100%;
}

/******************************************************************************/
#container {
	max-width:		960px;
	margin:			auto;
}
#top {
}
#site-title {
	font-weight:		bold;
	font-size:		120%;
}
#site-title a {
	color:			black;
	text-decoration:	none;
}
#site-description {
	font-size:		smaller;
}
#main {
	background-color:	white;
	border:			1px solid #aaaaaa;
	padding:		10px;
	box-shadow:		5px 5px 5px #aaaaaa;
}
#login {
}
#manage-pages {
}
#manage-users {
}
#manage-myself {
}
#forgot-password {
}
#reset-password {
}
#message {
}
#menu {
	display:		none;
}
#last-modified {
	padding-top:		2px;
	font-size:		smaller;
}
#parsing-time {
	padding-top:		2px;
	font-size:		smaller;
}
#bottom {
	margin-top:		5px;
	text-align:		right;
	font-size:		smaller;
	font-style:		italic;
}
#validators {
}

/******************************************************************************/
#view {
}
#edit {
}
#preview-warning {
	background-color:	red;
	padding:		5px;
	margin-bottom:		10px;
}
#preview {
}
#updated {
}
#file-link-example {
	margin-bottom:		30px;
}

/******************************************************************************/
#wiki-view {
	background-color:	#eeeeee;
	color:			#000000;
	border:			1px solid #999999;
	padding:		5px;
}
#wiki-edit {
}
#wiki-preview-warning {
	background-color:	red;
	padding:		5px;
	margin-bottom:		10px;
}
#wiki-preview {
}
#wiki-menu {
	padding:		5px 5px 0px 5px;
	display:		none;
}

/******************************************************************************/
#toc {
}
.toc-heading {
	font-weight:		bold;
}
.toc-list {
}
.lot-heading {
	font-weight:		bold;
}
.lot-list {
}
.lof-heading {
	font-weight:		bold;
}
.lof-list {
}
.text-left {
	text-align:		left;
}
.text-center {
	text-align:		center;
}
.text-right {
	text-align:		right;
}

/******************************************************************************/
#diff {
}
.diff-unchanged {
	font-family:		monospace;
}
.diff-added {
	background-color:	#66cccc;
	color:			#000000;
	font-family:		monospace;
}
.diff-deleted {
	background-color:	#ff99cc;
	color:			#000000;
	font-family:		monospace;
	text-decoration:	line-through;
}
.diff-modified {
	background-color:	#cccccc;
	color:			#000000;
	font-family:		monospace;
}
.diff-modified-added {
	background-color:	#66cccc;
	color:			#000000;
	font-family:		monospace;
}
.diff-modified-deleted {
	background-color:	#ff99cc;
	color:			#000000;
	font-family:		monospace;
	text-decoration:	line-through;
}

/******************************************************************************/
#ls {
}
.ls-time {
	font-size:		70%;
	font-style:		italic;
}

/******************************************************************************/
.goto-input {
}

/******************************************************************************/
#search {
}
.search-highlight {
	font-weight:		bold;
}
.search-input {
}

/******************************************************************************/
.comment-website {
	display:		none;
}
.comment-input {
}
EOT_UNIQKI
}

sub print_js{
	process_tpl("uniqki.js", shift, <<'EOT_UNIQKI');
/* http://developer.mozilla.org/en/docs/AJAX:Getting_Started */
function ajax_request(url, data, func, mime_type){
	var xml_request = null;

	/* Create an XMLHTTP instance */
	if(window.XMLHttpRequest){ /* Mozilla, Safari, ... */
		xml_request = new XMLHttpRequest();
		if(mime_type != null && xml_request.overrideMimeType){
			/* Some web servers return a non-standard mime type. */
			xml_request.overrideMimeType(mime_type);
		}
	}else
	if(window.ActiveXObject){ /* IE */
		try{
			xml_request = new ActiveXObject('Msxml2.XMLHTTP');
		}catch(e){
		try{
			xml_request = new ActiveXObject('Microsoft.XMLHTTP');
		}catch(e){}
		}
	}
	if(!xml_request){
		alert('Cannot create an XMLHTTP instance.');
		return;
	}

	/* This function has no arguments. */
	xml_request.onreadystatechange = function(){
		if(xml_request.readyState != 4)
			return;
		if(xml_request.status != 200)
			return;
		func(xml_request);
	}

	if(data == null)
		var method = 'GET';
	else{
		var method = 'POST';
		xml_request.setRequestHeader('Content-Type',
			'application/x-www-form-urlencoded');
	}

	/* xml_request.open(method, url, asynchronous) */
	xml_request.open(method, url, true);

	/* xml_request.send(POST data) */
	/* required even if the method is not POST. */
	xml_request.send(data);
}

/* http://forum.java.sun.com/thread.jspa?threadID=696590&tstart=105 */
function ajax_responseXML(xml_request){
	var xml = null;

	if(window.ActiveXObject){ /* IE */
		xml = document.createElement('div');
		xml.innerHTML = xml_request.responseText;

		/* Huidae Cho <http://geni.isnew.info> */
		xml.getElementById = function(id){
			for(var i = 0; i < this.childNodes.length; i++){
				if(id == this.childNodes[i].id)
					return this.childNodes[i];
			}
			return null;
		}
	}else
	if(window.XMLHttpRequest){
		xml = xml_request.responseXML;
	}

	return xml;
}

function remove_elements_by_class_name(class_name){
	var elements = document.getElementsByClassName(class_name);
	while(elements.length > 0)
		elements[0].parentNode.removeChild(elements[0]);
}

function process_menu(xml_request){
	var items = xml_request.responseText.split(':');
	var user = items[0];
	var admin = items[1];
	var has_read_access = items[2];
	var has_write_access = items[3];

	remove_elements_by_class_name(user == '' ? 'user' : 'visitor');
	if(admin == 0)
		remove_elements_by_class_name('admin');
	if(has_read_access == 0)
		remove_elements_by_class_name('read-access');
	if(has_write_access == 0)
		remove_elements_by_class_name('write-access');

	var menu = document.getElementById('menu');
	var wiki_menu = document.getElementById('wiki-menu');
	if(menu != null)
		menu.style.display = 'block';
	if(wiki_menu != null)
		wiki_menu.style.display = 'block';
}

function window_onload(func){
	if(window.addEventListener){
		window.addEventListener('load', func);
	}else{
		window.attachEvent('onload', func);
	}
}

window_onload(function(){
	ajax_request('[[CGI]]/[[PAGE]]?user_info', null, process_menu)
});
EOT_UNIQKI
}

#-------------------------------------------------------------------------------
# Text file subroutines
sub lcs{
	my ($c0, $c1) = @_;
	my @lcs;
	my $s;
	for($s = 0; $s <= $#$c0 && $s <= $#$c1; $s++){
		last if($$c0[$s] ne $$c1[$s]);
	}
	my ($e0, $e1);
	for($e0 = $#$c0, $e1 = $#$c1; $e0 > $s && $e1 > $s; $e0--, $e1--){
		last if($$c0[$e0] ne $$c1[$e1]);
	}
	my ($m, $n);
	for($m = $s; $m <= $e0; $m++){
		for($n = $s; $n <= $e1; $n++){
			if($$c0[$m] eq $$c1[$n]){
				if($m && $n){
					$lcs[$m][$n] = $lcs[$m-1][$n-1] + 1;
				}else{
					$lcs[$m][$n] = 1;
				}
			}elsif($m && $n && $lcs[$m][$n-1]+0 > $lcs[$m-1][$n]+0){
				$lcs[$m][$n] = $lcs[$m][$n-1] + 0;
			}else{
				if($m){
					$lcs[$m][$n] = $lcs[$m-1][$n] + 0;
				}else{
					$lcs[$m][$n] = 0;
				}
			}
		}
	}
	my $i = $lcs[$e0][$e1];
	my @delta;
	$delta[$i] = ($e0+1).",".($e1+1);
	for($m = $e0, $n = $e1; $i > 0 && $m >= $s && $n >= $s; $m--, $n--){
		if($$c0[$m] eq $$c1[$n]){
			$delta[--$i] = "$m,$n";
		}elsif($lcs[$m][$n-1] > $lcs[$m-1][$n]){
			$m++;
		}else{
			$n++;
		}
	}
	return ($s, @delta);
}

sub diff{
	my @line0 = split /\n/, $_[0], -1; $#line0--;
	my @line1 = split /\n/, $_[1], -1; $#line1--;
	my ($s, @delta) = lcs(\@line0, \@line1);
	my ($m, $n) = ($s, $s);
	my $diff = "";
	for(my $i = 0; $i <= $#delta; $i++, $m++, $n++){
		my ($x, $y) = split /,/, $delta[$i];
		if($x > $m){
			for(; $m < $x; $m++){
				$diff .= "-$m\n";
			}
		}
		if($y > $n){
			for(; $n < $y; $n++){
				$diff .= "+$m $line1[$n]\n";
			}
		}
	}
	return $diff;
}

sub patch{
	my @line0 = split /\n/, $_[0], -1; $#line0--;
	my @lined = split /\n/, $_[1];
	my $line0p = "";
	for(my $i = 0; $i <= $#lined; $i++){
		if($lined[$i] =~ m/^\+/){
			my $p = index $lined[$i], " ";
			my $j = substr $lined[$i], 1, $p-1;
			my $l = substr $lined[$i], $p+1;
			if($j){
				$line0[$j-1] .= "\n$l";
			}else{
				$line0p .= "$l\n";
			}
		}else{
			$line0[substr $lined[$i], 1] = "\x00";
		}
	}
	$line0[0] = "$line0p$line0[0]";
	my $str = join "\n", @line0;
	$str .= "\n";
	$str =~ s/\x00\n//g;
	return $str;
}

sub save{
	my ($PAGE, $TEXT) = @_;

	my $version = 1;
	my $txtv;

	if(-f "$PAGE.txt"){
		local *FH;
		if(open FH, "$PAGE.txt.v"){
			my $line = <FH>;
			local $/ = undef;
			$txtv = $line.<FH>;
			close FH;
			my @items = split /:/, $line;
			$version = $items[0];
		}else{
			my $time = (stat "$PAGE.txt")[9];
			$txtv = "${version}::$time\n";
		}
		my $text = read_file("$PAGE.txt");

		my $diff = diff($TEXT, $text);
		if($diff eq ""){
			$rebuild = 1;
			return;
		}

		$version++;
		my $time = time;
		$txtv = "$version:$USER:$time\n$diff\x00\n$txtv";
	}else{
		my $time = time;
		$txtv = "$version:$USER:$time\n";
	}

	write_file("$PAGE.txt.v", $txtv);
	$rebuild = 1 if(write_file("$PAGE.txt", $TEXT));
}

sub get_author{
	my $PAGE = shift;
	local *FH;
	my $author = get_msg("unknown_author");
	if(open FH, "$PAGE.txt.v"){
		my @items = split /:/, <FH>;
		close FH;
		die_message("internal_errors") unless(-f "$PAGE.txt");
		my $user = $items[1];
		if($user ne ""){
			@items = find_user_info($user);
			$author = $items[4];
		}
	}
	return $author;
}

sub get_version{
	my $PAGE = shift;
	local *FH;
	my $version = 0;
	if(open FH, "$PAGE.txt.v"){
		my @items = split /:/, <FH>;
		close FH;
		die_message("internal_errors") unless(-f "$PAGE.txt");
		$version = $items[0];
	}elsif(-f "$PAGE.txt"){
		$version = 1;
	}
	return $version;
}

sub lock_file{
	my $file = shift;
	my $timeout = 60;
	my $i = 0;
	while(-f "$file.lock"){
		die_message("internal_errors") if(++$i > $timeout);
		sleep 1;
	}
	$locked_files{$file} = 1;
	die_message("internal_errors") unless(write_file("$file.lock"));
}

sub unlock_file{
	my $file = shift;
	unlink "$file.lock";
	delete $locked_files{$file};
}

sub preview{
	local $PAGE = shift;
	local $TEXT = shift;
	my $uploaded = shift;
	my $wiki_edit = shift;
	my $txt;

	local $TITLE;
	local $PREVIEW;
	local $wiki;
	local $html_started = 0;
	local $header_printed = 0;
	local $footer_printed = 0;

	write_file(\$txt, ($wiki_edit ? "#!wiki\n" : "")."$TEXT\n");

	$PREVIEW = parse_file(\$txt);
	chomp $PREVIEW;

	unless(defined $TITLE){
		if($PAGE eq $INDEX_PAGE){
			($TITLE = $SITE_TITLE) =~ s/<[^>]*>//g;
		}else{
			$TITLE = $PAGE;
		}
	}
	$PREVIEW = $uploaded.$PREVIEW;
	$TEXT =~ s/&/&amp;/g; $TEXT =~ s/</&lt;/g; $TEXT =~ s/>/&gt;/g;

	if($wiki_edit){
		print_wiki_preview();
	}else{
		print_preview();
	}
}

sub make_html{
	local $PAGE = shift;
	local $wiki;
	local $html_started = 0;
	local $header_printed = 0;
	local $footer_printed = 0;
	local $AUTHOR = get_author($PAGE);
	local $TIME = format_time((stat "$PAGE.txt")[9]);
	local $TITLE;
	my $start_time = Time::HiRes::time() if($show_parsing_time);
	local $TEXT = parse_file("$PAGE.txt");
	local $PARSING_TIME = sprintf "%.3f", Time::HiRes::time() - $start_time
		if($show_parsing_time);
	local *FH;

	unless(defined $TITLE){
		if($PAGE eq $INDEX_PAGE){
			($TITLE = $SITE_TITLE) =~ s/<[^>]*>//g;
		}else{
			$TITLE = $PAGE;
		}
	}

	my $html;
	open FH, ">", \$html; my $fh = select FH;
	if($wiki){
		print_wiki_view();
	}else{
		print_view();
	}
	close FH; select $fh;
	$html =~ s/\r//g;

	lock_file("$PAGE.html");
	write_file("$PAGE.html", $html);
	chmod 0755, "$PAGE.html" if($hosting eq "awardspace");
	unlock_file("$PAGE.html");
}

sub rmrf{
	local *DH;
	foreach(@_){
		if(-f $_){
			unlink $_;
		}elsif(-d $_){
			my $dir = $_;
			opendir DH, $dir;
			my @i = map {"$dir/$_"} grep !/^\.{1,2}$/, readdir DH;
			closedir DH;
			rmrf(@i);
			rmdir $dir;
		}
	}
}

sub rmdirp{
	foreach(@_){
		my $dir = $_;
		while(index($dir, "/") >= 0){
			rmdir $dir;
			$dir =~ s#/[^/]*$##;
		}
		rmdir $dir;
	}
}

sub find{
	my $file = shift;
	if(-d $file){
		local *DH;
		my @list;
		opendir DH, $file;
		foreach(sort readdir DH){
			next if($_ eq "." || $_ eq "..");
			push @list, find("$file/$_");
		}
		closedir DH;
		return @list;
	}elsif(-f $file){
		return $file;
	}
}

sub get_var{
	my (%var, $v);
	foreach(split /&/, $QUERY_STRING){
		m/^([^=]*)=(.*)$/;
		$v = $1; $var{$v} = $2;
		$var{$v} =~ y/+/ /; $var{$v} =~ s/%0D//g;
		$var{$v} = decode_url($var{$v});
	}
	return %var if($CONTENT_LENGTH eq "" || $CONTENT_LENGTH <= 0);

	my $content = "";
	my $total_len = 0;
	while(my $buf_len = read STDIN, my $buf, $CONTENT_LENGTH - $total_len){
		$total_len += $buf_len;
		$content .= $buf;
		die_message("internal_errors") if($total_len > $CONTENT_LENGTH);
		last if($total_len == $CONTENT_LENGTH);
	}
	if($CONTENT_TYPE eq "application/x-www-form-urlencoded"){
		foreach(split /&/, $content){
			m/^([^=]*)=(.*)$/;
			$v = $1; $var{$v} = $2;
			$var{$v} =~ y/+/ /; $var{$v} =~ s/%0D//g;
			$var{$v} = decode_url($var{$v});
		}
	}elsif($CONTENT_TYPE =~ m#^multipart/form-data; boundary=(.*)$#){
		my $boundary = $1;
		$content = substr $content, length($boundary) + 4,
			$CONTENT_LENGTH - 2 * (length($boundary) + 4) - 4;
		foreach(split /\r\n--$boundary\r\n/, $content){
			my ($header, $body) = m/^(.*?)\r\n\r\n(.*)$/s;
			$header =~ m/ name="(.*?)"/;
			my $name = $1;
			if($header =~ m/ filename="(.*?)"/){
				($var{$name} = $1) =~ s#^.*[/\\]##;
				$var{"$name="} = $body;
			}else{
				$body =~ s/\r//g;
				$var{$name} = $body;
			}
		}
	}
	return %var;
}

sub get_cookie_attributes{
	my $subdomains = 0;
	my $paths = "";
	foreach my $item (split /:/, $SHARE_COOKIES){
		if($item eq "subdomains"){
			$subdomains = 1;
		}elsif($item eq "subpaths" || $item eq "all_paths"){
			$paths = $item;
		}
	}
	(my $script_dir = $SCRIPT_NAME) =~ s#[^/]*$##;

	my $cookie_attributes = "";
	$cookie_attributes .= "domain=$HTTP_HOST; " if($subdomains);
	$cookie_attributes .= $paths eq "all_paths" ? "path=/; " :
		($paths eq "subpaths" && $doc_root eq "" ?
			"path=$script_dir; " : "path=$SCRIPT_NAME; ");
	$cookie_attributes .= "secure; " if($HTTPS eq "on");
	$cookie_attributes .= "httponly";

	return $cookie_attributes;
}

sub set_cookie{
	my ($session_id, $expires) = @_;

	my @t = gmtime $expires;
	my @m = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);
	my @w = qw(Sun Mon Tue Wed Thu Fri Sat);
	my $expires = sprintf "%s, %02d-%s-%d %02d:%02d:%02d GMT",
		$w[$t[6]], $t[3], $m[$t[4]], $t[5]+1900, $t[2], $t[1], $t[0];

	print "Set-Cookie: uniqki=$session_id; expires=$expires; ".
		"$cookie_attributes\n";
}

sub clear_cookie{
	print "Set-Cookie: uniqki=; expires=Tue, 01-Jan-1980 00:00:00 GMT; ".
		"$cookie_attributes\n";
}

sub find_user_info{
	my $user = shift;
	local *FH;

	my $method = 0;
	# $method=0: No user found
	# $method=1: Use $PASSWORD_FILE
	# $method=2: Use $adminpw

	if($PASSWORD_FILE eq ""){
		# No password file is specified in u.cfg.  Since the password
		# file in the default config is u.pw, an empty $PASSWORD_FILE
		# was assigned by the user.
		if($adminpw eq $tmp_adminpw){
			# If $adminpw is still temporary, this situation can be
			# very dangerous because anyone can login using the
			# public temporary password.  Do not allow any login in
			# this case.
		}else{
			# If $adminpw has been changed, use this password.
			$method = 2;
		}
	}elsif(-f $PASSWORD_FILE){
		# Use the password file
		$method = 1;
	}elsif($adminpw eq $tmp_adminpw){
		# Password file does not exist and $adminpw is temporary.  The
		# first run of this script is this case.  Create the password
		# file only for the login action immediately before checking
		# credentials against the temporary password to avoid timing
		# attacks.
		$method = 2;
	}else{
		# Password file does not exist and $adminpw has been changed.
		# Assume that the user deleted the password file intentionally
		# for single file operations.
		$method = 2;
	}
	return if($method == 0);

	my $userline = "";
	if($method == 1){
		open FH, $PASSWORD_FILE;
		my @lines = grep /^$user:/, <FH>;
		close FH;

		if($#lines == 0){
			$userline = $lines[0];
			$userline =~ s/[\r\n]//;
		}
	}elsif($method == 2 &&
		"$user:" eq substr $adminpw, 0, length("$user:")){
		$userline = $adminpw;
	}
	return if($userline eq "");

	return split /:/, $userline;
}

sub find_user_info_by_email_address{
	my $email = shift;
	local *FH;

	my $method = 0;
	# $method=0: No user found
	# $method=1: Use $PASSWORD_FILE
	# $method=2: Use $adminpw

	if($PASSWORD_FILE eq ""){
		# No password file is specified in u.cfg.  Since the password
		# file in the default config is u.pw, an empty $PASSWORD_FILE
		# was assigned by the user.
		if($adminpw eq $tmp_adminpw){
			# If $adminpw is still temporary, this situation can be
			# very dangerous because anyone can login using the
			# public temporary password.  Do not allow any login in
			# this case.
		}else{
			# If $adminpw has been changed, use this password.
			$method = 2;
		}
	}elsif(-f $PASSWORD_FILE){
		# Use the password file
		$method = 1;
	}elsif($adminpw eq $tmp_adminpw){
		# Password file does not exist and $adminpw is temporary.  The
		# first run of this script is this case.  Create the password
		# file only for the login action immediately before checking
		# credentials against the temporary password to avoid timing
		# attacks.
		$method = 2;
	}else{
		# Password file does not exist and $adminpw has been changed.
		# Assume that the user deleted the password file intentionally
		# for single file operations.
		$method = 2;
	}
	return if($method == 0);

	(my $escaped_email = $email) =~ s/\./\\./g;

	my $userline = "";
	if($method == 1){
		open FH, $PASSWORD_FILE;
		my @lines = grep /:$escaped_email(?::[^:]*){2}$/i, <FH>;
		close FH;

		if($#lines == 0){
			$userline = $lines[0];
			$userline =~ s/[\r\n]//;
		}
	}elsif($method == 2 &&
		$adminpw =~ m/:$escaped_email(?::[^:]*){2}$/i){
		$userline = $adminpw;
	}
	return if($userline eq "");

	return split /:/, $userline;
}

sub find_user_info_by_password_reset_token{
	my $token = shift;
	local *FH;

	my $method = 0;
	# $method=0: No user found
	# $method=1: Use $PASSWORD_FILE
	# $method=2: Use $adminpw

	if($PASSWORD_FILE eq ""){
		# No password file is specified in u.cfg.  Since the password
		# file in the default config is u.pw, an empty $PASSWORD_FILE
		# was assigned by the user.
		if($adminpw eq $tmp_adminpw){
			# If $adminpw is still temporary, this situation can be
			# very dangerous because anyone can login using the
			# public temporary password.  Do not allow any login in
			# this case.
		}else{
			# If $adminpw has been changed, use this password.
			$method = 2;
		}
	}elsif(-f $PASSWORD_FILE){
		# Use the password file
		$method = 1;
	}elsif($adminpw eq $tmp_adminpw){
		# Password file does not exist and $adminpw is temporary.  The
		# first run of this script is this case.  Create the password
		# file only for the login action immediately before checking
		# credentials against the temporary password to avoid timing
		# attacks.
		$method = 2;
	}else{
		# Password file does not exist and $adminpw has been changed.
		# Assume that the user deleted the password file intentionally
		# for single file operations.
		$method = 2;
	}
	return if($method != 1);

	(my $escaped_token = $token) =~ s/\./\\./g;

	my $userline = "";
	open FH, $PASSWORD_FILE;
	my @lines = grep /:$escaped_token$/, <FH>;
	close FH;

	if($#lines == 0){
		$userline = $lines[0];
		$userline =~ s/[\r\n]//;
	}
	return if($userline eq "");

	return split /:/, $userline;
}

sub authenticate_user{
	my ($user, $pw, $logout_others) = @_;

	my $method = 0;
	# $method=0: Login not allowed
	# $method=1: Create $PASSWORD_FILE and force to change the password
	# $method=2: Use $PASSWORD_FILE
	# $method=3: Use $adminpw

	if($PASSWORD_FILE eq ""){
		# No password file is specified in u.cfg.  Since the password
		# file in the default config is u.pw, an empty $PASSWORD_FILE
		# was assigned by the user.
		if($adminpw eq $tmp_adminpw){
			# If $adminpw is still temporary, this situation can be
			# very dangerous because anyone can login using the
			# public temporary password.  Do not allow any login in
			# this case.
			die_message("login_not_allowed");
		}else{
			# If $adminpw has been changed, use this password.
			$method = 3;
		}
	}elsif(-f $PASSWORD_FILE){
		# Use the password file
		$method = 2;
	}elsif($adminpw eq $tmp_adminpw){
		# Password file does not exist and $adminpw is temporary.  The
		# first run of this script is this case.  Create the password
		# file only for the login action immediately before checking
		# credentials against the temporary password to avoid timing
		# attacks.
		if($QUERY_STRING eq "login"){
			write_file($PASSWORD_FILE, "$adminpw\n");
			$method = 1;
		}
	}else{
		# Password file does not exist and $adminpw has been changed.
		# Assume that the user deleted the password file intentionally
		# for single file operations.
		$method = 3;
	}

	my ($usr, $saved_pw, $group, $email, $name, $token) =
		find_user_info($user);
	if(!defined $usr || $saved_pw eq "blocked"){
		close_session();
		die_message("login_failed");
	}

	my $salt = pack("H*", substr $saved_pw, 0, 16);
	if($saved_pw ne hash_password($user, $pw, $salt)){
		close_session();
		die_message("login_failed");
	}

	# If admin password is not temporary, the password is secure.
	my $userpw = "$user:$saved_pw:";
	$insecure_pw = 0 if($userpw ne substr $tmp_adminpw, 0, length($userpw));

	clear_user_sessions($user) if($logout_others eq "1");
	start_session($user);

	if($insecure_pw){
		# Force to change the password
		die_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE?manage_myself");
	}

	clear_password_reset_token($token);

	$USER = $user;
	$NAME = $name;
	$admin = 1 if($group eq "admin");
}

sub find_session_info{
	my $session_id = shift;
	local *FH;

	return if(!-f $sessions_file || !is_session_id($session_id));

	open FH, $sessions_file;
	my @lines = grep /^$session_id:/, <FH>;
	close FH;
	return if($#lines == -1);

	return split /:/, $lines[0];
}

sub start_session{
	my $user = shift;
	my ($session_id, $expires) = generate_session_id($user);
	set_cookie($session_id, $expires);
}

sub renew_session{
	my $session_id = shift;

	my $expires = time + $INACTIVE_TIMEOUT * 60;
	my $new_sessions = "";
	my $renewed = 0;

	lock_file($sessions_file);
	local *FH;
	open FH, $sessions_file;
	while(<FH>){
		if(m/^$session_id:/){
			$renewed = 1;
			my @items = split /:/;
			$_ = "$session_id:$items[1]:$items[2]:$expires\n";
		}
		$new_sessions .= $_;
	}
	close FH;

	if($renewed){
		write_file($sessions_file, $new_sessions);
		set_cookie($session_id, $expires);
	}
	unlock_file($sessions_file);
}

sub close_session{
	clear_cookie();

	my $cookie = $HTTP_COOKIE; $cookie =~ s/; /\n/g;
	return unless($cookie =~ m/^uniqki=(.+)$/m);

	my $session_id = $1;
	return if(!-f $sessions_file || !is_session_id($session_id));

	my $new_sessions = "";
	my $deleted = 0;

	lock_file($sessions_file);
	local *FH;
	open FH, $sessions_file;
	while(<FH>){
		if(m/^$session_id:/){
			$deleted = 1;
			next;
		}
		$new_sessions .= $_;
	}
	close FH;

	write_file($sessions_file, $new_sessions) if($deleted);
	unlock_file($sessions_file);
}

sub clear_user_sessions{
	my $user = shift;

	unless(defined $user){
		clear_cookie();
		my $cookie = $HTTP_COOKIE; $cookie =~ s/; /\n/g;
		$cookie =~ m/^uniqki=(.+)$/m;
		my $session_id = $1;
		(my $sess, $user) = find_session_info($session_id);
	}
	return if(!-f $sessions_file || !is_username($user));

	my $new_sessions = "";
	my $deleted = 0;

	lock_file($sessions_file);
	local *FH;
	open FH, $sessions_file;
	while(<FH>){
		if(m/^[^:]*:$user:/){
			$deleted = 1;
			next;
		}
		$new_sessions .= $_;
	}
	close FH;

	write_file($sessions_file, $new_sessions) if($deleted);
	unlock_file($sessions_file);
}

sub clear_expired_sessions{
	return if(!-f $sessions_file);

	my $new_sessions = "";
	my $deleted = 0;
	my $time = time;

	lock_file($sessions_file);
	local *FH;
	open FH, $sessions_file;
	while(<FH>){
		if(m/:([0-9]+)$/ && $time > $1){
			$deleted = 1;
			next;
		}
		$new_sessions .= $_;
	}
	close FH;

	write_file($sessions_file, $new_sessions) if($deleted);
	unlock_file($sessions_file);
}

sub handle_session{
	my $cookie = $HTTP_COOKIE; $cookie =~ s/; /\n/g;
	unless($cookie =~ m/^uniqki=(.+)$/m){
		clear_cookie();
		return;
	}

	my $session_id = $1;
	my ($sess, $user, $status, $expires) = find_session_info($session_id);

	unless(defined $sess){
		clear_cookie();
		return;
	}
	if($status ne "active" || time > $expires){
		close_session();
		return;
	}
	my ($usr, $pw, $group, $email, $name, $token) = find_user_info($user);
	unless(defined $usr){
		close_session();
		return;
	}

	renew_session($session_id);

	# If admin password is not temporary, the password is secure.
	my $userpw = "$user:$pw:";
	$insecure_pw = 0 if($userpw ne substr $tmp_adminpw, 0, length($userpw));

	$USER = $user;
	$NAME = $name;
	$admin = 1 if($group eq "admin");
}

sub clear_password_reset_token{
	my $token = shift;
	return if(!-f $PASSWORD_FILE ||
		$token !~ m/^[a-zA-Z0-9]{8}[0-9a-f]{40}\.[0-9]+$/);

	my $new_pw = "";
	my $cleared = 0;

	lock_file($PASSWORD_FILE);
	local *FH;
	open FH, $PASSWORD_FILE;
	while(<FH>){
		if(":$token\n" eq substr $_, length($_) - length(":$token\n")){
			my @items = split /:/;
			$cleared = 1;
			$_ = "$items[0]:$items[1]:$items[2]:$items[3]:$items[4]:\n";
		}
		$new_pw .= $_;
	}
	close FH;

	write_file($PASSWORD_FILE, $new_pw) if($cleared);
	unlock_file($PASSWORD_FILE);
}

sub generate_random_string{
	my $len = shift;
	# http://www.perlmonks.org/?node_id=233023
	my @chars = ("a".."z", "A".."Z", "0".."9");
	my $str;
	$str .= $chars[rand @chars] for 1..$len;
	return $str;
}

sub generate_salt{
	# salt length: 8
	return generate_random_string(8);
}

sub generate_session_id{
	my $user = shift;
	my $session_id;
	my $i = 0;
	my $found;
	do{
		$session_id = generate_random_string(64);
		my @session = find_session_info($session_id);
		$found = defined $session[0] ? 1 : 0;
		$i++;
	}while($found && $i<10);

	die_message("session_errors") if($found);

	my $expires = time + $INACTIVE_TIMEOUT * 60;

	lock_file($sessions_file);
	local *FH;
	die_message("session_errors") unless(open FH, ">>$sessions_file");
	print FH "$session_id:$user:active:$expires\n";
	close FH;
	unlock_file($sessions_file);

	return ($session_id, $expires);
}

# PBKDF2 for password hashing
# http://www.ict.griffith.edu.au/anthony/software/pbkdf2.pl
# Anthony Thyssen
sub get_pbkdf2_key{
	# key length: 128
	my ($password, $salt) = @_;
	my $prf = \&hmac_sha1;
	my $iter = 8192;
	my $keylen = 64;
	return unpack("H*", pbkdf2($prf, $password, $salt, $iter, $keylen));
}

# http://www.perlmonks.org/?node_id=631963
# Thanks to Jochen Hoenicke <hoenicke@gmail.com>
# (one of the authors of Palm Keyring)
sub pbkdf2{
	my ($prf, $password, $salt, $iter, $keylen) = @_;
	my ($k, $t, $u, $ui, $i);
	$t = "";
	for($k = 1; length($t) < $keylen; $k++){
		$u = $ui = $prf->($salt.pack('N', $k), $password);
		for($i = 1; $i < $iter; $i++){
			$ui = $prf->($ui, $password);
			$u ^= $ui;
		}
		$t .= $u;
	}
	return substr $t, 0, $keylen;
}

sub hash_password{
	# hashed password length: 2*8+128=144
	my ($user, $pw, $salt) = @_;
	$salt = generate_salt() unless defined $salt;
	return unpack("H*", $salt).get_pbkdf2_key("$user:$salt:$pw", $salt);

}

sub generate_password_set_token{
	# password set token length: 64+1+...
	my $user = shift;
	return generate_random_string(64).".".
		(time + $SET_PASSWORD_TIMEOUT * 60);
}

sub generate_password_reset_token{
	# password reset token length: 64+1+...
	my $user = shift;
	return generate_random_string(64).".".
		(time + $RESET_PASSWORD_TIMEOUT * 60);
}

sub send_email{
	my ($email, $subject, $text) = @_;
	eval "use MIME::Lite;";
	die_message("perl_module_not_installed", "MIME::Lite") if($@);

	if($smtp_server ne ""){
		if($smtp_port ne ""){
			if($smtp_username ne "" && $smtp_password ne ""){
				MIME::Lite->send("smtp", $smtp_server,
					Port=>$smtp_port,
					AuthUser=>$smtp_username,
					AuthPass=>$smtp_password);
			}else{
				MIME::Lite->send("smtp", $smtp_server,
					Port=>$smtp_port);
			}
		}else{
			if($smtp_username ne "" && $smtp_password ne ""){
				MIME::Lite->send("smtp", $smtp_server,
					AuthUser=>$smtp_username,
					AuthPass=>$smtp_password);
			}else{
				MIME::Lite->send("smtp", $smtp_server);
			}
		}
	}
	MIME::Lite->quiet(1);

	my $msg = MIME::Lite->new(
		From=>$EMAIL_ADDRESS,
		To=>$email,
		Subject=>$subject,
		Data=>$text);
	$msg->send();
	return $msg->last_send_successful();
}

sub create_goto_form{
	# $mode=undef: return
	# $mode=1: print
	my $mode = shift;
	my $goto = get_msg("goto_form_goto");
	my $form = <<EOT;
<form class="goto-input" action="$SCRIPT_NAME" method="get">
<div>
<input accesskey="g" id="goto" name="goto" />
<input type="submit" value="$goto" />
</div>
</form>
EOT
	if($mode == 1){
		print $form;
		return;
	}
	# Forms are not allowed inside a <p> block
	close_paragraph();
	return $form;
}

sub create_search_form{
	# $mode=undef: return
	# $mode=1: print
	my $mode = shift;
	my $search = get_msg("search_form_search");
	my $simple = get_msg("search_form_simple");
	my $icase = get_msg("search_form_ignore_case");
	my $link = get_msg("search_form_links");
	my $title = get_msg("search_form_print_titles");
	my $nomatch = get_msg("search_form_dont_print_matches");
	my $form = <<EOT;
<form class="search-input" action="$CGI" method="get">
<div>
<input accesskey="s" id="search" name="search" />
<input type="submit" value="$search" />
<br />
<input type="checkbox" id="simple" name="simple" value="1" checked="checked" /> $simple
<input type="checkbox" id="icase" name="icase" value="1" checked="checked" /> $icase
<input type="checkbox" id="link" name="link" value="1" /> $link
<br />
<input type="checkbox" id="title" name="title" value="1" /> $title
<input type="checkbox" id="nomatch" name="nomatch" value="1" /> $nomatch
</div>
</form>
EOT
	if($mode == 1){
		print $form;
		return;
	}
	# Forms are not allowed inside a <p> block
	close_paragraph();
	return $form;
}

sub create_comment_form{
	# $mode=undef: return
	# $mode=1: print
	my ($page, $comment, $direction, $rows, $cols, $mode) = @_;
	$page = $PAGE if($page eq "");
	$comment = "comment" if($comment eq "");
	$direction = "down" if($direction eq "");
	$rows = "6" if($rows eq "");
	$cols = "80" if($cols eq "");
	die_message("invalid_comment_tag", $comment)
		unless($comment =~ m/^[a-zA-Z0-9_-]+$/);
	my $id = time;

	my $leave_this_field_blank = get_msg("comment_form_leave_this_field_blank");
	my $write = get_msg("comment_form_write");
	my $form = <<EOT;
<form class="comment-input" action="$CGI?comment=$comment" method="post">
<div>
<div class="comment-website">$leave_this_field_blank<input id="website" name="website" /></div>
<input type="hidden" id="id" name="id" value="$id" />
<input type="hidden" id="page" name="page" value="$page" />
<input type="hidden" id="direction" name="direction" value="$direction" />
<textarea accesskey="c" id="text" name="text" rows="$rows" cols="$cols"></textarea>
<input type="submit" value="$write" />
</div>
</form>
EOT
	if($mode == 1){
		print $form;
		return;
	}
	# Forms are not allowed inside a <p> block
	close_paragraph();
	return $form;
}

sub verify_input_data{
	$verify_input = \&verify_input unless defined $verify_input;
	return $verify_input->(@_);
}

sub read_file{
	my $file = shift;
	my $text = "";
	local *FH;

	# "<" is required for the in-memory file
	if(open FH, "<", $file){
		# sysread is faster, but it doesn't work with in-memory files.
		local $/ = undef;
		$text = <FH>;
		close FH;
	}

	return $text;
}

sub write_file{
	# return 1 if successful
	# return 0 otherwise
	my ($file, $text, $binary) = @_;
	local *FH;

	# ">" is required for the in-memory file
	if(open FH, ">", $file){
		binmode FH if($binary);
		print FH $text;
		close FH;
		return 1;
	}
	return 0;
}

################################################################################
# Parsing subroutines
sub prepare_parser{
	@begin_parsing = \&begin_parsing;
	@parse_line = \&parse_line;
	@end_parsing = \&end_parsing;

	@process_child_block = \&process_child_block;
	@preprocess_line = \&preprocess_line;
	@process_syntax_block = \&process_syntax_block;
	@process_asis_lines = \&process_asis_lines;
	@skip_comment = \&skip_comment;
	@process_wiki_command = \&process_wiki_command;
	@process_nonwiki_command = \&process_nonwiki_command;
	@skip_unknown_command = \&skip_unknown_command;
	@start_syntax_block = \&start_syntax_block;
	@process_collected_lines = \&process_collected_lines;
	@process_paragraph_break = \&process_paragraph_break;
	@escape_inline_syntax = \&escape_inline_syntax;
	@process_inline_syntax = \&process_inline_syntax;
	@collect_lines = \&collect_lines;
	@process_line_syntax = \&process_line_syntax;
	@start_paragraph = \&start_paragraph;
	@postprocess_line = \&postprocess_line;
	@close_all_open = \&close_all_open;
}

sub parse{
	local $_ = shift;
	my @parsers = @_;
	foreach my $parser (@parsers){
		$_ = $parser->($_);
		return unless defined;
	}
	return $_;
}

sub parse_file{
	my $file = shift;
	local *UNIQKI_FH;

	return "" unless(open UNIQKI_FH, "<", $file);
	$wiki = <UNIQKI_FH> eq "#!wiki\n" ? 1 : 0;
	close UNIQKI_FH;

	local ($text, $url_char, $url_punct, $child_block, $code_block,
		$syntax_block, @parsed_blocks, $re_start, $re_n, @re, @re_sub,
		$p, $asis, $nosyntax, $pre, $pre_code, $blockquote, $list,
		$table, $figure, %h_n, $h_top, $h_prev, %h_secs, %secs_no,
		$toc, $notoc, $tab_no, %tabs_n, %tabs, $lot, $nolot, $fig_no,
		%figs_n, %figs, $lof, $nolof);
	my @files = ();

	push @files, $HEADER_FILE;
	push @files, $NONWIKI_HEADER_FILE unless($wiki);
	push @files, $WIKI_HEADER_FILE if($wiki);
	push @files, $file;
	push @files, $NONWIKI_FOOTER_FILE unless($wiki);
	push @files, $WIKI_FOOTER_FILE if($wiki);
	push @files, $FOOTER_FILE;

	my @_begin_parsing = @begin_parsing;
	my @_parse_line = @parse_line;
	my @_end_parsing = @end_parsing;

	my @_process_child_block = @process_child_block;
	my @_preprocess_line = @preprocess_line;
	my @_process_syntax_block = @process_syntax_block;
	my @_process_asis_lines = @process_asis_lines;
	my @_skip_comment = @skip_comment;
	my @_process_wiki_command = @process_wiki_command;
	my @_process_nonwiki_command = @process_nonwiki_command;
	my @_skip_unknown_command = @skip_unknown_command;
	my @_start_syntax_block = @start_syntax_block;
	my @_process_collected_lines = @process_collected_lines;
	my @_process_paragraph_break = @process_paragraph_break;
	my @_escape_inline_syntax = @escape_inline_syntax;
	my @_process_inline_syntax = @process_inline_syntax;
	my @_collect_lines = @collect_lines;
	my @_process_line_syntax = @process_line_syntax;
	my @_start_paragraph = @start_paragraph;
	my @_postprocess_line = @postprocess_line;
	my @_close_all_open = @close_all_open;

	do $USER_PARSERS_FILE if(-f $USER_PARSERS_FILE);

	$_->() foreach(@begin_parsing);
	foreach(@files){
		# "<" is required for the in-memory file
		next if($_ eq "" || !open UNIQKI_FH, "<", $_);
		$text .= parse($_, @parse_line) while(<UNIQKI_FH>);
		close UNIQKI_FH;
	}
	$_->() foreach(@end_parsing);

	@begin_parsing = @_begin_parsing;
	@parse_line = @_parse_line;
	@end_parsing = @_end_parsing;

	@process_child_block = @_process_child_block;
	@preprocess_line = @_preprocess_line;
	@process_syntax_block = @_process_syntax_block;
	@process_asis_lines = @_process_asis_lines;
	@skip_comment = @_skip_comment;
	@process_wiki_command = @_process_wiki_command;
	@process_nonwiki_command = @_process_nonwiki_command;
	@skip_unknown_command = @_skip_unknown_command;
	@start_syntax_block = @_start_syntax_block;
	@process_collected_lines = @_process_collected_lines;
	@process_paragraph_break = @_process_paragraph_break;
	@escape_inline_syntax = @_escape_inline_syntax;
	@process_inline_syntax = @_process_inline_syntax;
	@collect_lines = @_collect_lines;
	@process_line_syntax = @_process_line_syntax;
	@start_paragraph = @_start_paragraph;
	@postprocess_line = @_postprocess_line;
	@close_all_open = @_close_all_open;

	return $text;
}

sub parse_child_block{
	my $txt = shift;
	local ($text, $url_char, $url_punct, $child_block, $code_block,
		$syntax_block, @parsed_blocks, $re_start, $re_n, @re, @re_sub,
		$p, $asis, $nosyntax, $pre, $pre_code, $blockquote, $list,
		$table, $figure, %h_n, $h_top, $h_prev, %h_secs, %secs_no,
		$toc, $notoc, $tab_no, %tabs_n, %tabs, $lot, $nolot, $fig_no,
		%figs_n, %figs, $lof, $nolof);

	$_->() foreach(@begin_parsing);
	$text .= parse_lines($txt);
	$_->() foreach(@end_parsing);

	return $text;
}

sub parse_block{
	my $txt = shift;
	local ($text, $url_char, $url_punct, $child_block, $code_block,
		$syntax_block, @parsed_blocks, $p, $asis, $nosyntax, $pre,
		$pre_code, $blockquote, $list, $table, $figure);

	$_->(1) foreach(@begin_parsing);
	$text .= parse_lines($txt);
	$_->(1) foreach(@end_parsing);

	return $text;
}

sub parse_lines{
	my $txt = shift;
	local $text;
	$text .= parse($_, @parse_line) foreach(split /\n/, $txt, -1);
	return $text;
}

sub run_code_block{
	my $block = shift;
	$block =~ s/^(##[{}]_*)_$/$1/mg;
	eval $block;
}

sub create_child_block{
	my $block = shift;
	my $i = index $block, "\n";
	my $j = rindex $block, "\n";
	my $begin = substr $block, 0, $i;
	my $end = substr $block, $j + 1;
	$block = substr $block, $i + 1, $j - $i - 1;
	$block =~ s/(\(\(\(_*)_$/$1/mg;
	$block =~ s/^(\)\)\)_*)_/$1/mg;
	my $parsed_block = parse_child_block($block);
	chomp $parsed_block;
	push @parsed_blocks, $parsed_block;
	return "$begin\x06$end";
}

sub create_syntax_block{
	my $block = shift;
	my $i = index $block, "\n";
	my $j = rindex $block, "\n";
	my $begin = substr $block, 0, $i;
	my $end = substr $block, $j + 1;
	$block = substr $block, $i + 1, $j - $i - 1;
	$block =~ s/(?<!\()(\(\(_*)_$/$1/mg;
	$block =~ s/^(\)\)_*)_/$1/mg;
	my $parsed_block = parse_block($block);
	chomp $parsed_block;
	push @parsed_blocks, $parsed_block;
	return "$begin\x06$end";
}

sub create_blockquote{
	my @lines = split /\n/, shift;
	my $blockquote = "";
	my @cite = ();
	my $q_i = 0;
	my $use_p = 0;
	my $p = 0;

	foreach(@lines){
		m/^( *)(&gt;[ \t])?(.*)$/;
		my $i = length($1) / 2 + 1;
		my $start = $2 ne "" ? 1 : 0;
		my $line = $3;
		if(!$start || $line =~ m/^\(.*\)$/){
			if($i - 1 < $q_i){
				if($p){
					$blockquote .= "</p>\n";
					$p = 0;
				}
				while(--$q_i >= $i - 1){
					if($cite[$q_i] ne ""){
						$blockquote .= "<footer><cite>$cite[$q_i]</cite></footer>\n";
						$cite[$q_i] = "";
					}
					$blockquote .= "</blockquote>\n";
				}
				$q_i++;
			}
			if($line eq "" || $line eq "..."){
				$use_p = 1;
				if($p){
					$blockquote .= "</p>\n";
					$p = 0;
				}
				next;
			}
			if($line =~ m/^\([ \t]*(.*?)[ \t]*\)$/){
				my $qi = $start ? $i - 1 : $q_i - 1;
				$cite[$qi] .= "\n" if($cite[$qi] ne "");
				$cite[$qi] .= $1;
			}else{
				if($use_p){
					$line =~ s#(\x06)#</p>$1<p>#g;
					if(!$p){
						$blockquote .= "<p>";
						$p = 1;
					}
				}
				$line =~ s#([ \t])\([ \t]*(.*?)[ \t]*\)$#$1<cite>$2</cite>#;
				$line =~ s/^[ \t]*(.*?)[ \t]*$/$1/;
				$blockquote .= "$line\n";
			}
			next unless($start);
			$line = "";
		}
		$use_p = 0;
		if($p){
			$blockquote .= "</p>\n";
			$p = 0;
		}
		if($i > $q_i){
			for(; $q_i < $i - 1; $q_i++){
				$blockquote .= "<blockquote>\n";
			}
			$q_i++;
			$blockquote .= "<blockquote>\n";
		}elsif($i < $q_i){
			while(--$q_i >= $i){
				if($cite[$q_i] ne ""){
					$blockquote .= "<footer><cite>$cite[$q_i]</cite></footer>\n";
					$cite[$q_i] = "";
				}
				$blockquote .= "</blockquote>\n";
			}
			$q_i++;
		}else{
			if($cite[$q_i-1] ne ""){
				$blockquote .= "<footer><cite>$cite[$q_i-1]</cite></footer>\n";
				$cite[$q_i-1] = "";
			}
			$blockquote .= "</blockquote>\n<blockquote>\n";
		}

		$line =~ s#([ \t])\([ \t]*(.*?)[ \t]*\)$#$1<cite>$2</cite>#;
		$line =~ s/^[ \t]*(.*?)[ \t]*$/$1/;
		$blockquote .= "$line\n" if($line ne "");
	}
	if($p){
		$blockquote .= "</p>\n";
		$p = 0;
	}
	while(--$q_i >= 0){
		if($cite[$q_i] ne ""){
			$blockquote .= "<footer><cite>$cite[$q_i]</cite></footer>\n";
			$cite[$q_i] = "";
		}
		$blockquote .= "</blockquote>\n";
	}

	# Inline perl code
	$blockquote =~ s/``(.*?)``(?!`)/$1/eeg;
	# Discard none characters
	$blockquote =~ y/\x00//d;

	return $blockquote;
}

sub create_list{
	my @lines = split /\n/, shift;
	my $list = "";
	my $li_i = 0;
	my @li = ();
	my @li_attr = ();
	my $use_p = 0;
	my $p = 0;

	foreach(@lines){
		m/^( *)(?:([*+-]|: [ \t]*(.*?)[ \t]*:)[ \t])?[ \t]*(.*?)[ \t]*$/;
		my $i = length($1) / 2 + 1;
		my $line = $4;
		if($2 eq ""){
			if(--$i < $li_i){
				if($p){
					$list .= "</p>\n";
					$p = 0;
				}
				while(--$li_i >= $i){
					if($li[$li_i] eq "dl"){
						$list .= "</dd>\n";
					}else{
						$list .= "</li>\n";
					}
					$list .= "</$li[$li_i]>\n";
				}
				$li_i++;
			}
			if($line eq "" || $line eq "..."){
				$use_p = 1;
				if($p){
					$list .= "</p>\n";
					$p = 0;
				}
				next;
			}
			if($use_p){
				$line =~ s#(\x06)#</p>$1<p>#g;
				if(!$p){
					$list .= "<p>";
					$p = 1;
				}
			}
			$list .= "$line\n";
			next;
		}
		$use_p = 0;
		if($p){
			$list .= "</p>\n";
			$p = 0;
		}
		my $tag = substr $2, 0, 1;
		my $term = $3;
		my $attr = "";
		if($tag eq "*"){
			$tag = "ul";
		}elsif($tag eq "+"){
			$tag = "ol";
		}elsif($tag eq "-"){
			$tag = "ol";
			$attr = q( reversed="reversed");
		}else{
			$tag = "dl";
		}
		if($i > $li_i){
			for(; $li_i < $i - 1; $li_i++){
				$list .= "<$tag>\n";
				if($tag eq "dl"){
					$list .= "<dt></dt>\n<dd>";
				}else{
					$list .= "<li>";
				}
				$li[$li_i] = $tag;
				$li_attr[$li_i] = "";
			}
			$list .= "<$tag$attr>\n";
			$li[$li_i] = $tag;
			$li_attr[$li_i++] = $attr;
		}elsif($i < $li_i){
			while(--$li_i >= $i){
				if($li[$li_i] eq "dl"){
					$list .= "</dd>\n";
				}else{
					$list .= "</li>\n";
				}
				$list .= "</$li[$li_i]>\n";
			}
			if($li[$li_i] eq $tag && $li_attr[$li_i] eq $attr){
				if($li[$li_i] eq "dl"){
					$list .= "</dd>\n";
				}else{
					$list .= "</li>\n";
				}
				$li_i++;
			}else{
				for(; $li_i >= 0 && ($li[$li_i] ne $tag ||
					$li_attr[$li_i] ne $attr); $li_i--){
					if($li[$li_i] eq "dl"){
						$list .= "</dd>\n";
					}else{
						$list .= "</li>\n";
					}
					$list .= "</$li[$li_i]>\n";
				}
				while(++$li_i < $i-1){
					$list .= "<$tag>\n";
					$li[$li_i] = $tag;
					$li_attr[$li_i] = "";
				}
				$list .= "<$tag$attr>\n";
				$li[$li_i] = $tag;
				$li_attr[$li_i++] = $attr;
			}
		}elsif($li[$li_i-1] ne $tag || $li_attr[$li_i-1] ne $attr){
			if($li[$li_i-1] eq "dl"){
				$list .= "</dd>\n";
			}else{
				$list .= "</li>\n";
			}
			$list .= "</$li[$li_i-1]>\n<$tag$attr>\n";
			$li[$li_i-1] = $tag;
			$li_attr[$li_i-1] = $attr;
		}elsif($tag eq "dl"){
			$list .= "</dd>\n";
		}else{
			$list .= "</li>\n";
		}

		if($tag eq "dl"){
			$list .= "<dt>$term</dt>\n<dd>$line\n";
		}else{
			$list .= "<li>$line\n";
		}
	}
	if($p){
		$list .= "</p>\n";
		$p = 0;
	}
	while(--$li_i >= 0){
		if($li[$li_i] eq "dl"){
			$list .= "</dd>\n";
		}else{
			$list .= "</li>\n";
		}
		$list .= "</$li[$li_i]>\n";
	}

	# Inline perl code
	$list =~ s/``(.*?)``(?!`)/$1/eeg;
	# Discard none characters
	$list =~ y/\x00//d;

	return $list;
}

sub create_table{
	my @lines = split /\n/, shift;
	my $id = "";
	my $title = "";
	my $caption = "";
	my $thead = "";
	my $tfoot = "";
	my $tbodies = "";
	my $tbody = "";

	foreach(@lines){
		my $end = substr $_, -1;
		if(m/^!(!)?[ \t](.*[ \t])?(!)?!$/){
			my $inc_lot = $1 eq "" ? 1 : 0;
			my $del_punct_from_title = $3 eq "" ? 1 : 0;
			(my $line = $2) =~ s/^[ \t]+|[ \t]+$//g;
			next if($line eq "");
			$caption .= "\n" if($caption ne "");
			$caption .= $line;
			if($inc_lot && $id eq ""){
				$line =~ s/[`~!@#\$%^&*-_=+\\|;:,.\/?]+$//
					if($del_punct_from_title);
				if($line ne ""){
					$id = convert_page_name("table $line");
					my $j = $tabs_n{$id}++;
					if($j > 0){
						$id .= $j + 1;
						$tabs_n{$id}++;
					}
					$title = $line;
				}
			}
		}elsif($end eq "^"){
			$thead .= create_table_row($_);
		}elsif($end eq "!"){
			$tfoot .= create_table_row($_);
		}else{
			$_ = substr $_, 0, length($_) - 1 if($end eq "_");
			$tbody .= create_table_row($_);
			if($end eq "_" && $tbody ne ""){
				$tbody = update_table_rowspan($tbody);
				$tbodies .= "<tbody>\n$tbody</tbody>\n";
				$tbody = "";
			}
		}
	}
	if($tbody ne ""){
		$tbody = update_table_rowspan($tbody);
		$tbodies .= "<tbody>\n$tbody</tbody>\n";
	}

	my $table = "";
	return $table if($caption eq "" && $thead eq "" && $tbodies eq "" &&
		$tfoot eq "");

	$thead = update_table_rowspan($thead);
	$tfoot = update_table_rowspan($tfoot);

	my $tab = "";
	if($id eq ""){
		$table = "<table>\n";
	}else{
		$tabs{$id} = ++$tab_no;
		$tab = "$TABLE_NUMBER_PREFIX$tab_no$TABLE_NUMBER_SUFFIX";
		$table = "<table id=\"$id\">\n";
		my $enc_id = encode_url($id);
		$lot .= "<li><a href=\"#$enc_id\">$tab$title</a></li>\n";
	}
	$table .= "<caption>$tab$caption</caption>\n" if($caption ne "");
	$table .= "<thead>\n$thead</thead>\n" if($thead ne "");
	$table .= $tbodies if($tbodies ne "");
	$table .= "<tfoot>\n$tfoot</tfoot>\n" if($tfoot ne "");
	$table .= "</table>\n";

	# Inline perl code
	$table =~ s/``(.*?)``(?!`)/$1/eeg;
	# Discard none characters
	$table =~ y/\x00//d;

	return $table;
}

sub create_table_row{
	my $row = shift;

	$row =~ s/(!+)$/@{["|" x length($1)]}/;

	# Empty cells
	$row =~ s#([|^])[ \t]+([|^]*)(?=[|^](?:[ \t]|$))#@{[create_table_cell($1, $2)]}#g;
	# Non-empty cells
	$row =~ s#([|^])[ \t]([ \t]*)([^ \t].*?)([ \t]*)[ \t]([|^]*)(?=[|^](?:[ \t]|$)|<t[hd] )#@{[create_table_cell($1, $5, $2, $3, $4)]}#g;
	$row =~ s/[|^]$//;

	return "<tr>$row</tr>\n";
}

sub create_table_cell{
	my ($type, $colspan, $left, $content, $right) = @_;

	$type = $type eq "^" ? "th" : "td";
	$colspan = length($colspan) + 1;
	$left = length($left);
	$right = length($right);

	$colspan = $colspan == 1 ? "" : qq( colspan="$colspan");
	my $align = $left == 0 ? "left" : ($right == 0 ? "right" : "center");
	return qq(<$type$colspan class="text-$align">$content</$type>);
}

sub update_table_rowspan{
	my $rows = shift;

	(my $rowspan = $rows) =~ s#</?tr>##g;
	$rowspan =~ s#<(t[hd]) [^>]+>\.\.\.</\1>#+#g;
	$rowspan =~ s#<(t[hd]) [^>]+>.*?</\1>#1#g;
	# $rowspan example:
	# 111
	# 1++
	# 11+

	my @rs = split /\n/, $rowspan;
	# Only one row
	return $rows if($#rs == 0);

	# The first row cannot be spanned from above.
	$rs[0] = "1" x length($rs[0]);
	# No row spans
	return $rows if(index(join("\n", @rs), "+") == -1);

	my @counts;
	for my $i (0..$#rs){
		my $c = 0;
		$counts[$i][$c++] = $_ foreach(split //, $rs[$i]);
	}
	# Count the number of row spans.
	for my $i (0..($#rs-1)){
		for my $c (0..$#{$counts[$i]}){
			last if($counts[$i][$c] eq "+");
			for my $j (($i+1)..$#rs){
				last if($counts[$j][$c] ne "+");
				$counts[$i][$c]++;
			}
		}
	}

	# Make it easy to replace back </th> and </td> later.
	# \x01-\x03 have already been converted to &amp;, &lt;, and &gt;.
	$rows =~ s#</th>#\x01\x03#g;
	$rows =~ s#</td>#\x02\x03#g;

	my @cells;
	my @rows = split /\n/, $rows;
	for my $i (0..$#rows){
		my $c = 0;
		$cells[$i][$c++] = $_ foreach(split /\x03/, $rows[$i]);
	}

	for my $i (0..$#rs){
		for my $c (0..$#{$counts[$i]}){
			if($counts[$i][$c] > 1){
				$cells[$i][$c] =~ s/(<t[hd])(?=[> ])/$1 rowspan="$counts[$i][$c]"/;
			}elsif($counts[$i][$c] eq "+"){
				$cells[$i][$c] =~ s/<t[hd][> ].*[\x01\x02]//;
			}
		}
	}

	$rows = "";
	for my $i (0..$#rs){
		$rows .= join("", @{$cells[$i]})."\n";
	}
	$rows =~ s#\x01#</th>#g;
	$rows =~ s#\x02#</td>#g;

	return $rows;
}

sub create_figure{
	my @lines = split /\n/, shift;
	my $id = "";
	my $title = "";
	my $content = "";
	my $figcaption = "";
	my $figure = "";

	foreach(@lines){
		if(m/^"(!)?[ \t](.*[ \t])?(!)?"$/){
			my $inc_lof = $1 eq "" ? 1 : 0;
			my $del_punct_from_title = $3 eq "" ? 1 : 0;
			(my $line = $2) =~ s/^[ \t]+|[ \t]+$//g;
			next if($line eq "");
			$figcaption .= "\n" if($figcaption ne "");
			$figcaption .= $line;
			if($inc_lof && $id eq ""){
				$line =~ s/[`~!@#\$%^&*-_=+\\|;:,.\/?]+$//
					if($del_punct_from_title);
				if($line ne ""){
					$id = convert_page_name("figure $line");
					my $j = $figs_n{$id}++;
					if($j > 0){
						$id .= $j + 1;
						$figs_n{$id}++;
					}
					$title = $line;
				}
			}
		}else{
			my $line = substr $_, 2, length($_) - 4;
			$line =~ s/^[ \t]+|[ \t]+$//g;
			next if($line eq "");
			$content .= " " if($content ne "");
			$content .= $line;
		}
	}

	return $figure if($content eq "" && $figcaption eq "");

	my $fig = "";
	if($id eq ""){
		$figure = "<figure>\n";
	}else{
		$figs{$id} = ++$fig_no;
		$fig = "$FIGURE_NUMBER_PREFIX$fig_no$FIGURE_NUMBER_SUFFIX";
		$figure = "<figure id=\"$id\">\n";
		my $enc_id = encode_url($id);
		$lof .= "<li><a href=\"#$enc_id\">$fig$title</a></li>\n";
	}
	$figure .= "$content\n" if($content ne "");
	$figure .= "<figcaption>$fig$figcaption</figcaption>\n"
		if($figcaption ne "");
	$figure .= "</figure>\n";

	# Inline perl code
	$figure =~ s/``(.*?)``(?!`)/$1/eeg;
	# Discard none characters
	$figure =~ y/\x00//d;

	return $figure;
}

sub close_paragraph{
	if($p){
		$text .= "</p>\n";
		$p = 0;
	}
}

sub process_child_block{
	# return undef to skip to the next line
	# return the current line for further processing
	local $_ = shift;

	# Child block
	if(!$asis && !m/^[%#]/ && "(((" eq substr $_, -3){
		# Process the first line later
		$child_block = (substr $_, 0, length($_) - 3)."\n";
		return;
	}
	# Process child block
	if($child_block ne ""){
		if(")))" eq substr($_, 0, 3) && "_" ne substr($_, 3, 1)){
			my $block = $child_block.substr($_, 3);
			$child_block = "";
			$_ = create_child_block($block);
		}else{
			$child_block .= "$_\n";
			return;
		}
	}

	return $_;
}

sub preprocess_line{
	# return undef to skip to the next line
	# return the current line for further processing
	local $_ = shift;

	# Apply regular expressions if not asis
	if(!$asis && m/^(?!#(?:no)?regex)/){
		for(my $i = $re_start; $i < $re_n; $i++){
			if(m/^(?!#(?:no)?regex)/){
				eval "s\x1e$re[$i]\x1e$re_sub[$i]\x1eg;";
			}
		}
		if(m/\n/){
			local $re_start = $re_n;
			$text .= parse($_, @parse_line)
				foreach(split /\n/, $_, -1);
			return;
		}
	}
	# Wiki but not asis
	if($wiki && !$asis){
		# Skip admin code
		return if("##" eq substr $_, 0, 2);
		# Escape inline perl code
		s/``(.*?)``(?!`)/`\x00`$1`\x00`/g;
	}
	# Process code block
	if($code_block ne ""){
		if($_ eq "##}"){
			my $block = "$code_block}";
			$code_block = "";
			run_code_block($block);
		}else{
			$code_block .= "$_\n";
		}
		return;
	}

	return $_;
}

sub process_syntax_block{
	# return undef to skip to the next line
	# return the current line for further processing
	local $_ = shift;

	# Process syntax block
	if($syntax_block ne ""){
		if("))" eq substr($_, 0, 2) && "_" ne substr($_, 2, 1)){
			my $block = $syntax_block.substr($_, 2);
			$syntax_block = "";
			$_ = create_syntax_block($block);
		}else{
			$syntax_block .= "$_\n";
			return;
		}
	}

	return $_;
}

sub process_asis_lines{
	# return undef to skip to the next line
	# return the current line for further processing
	local $_ = shift;

	# Start or close nosyntax
	if(m/^("""+)$/ && (!$nosyntax || $nosyntax == length($1))){
		if($nosyntax){
			$asis = 0;
			$nosyntax = 0;
		}else{
			$_->() foreach(@close_all_open);
			$asis = 1;
			$nosyntax = length($1);
		}
		return;
	}
	# Inside nosyntax
	if($nosyntax){
		s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g; s/\x00//g;
		$text .= "$_\n";
		return;
	}
	# Start or close pre
	if(m/^(---+)(?:\[(.*)\])?$/ && (!$pre || ($pre == length($1) &&
				($2 eq "" || $pre_code eq $2)))){
		if($pre){
			chomp $text;
			if($pre_code eq ""){
				$text .= "</pre>\n";
			}else{
				$text .= "</code></pre>\n";
				$pre_code = "";
			}
			$asis = 0;
			$pre = 0;
		}else{
			$_->() foreach(@close_all_open);
			if($2 eq ""){
				$text .= "<pre>";
			}else{
				$text .= qq(<pre><code class="language-$2">);
				$pre_code = $2;
			}
			$asis = 1;
			$pre = length($1);
		}
		return;
	}
	# Inside pre
	if($pre){
		s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g; s/\x00//g;
		$text .= "$_\n";
		return;
	}

	return $_;
}

sub skip_comment{
	# return undef to skip to the next line
	# return the current line for further processing
	local $_ = shift;

	# Skip comment
	return if("%" eq substr $_, 0, 1);

	return $_;
}

sub process_wiki_command{
	# return undef to skip to the next line
	# return the current line for further processing
	local $_ = shift;

	# Register regular expressions
	if(m/^#regex (.)(.+)(?<!\\)\1(.*)(?<!\\)\1$/){
		# Don't allow code embedding in a wiki page
		return if($wiki && (index($2, '(?{') != -1 ||
				    index($2, '(??{') != -1 ||
				    index($3, '@{[') != -1));

		my $i;
		for($i = 0; $i < $re_n; $i++){
			last if($re[$i] eq $2);
		}
		$re[$re_n++] = $2 if($i == $re_n);
		$_ = $3;
		# Treat a single backslash as an escape character.
		s/\\(?![\\a-zA-Z0-9])/\x00/g;
		# Don't allow access to variables.
		s/([\$@%\[\]])/\\\1/g;
		$re_sub[$i] = $_;
		return;
	}
	# Clear regular expressions
	if(m/^#noregex(?:| (.)(.+)(?<!\\)\1)$/){
		if($2 eq ""){
			$re_n = 0;
			$#re = $#re_sub = -1;
		}else{
			for(my $i = 0; $i < $re_n; $i++){
				if($re[$i] eq $2){
					$re_n--;
					for(; $i < $re_n; $i++){
						$re[$i] = $re[$i+1];
						$re_sub[$i] = $re_sub[$i+1];
					}
					$#re = $#re_sub = $re_n-1;
					last;
				}
			}
		}
		return;
	}
	# Output verbose html code
	if(m/^#html (.+)$/){
		$text .= "$1\n";
		return;
	}
	# Table of contents
	if("#notoc" eq $_){
		$notoc = 1;
		return;
	}
	# List of tables
	if("#lot" eq $_){
		$nolot = 0;
		return;
	}
	# List of figures
	if("#lof" eq $_){
		$nolof = 0;
		return;
	}

	return $_;
}

sub process_nonwiki_command{
	# return undef to skip to the next line
	# return the current line for further processing
	local $_ = shift;

	# Include another Uniqki file
	if(m/^##include (.+)$/){
		local *FH;
		if(open FH, $1){
			my $line = <FH>;
			my $inc_wiki = 0;
			if($line eq "#!wiki\n"){
				$inc_wiki = 1 unless($wiki);
			}else{
				$text .= parse($line, @parse_line);
			}
			local $wiki = 1 if($inc_wiki);
			$text .= parse($_, @parse_line) while(<FH>);
			close FH;
		}
		return;
	}
	# Shell command
	if(m/^##shell (.+)$/){
		$text .= `$1`;
		return;
	}
	# Perl subroutine or code
	if(m/^##((?:sub |{).*)$/){
		if("}" eq substr $1, -1){
			eval $1;
			return;
		}
		$code_block = "$1\n";
		return;
	}

	return $_;
}

sub skip_unknown_command{
	# return undef to skip to the next line
	# return the current line for further processing
	local $_ = shift;

	# Ignore other lines starting with #
	return if("#" eq substr $_, 0, 1);

	return $_;
}

sub start_syntax_block{
	# return undef to skip to the next line
	# return the current line for further processing
	local $_ = shift;

	# Syntax block
	if("((" eq substr $_, -2){
		# Process the first line later
		$syntax_block = (substr $_, 0, length($_) - 2)."\n";
		return;
	}

	return $_;
}

sub process_collected_lines{
	# return undef to skip to the next line
	# return the current line for further processing
	local $_ = shift;

	# Close blockquote
	if($blockquote ne "" && !(m/^((?:  ){0,})(>[ \t])?/ && "$1$2" ne "")){
		close_paragraph();
		$text .= create_blockquote($blockquote);
		$blockquote = "";
	}
	# Close list
	if($list ne "" && !(m/^((?:  ){0,})((?:[*+-]|: .*?:)[ \t])?/ &&
			"$1$2" ne "")){
		close_paragraph();
		$text .= create_list($list);
		$list = "";
	}
	# Close table
	if($table ne "" &&
		!m/^(?:!!?[ \t](?:.*[ \t])?!?!|[|^][ \t](?:.*[ \t])?(?:[!^]+|\|+_?))$/){
		close_paragraph();
		$text .= create_table($table);
		$table = "";
	}
	# Close figure
	if($figure ne "" &&
		!m/^(?:"!?[ \t](?:.*[ \t])?!?"|@[ \t](?:.*[ \t])?@)$/){
		close_paragraph();
		$text .= create_figure($figure);
		$figure = "";
	}

	return $_;
}

sub process_paragraph_break{
	# return undef to skip to the next line
	# return the current line for further processing
	local $_ = shift;

	if("" eq $_ || m/^___+$/){
		# Close the current paragraph or draw a horizontal line
		close_paragraph();
		# Horizontal line
		$text .= "<hr />\n" if($_ ne "");
		return;
	}

	return $_;
}

sub escape_inline_syntax{
	# return undef to skip to the next line
	# return the current line for further processing
	local $_ = shift;
	s#([`"/*'_!\[{<-]|[a-z]+://)#\x00$1#gi;
	return $_;
}

sub process_inline_syntax{
	# return undef to skip to the next line
	# return the current line for further processing
	# \x00: escape character
	# \x01: &
	# \x02: <
	# \x03: >
	# \x04: temporary character
	local $_ = shift;

	# Convert escaped [&<>] to \x01, \x02, and \x03
	s/\x00&/\x01/g; s/\x00</\x02/g; s/\x00>/\x03/g;

	# Escape inline syntax. \x00[&<>] may be generated.
	s/""(.)(.*?)\1""/@{[parse($2, @escape_inline_syntax)]}/g;

	# Convert \x00[&<>] from escaped inline syntax to \x04[&<>]
	s/\x00([&<>])/\x04$1/g;
	# Restore escaped [&<>] from the text
	s/\x01/\x00&/g; s/\x02/\x00</g; s/\x03/\x00>/g;
	# Restore escaped [&<>] from escaped inline syntax
	s/\x04&/\x00\x01/g; s/\x04</\x00\x02/g; s/\x04>/\x00\x03/g;
	# Regular [&<>] should not be translated to html codes at this point
	# because page names and links will be affected.  Instead, flag them so
	# that they can be converted to html later.  This flagging does not
	# apply to escaped characters (\x00[&<>]).  Escaped characters may come
	# from the #regex syntax to enter [&<>] as is without converting them
	# to &amp, &lt, and &gt.
	s/(?<!\x00)&/\x01/g; s/(?<!\x00)</\x02/g; s/(?<!\x00)>/\x03/g;

	# Pages
	s#\[\[(.*?)(?:\#(.*?))?(?:\|(.*?))?\]\]#@{[link_page($1, $2, $3)]}#g;
	# Images
	s#\{\{\{(.*?)(?:\|(.*?))?}}}(?:\[(.*?)\])?#@{[link_image($1, $2, $3)]}#g;
	# Files
	s#\{\{(.*?)(?:\|(.*?))?}}#@{[link_file($1, $2)]}#g;
	# URL images
	s#\x02\x02\x02(.*?)(?:\|(.*?))?\x03\x03\x03(?:\[(.*?)\])?#@{[link_url_image($1, $2, $3)]}#g;
	# URLs
	s#\x02\x02(.*?)(?:\|(.*?))?\x03\x03#@{[link_url($1, $2)]}#g;
	# Text styles
	# Avoid conflicts with //italic//
	s#([a-z]+:/)(/)#$1\x00$2#gi;
	s#//(.*?)//#<i>$1</i>#g;
	s#([a-z]+:/)\x00(/)#$1$2#gi;
	s#\*\*(.*?)\*\*#<b>$1</b>#g;
	s#''(.*?)''(?:\[(.*?)\])?#@{[$2 eq "" ? "<code>$1</code>" : qq(<code class="language-$2">$1</code>)]}#g;
	s#--(.*?)--#<s>$1</s>#g;
	s#__(.*?)__#<u>$1</u>#g;
	s#\!\!(.*?)\!\!#<mark>$1</mark>#g;
	# Protect protocols inside tags
	s#<([^>]*(?:[a-z]+://)[^>]*)>#<@{[protect_urls($1)]}>#gi;
	# Protect protocols outside tags
	s#(<a [^>]*>)([^<]*(?:[a-z]+://)[^<]*)(</a>)#$1@{[protect_urls($2)]}$3#gi;
	# Translate non-protected protocols to links
	s#(?<![a-zA-Z\x00])((?:[a-z]+://)[\x01$url_char]+\x01[a-z]+;)(?=(?:[ \t]|$))#<a class="auto-title" href="\x00$1">\x00$1</a>#ogi;
	s#(?<![a-zA-Z\x00])((?:[a-z]+://)[\x01$url_char]+)(?=[$url_punct](?:[ \t]|$))#<a class="auto-title" href="\x00$1">\x00$1</a>#ogi;
	s#(?<![a-zA-Z\x00])((?:[a-z]+://)[\x01$url_char]+)#<a class="auto-title" href="\x00$1">\x00$1</a>#ogi;
	s/\x01/&amp;/g; s/\x02/&lt;/g; s/\x03/&gt;/g;

	return $_;
}

sub collect_lines{
	# return undef to skip to the next line
	# return the current line for further processing
	local $_ = shift;

	# Collect quote lines
	if(m/^((?:  ){0,})(&gt;[ \t])?/ && "$1$2" ne "" &&
		"$2$blockquote" ne ""){
		$blockquote .= "$_\n";
		return;
	}
	# Collect list lines
	if(m/^((?:  ){0,})((?:[*+-]|: .*?:)[ \t])?/ && "$1$2" ne "" &&
		"$2$list" ne ""){
		$list .= "$_\n";
		return;
	}
	# Collect table lines
	if(m/^(?:!!?[ \t](?:.*[ \t])?!?!|[|^][ \t](?:.*[ \t])?(?:[!^]+|\|+_?))$/){
		$table .= "$_\n";
		return;
	}
	# Collect figure lines
	if(m/^(?:"!?[ \t](?:.*[ \t])?!?"|@[ \t](?:.*[ \t])?@)$/){
		$figure .= "$_\n";
		return;
	}

	return $_;
}

sub process_line_syntax{
	# return undef to skip to the next line
	# return the current line for further processing
	local $_ = shift;

	# Heading
	if(m/^(=+)!? (.*)$/ && length($1) <= 6){
		my $i = length($1);
		my $inc_toc = "!" ne substr $_, $i, 1 ? 1 : 0;
		$_ = $2;
		# Inline perl code
		s/``(.*?)``(?!`)/$1/eeg;
		s/^[ \t]+|[ \t]+$//g;
		# Discard none characters
		y/\x00//d;
		close_paragraph();
		if($i == 1){
			if($TITLE eq ""){
				$TITLE = $_;
				$TITLE =~ s/<[^>]*>//g;
			}
			$text .= qq(<h$i>$_</h$i>\n);
			return;
		}elsif(!$inc_toc){
			$text .= qq(<h$i>$_</h$i>\n);
			return;
		}

		(my $title = $_) =~ s/<[^>]*>//g;
		my $id = $title;
		$id =~ s/&amp;/&/g; $id =~ s/&lt;/</g; $id =~ s/&gt;/>/g;
		$id = convert_page_name($id);
		my $j = $h_n{$id}++;
		if($j > 0){
			$id .= $j + 1;
			$h_n{$id}++;
		}

		$secs_no{$i}++;
		for($j = $i + 1; $j <= 6; $j++){
			$secs_no{$j} = 0;
		}

		my $sec = "";
		for($j = 2; $j <= $i; $j++){
			next unless($secs_no{$j});
			$sec .= $SECTION_NUMBER_SEPARATOR if($sec ne "");
			$sec .= $secs_no{$j};
		}
		$h_secs{$id} = $sec;
		$sec = "$SECTION_NUMBER_PREFIX$sec$SECTION_NUMBER_SUFFIX";

		$text .= "\x05" if($toc eq "");
		$text .= qq(<h$i id="$id">$sec$_</h$i>\n);

		if($i > $h_prev){
			if($h_prev){
				$toc .= "<li><ul>" while($h_prev++ < $i);
				$h_prev--;
			}else{
				$toc .= "<li><ul>" while(++$h_prev < $i);
				$h_top = $i;
			}
			$toc .= "\n";
		}elsif($i < $h_prev){
			$toc .= "</ul></li>" while(--$h_prev >= $i);
			$toc .= "\n";
			$h_prev++;
			$h_top = $i if($i < $h_top);
		}
		my $enc_id = encode_url($id);
		$toc .= "<li><a href=\"#$enc_id\">$sec$title</a></li>\n";
		return;
	}

	return $_;
}

sub start_paragraph{
	# return undef to skip to the next line
	# return the current line for further processing
	local $_ = shift;

	# Start a new paragraph
	if(!$p){
		$text .= "<p>";
		$p = 1;
	}

	return $_;
}

sub postprocess_line{
	# return undef to skip to the next line
	# return the current line for further processing
	local $_ = shift;

	# Handle <p> tags around syntax blocks
	s#(\x06)#</p>$1<p>#g;
	# Inline perl code
	s/``(.*?)``(?!`)/$1/eeg;
	# Discard none characters
	y/\x00//d;

	return $_;
}

sub close_all_open{
	if($child_block ne ""){
		my $block = $child_block;
		$child_block = "";
		local $_ = create_child_block($block);
		$text .= parse($_, @parse_line);
	}
	if($code_block ne ""){
		my $block = "$code_block}";
		$code_block = "";
		run_code_block($block);
	}
	if($syntax_block ne ""){
		my $block = $syntax_block;
		$syntax_block = "";
		local $_ = create_syntax_block($block);
		$text .= parse($_, @parse_line);
	}
	if($nosyntax){
		$asis = 0;
		$nosyntax = 0;
	}
	if($pre){
		chomp $text;
		if($pre_code eq ""){
			$text .= "</pre>\n";
		}else{
			$text .= "</code></pre>\n";
			$pre_code = "";
		}
		$asis = 0;
		$pre = 0;
	}
	if($blockquote ne ""){
		$text .= create_blockquote($blockquote);
		$blockquote = "";
	}
	if($list ne ""){
		$text .= create_list($list);
		$list = "";
	}
	if($table ne ""){
		$text .= create_table($table);
		$table = "";
	}
	if($figure ne ""){
		$text .= create_figure($figure);
		$figure = "";
	}
	close_paragraph();
}

################################################################################
# User-replaceable subroutines
sub verify_input{
	# return 1 if OK
	# return 0 otherwise
	my ($query, $var) = @_;
	if($query eq "comment"){
		return 0 if($$var{website} ne "" || $$var{id} >= time - 15);
		(my $text = $$var{text}) =~ s/[`~!@#\$%^&*_=+\\|;:'",.\/?()\[\]{}<>0-9-]//g;
		$text =~ s/[ \t\n]+/ /g;
		$text =~ s/^ | $//g;
		return 0 if($text eq "");

		$$var{text} =~ s/^[ \t\n]+|[ \t\n]+$//g;
	}
	return 1;
}

sub begin_parsing{
	my $block_level = shift;

	$url_char = 'a-zA-Z0-9:@/~%.,_$?=&;#+-';
	$url_punct = '.,;:!?';

	$text = "";

	$child_block = "";
	$code_block = "";
	$syntax_block = "";
	@parsed_blocks = ();
	$p = 0;
	$asis = 0;
	$nosyntax = 0;
	$pre = 0;
	$pre_code = "";
	$blockquote = "";
	$list = "";
	$table = "";
	$figure = "";

	if(!$block_level){
		$re_start = 0;
		$re_n = 0;
		@re = ();
		@re_sub = ();
		%h_n = ();
		$h_top = 0;
		$h_prev = 0;
		%h_secs = ();
		%secs_no = ();
		$toc = "";
		$notoc = 0;
		$tab_no = 0;
		%tabs_n = ();
		%tabs = ();
		$lot = "";
		$nolot = 1;
		$fig_no = 0;
		%figs_n = ();
		%figs = ();
		$lof = "";
		$nolof = 1;
	}
}

sub parse_line{
	# \x00: none or escape character
	# \x01-\x04: temporary characters
	# \x05: place holder for TOC
	# \x06: place holder for a parsed block
	# \x1e: delimiter
	# %comment
	# #wiki command
	# ##non-wiki command
	# ``inline perl code``
	local $_ = shift;
	y/\n//d;

	foreach my $parser (
		@process_child_block,
		@preprocess_line,
		@process_syntax_block,
		@process_asis_lines,
		@skip_comment,
		@process_wiki_command,
		@process_nonwiki_command,
		@skip_unknown_command,
		@start_syntax_block,
		@process_collected_lines,
		@process_paragraph_break,
		@process_inline_syntax,
		@collect_lines,
		@process_line_syntax,
		@start_paragraph,
		@postprocess_line){
		$_ = $parser->($_);
		return unless defined;
	}

	return "$_\n";
}

sub end_parsing{
	my $block_level = shift;

	$_->() foreach(@close_all_open);
	if(!$block_level){
		$text = "\x05$text" unless($text =~ m/\x05/);
		if(!$notoc && $toc ne ""){
			my $i = $h_prev;
			$toc = "<ul class=\"toc-list\">\n$toc";
			$toc .= "</ul></li>" while(--$h_prev>0);
			$toc .= ($i > 1 ? "\n" : "")."</ul>\n";
			for(my $i = 0; $i < $h_top - 1; $i++){
				$toc =~ s#^(.*\n)<li><ul>#\1#;
				$toc =~ s#</ul></li>(\n.*)$#\1#;
			}
			$toc =~ s#</li>\n<li>(<ul>)#\n\1#g;
			$toc =~ s#\n+#\n#g;
			my $heading = get_msg("table_of_contents");
			$toc = "<div id=\"toc\">\n".
				"<div class=\"toc-heading\">$heading</div>\n".
				"$toc</div>\n";
			$text =~ s/(\x05)/$toc$1/g;
		}
		foreach(keys %h_secs){
			my $enc_id = encode_url($_);
			my $sec = $h_secs{$_};
			$text =~ s/(<a class="auto-title" href="#$enc_id">)[^<]*(<\/a>)/\1$SECTION_REFERENCE_PREFIX$sec$SECTION_REFERENCE_SUFFIX\2/g;
		}
		if(!$nolot && $lot ne ""){
			my $heading = get_msg("list_of_tables");
			$lot = "<div id=\"lot\">\n".
				"<div class=\"lot-heading\">$heading</div>\n".
				"<ul class=\"lot-list\">\n$lot</ul>\n</div>\n";
			$text =~ s/(\x05)/$lot$1/g;
		}
		foreach(keys %tabs){
			my $enc_id = encode_url($_);
			my $tab = $tabs{$_};
			$text =~ s/(<a class="auto-title" href="#$enc_id">)[^<]*(<\/a>)/\1$TABLE_REFERENCE_PREFIX$tab$TABLE_REFERENCE_SUFFIX\2/g;
		}
		if(!$nolof && $lof ne ""){
			my $heading = get_msg("list_of_figures");
			$lof = "<div id=\"lof\">\n".
				"<div class=\"lof-heading\">$heading</div>\n".
				"<ul class=\"lof-list\">\n$lof</ul>\n</div>\n";
			$text =~ s/(\x05)/$lof$1/g;
		}
		foreach(keys %figs){
			my $enc_id = encode_url($_);
			my $fig = $figs{$_};
			$text =~ s/(<a class="auto-title" href="#$enc_id">)[^<]*(<\/a>)/\1$FIGURE_REFERENCE_PREFIX$fig$FIGURE_REFERENCE_SUFFIX\2/g;
		}

		$re_start = 0;
		$re_n = 0;
		@re = ();
		@re_sub = ();
		%h_n = ();
		$h_top = 0;
		$h_prev = 0;
		%h_secs = ();
		%secs_no = ();
		$toc = "";
		$notoc = 0;
		$tab_no = 0;
		%tabs_n = ();
		%tabs = ();
		$lot = "";
		$nolot = 1;
		$fig_no = 0;
		%figs_n = ();
		%figs = ();
		$lof = "";
		$nolof = 1;
	}
	$text =~ y/\x05//d;
	my $i = 0;
	$text =~ s/\x06/@{[$parsed_blocks[$i++]]}/g;
	@parsed_blocks = ();
	$text =~ y/\x06//d;
	$text =~ s#<([ibsu]|code|mark)>([ \t\n]*)</\1>#$2#g;
	$text =~ s#[ \t\n]*(<(?:p|li|dd)>)[ \t\n]*#\n$1#g;
	$text =~ s#[ \t\n]*(</(?:p|li|dd)>)[ \t\n]*#$1\n#g;
	$text =~ s#<p></p>\n##g;
	$text =~ s#^\n+|\n+$##g;
}

################################################################################
# Clean up
END{
	while(my $file = each %locked_files){
		unlock_file($file);
	}
}

if($PAGE eq $CGI && $FILE ne ""){
################################################################################
# u/u/.../PAGE?ACTION	Called from a secured site
	die_redirect("$HTTP_BASE$SCRIPT_NAME/$FILE?$QUERY_STRING");
}

$PAGE = convert_page_name($PAGE);
die_message("page_not_allowed", $PAGE)
	if($PAGES_NOT_ALLOWED ne "" && $PAGE =~ m/$PAGES_NOT_ALLOWED/o);

################################################################################
# Login, logout
if($QUERY_STRING eq "logout"){
#-------------------------------------------------------------------------------
# u/PAGE?logout		Logout
	close_session();
	die_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE");
}elsif($QUERY_STRING eq "logout_all"){
#-------------------------------------------------------------------------------
# u/PAGE?logout_all	Logout from all computers
	clear_user_sessions();
	die_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE");
}

clear_expired_sessions();
handle_session();

if(!is_logged_in()){
if($QUERY_STRING eq "login"){
	if($REQUEST_METHOD eq "GET"){
#-------------------------------------------------------------------------------
# u/PAGE?login		GET login request: Login form
		print_login();
		die;
	}else{
#-------------------------------------------------------------------------------
# u/PAGE?login		POST login request: Check credentials
		my %var = get_var();
		authenticate_user($var{user}, $var{pw}, $var{logout_others});
	}
}elsif($QUERY_STRING eq "loginout"){
#-------------------------------------------------------------------------------
# u?loginout		Loginout
# u/PAGE?loginout	Loginout
	die_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE?login");
}
}elsif($QUERY_STRING eq "loginout"){
#-------------------------------------------------------------------------------
# u?loginout		Loginout
# u/PAGE?loginout	Loginout
	die_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE?logout");
}

{
#-------------------------------------------------------------------------------
# Is this page wiki?
	my $page;
	local *FH;
	if($PAGE eq "" && ($QUERY_STRING eq "login" || $QUERY_STRING eq "")){
		$page = $INDEX_PAGE;
	}else{
		$page = $PAGE;
	}
	$wiki = 0;
	if($page ne ""){
		if(-f "$page.txt"){
			open FH, "$page.txt";
			$wiki = 1 if(<FH> eq "#!wiki\n");
			close FH;
		}elsif($WIKI_PAGES_ALLOWED ne "" &&
			$page =~ m/$WIKI_PAGES_ALLOWED/o){
			$wiki = 1;
		}
	}
}

if($QUERY_STRING eq "css"){
#-------------------------------------------------------------------------------
# u?css			Print CSS
# u/PAGE?css		Print CSS
	print_css(2);
	die;
}elsif($QUERY_STRING eq "js"){
#-------------------------------------------------------------------------------
# u?js			Print JavaScript
# u/PAGE?js		Print JavaScript
	print_js(2);
	die;
}elsif($QUERY_STRING eq "user_info"){
#-------------------------------------------------------------------------------
# u/PAGE?user_info	Print user information
	my $page_exists = page_exists();
	my $has_read_access = $page_exists && has_read_access() ? 1 : 0;
	my $has_write_access = $page_exists && has_write_access() ? 1 : 0;
	die_text("$USER:$admin:$has_read_access:$has_write_access");
}elsif($QUERY_STRING eq "forgot_password"){
#-------------------------------------------------------------------------------
# u?forgot_password		Forgot password
# u/PAGE?forgot_password	Forgot password
	if($REQUEST_METHOD eq "GET"){
		print_forgot_password();
		die;
	}

	my %var = get_var();
	if($var{user} eq "" && $var{email} eq ""){
		die_message("enter_username_or_email_address");
	}
	my ($user, $pw, $group, $email, $name, $token);
	$user = "";
	if($var{email} ne ""){
		if(!is_email_address($var{email})){
			die_message("check_email_address");
		}
		($user, $pw, $group, $email, $name, $token) =
			find_user_info_by_email_address($var{email});
		unless(defined $user){
			die_message("email_address_not_found", $var{email});
		}
		if($var{user} ne "" && $var{user} ne $user){
			die_message("user_info_mismatch");
		}
	}
	if($user eq ""){
		($user, $pw, $group, $email, $name, $token) =
			find_user_info($var{user});
		unless(defined $user){
			die_message("user_not_found", $var{user});
		}
	}

	die_message("user_blocked", $user) if($pw eq "blocked");
	die_message("password_reset_token_still_valid")
		if(is_password_reset_token_valid($token));

	$token = generate_password_reset_token($user);

	my $new_pw = "";
	my $token_added = 0;

	lock_file($PASSWORD_FILE);
	if(-f $PASSWORD_FILE){
		local *FH;
		open FH, $PASSWORD_FILE;
		while(<FH>){
			if(m/^$user:/){
				$token_added = 1;
				my @items = split /:/;
				$_ = "$user:$items[1]:$items[2]:$items[3]:$items[4]:$token\n";
			}
			$new_pw .= $_;
		}
		close FH;
	}elsif($adminpw =~ m/^$user:/){
		$token_added = 1;
		my @items = split /:/, $adminpw;
		$new_pw = "$user:$items[1]:$items[2]:$items[3]:$items[4]:$token\n";
	}

	# Something's wrong because a username already found does not exist.
	die_message("internal_errors") unless($token_added);

	my $link = "$HTTP_BASE$SCRIPT_NAME?reset_password=$token";
	my $subject = get_msg("reset_password_email_subject", $DOC_BASE);
	my $text = get_msg("reset_password_email_text", $var{user}, $DOC_BASE,
		$link, $RESET_PASSWORD_TIMEOUT);
	if(!send_email($email, $subject, $text)){
		die_message("email_notification_failed", $user, $email);
	}

	write_file($PASSWORD_FILE, $new_pw);
	unlock_file($PASSWORD_FILE);

	die_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE");
}elsif($QUERY_STRING eq "reset_password" && $REQUEST_METHOD eq "POST"){
#-------------------------------------------------------------------------------
# u?reset_password	Reset password
# u/PAGE?reset_password	Reset password
	my %var = get_var();
	die_message("invalid_password_reset_token")
		unless(is_password_reset_token_valid($var{token}));
	my ($user, $saved_pw, $group, $email, $name) =
		find_user_info_by_password_reset_token($var{token});
	die_message("password_reset_token_not_found") unless defined $user;

	if($var{pw} ne $var{pw2}){
		die_message("confirm_password");
	}
	unless(is_password($var{pw})){
		die_message("check_password");
	}

	my $new_pw = "";
	my $reset = 0;

	lock_file($PASSWORD_FILE);
	if(-f $PASSWORD_FILE){
		local *FH;
		open FH, $PASSWORD_FILE;
		while(<FH>){
			if(m/^$user:/){
				$reset = 1;
				my @items = split /:/;
				my $pw = hash_password($user, $var{pw});
				my $userline = "$user:$pw:$items[2]:$items[3]:$items[4]:\n";
				$_ = $userline;
			}
			$new_pw .= $_;
		}
		close FH;
	}
	# Password reset token cannot be found this time?
	die_message("internal_errors") unless($reset);

	write_file($PASSWORD_FILE, $new_pw);
	unlock_file($PASSWORD_FILE);

	die_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE");
}elsif($QUERY_STRING =~ m/^reset_password=([a-zA-Z0-9]{8}[0-9a-f]{40}\.([0-9]+))$/){
#-------------------------------------------------------------------------------
# u?reset_password=token	Reset password
# u/PAGE?reset_password=token	Reset password
	my $token = $1;
	my $expires = $2;

	my $time = time;
	if($time >= $expires){
		clear_password_reset_token($token);
		die_message("password_reset_token_expired");
	}

	local $PASSWORD_RESET_TOKEN = $token;
	print_reset_password();
	die;
}elsif($QUERY_STRING eq "manage_myself"){
#-------------------------------------------------------------------------------
# u?manage_myself	Manage myself
# u/PAGE?manage_myself	Manage myself
	print_manage_myself();
	die;
}elsif($QUERY_STRING eq "update_myself" && $REQUEST_METHOD eq "POST" && is_logged_in()){
#-------------------------------------------------------------------------------
# u?update_myself	Update myself
# u/PAGE?update_myself	Update myself
	my %var = get_var();
	if($var{pw} ne $var{pw2}){
		die_message("confirm_password");
	}
	if($var{pw} ne "" && !is_password($var{pw})){
		die_message("check_password");
	}
	if($var{pw} eq "" && $var{email} eq "" && $var{name} eq ""){
		die_message("enter_user_info_to_update");
	}

	my $new_pw = "";
	my $updated = 0;

	lock_file($PASSWORD_FILE);
	if(-f $PASSWORD_FILE){
		local *FH;
		open FH, $PASSWORD_FILE;
		while(<FH>){
			if(m/^$USER:/){
				$updated = 1;
				my @items = split /:/;
				my $pw = $var{pw} ne "" ?
					hash_password($USER, $var{pw}) :
					$items[1];
				my $group = $items[2];
				my $email = $var{email} ne "" ?
					$var{email} : $items[3];
				my $name = $var{name} ne "" ?
					$var{name} : $items[4];
				my $token = $items[5];
				# new line from $items[5]
				my $userline = "$USER:$pw:$group:$email:$name:$token";
				if($userline eq $_){
					close FH;
					die_message("enter_user_info_to_update", $USER);
				}
				$_ = $userline;
			}
			$new_pw .= $_;
		}
		close FH;
	}else{
		my @items = split /:/, $adminpw;
		if($USER ne $items[0]){
			# Something's wrong because you're the only user, but
			# the user line in this script is not you! How did you
			# login?
			die_message("internal_errors");
		}

		$updated = 1;
		my $pw = $var{pw} ne "" ? hash_password($USER, $var{pw}) :
			$items[1];
		my $group = $items[2];
		my $email = $var{email} ne "" ? $var{email} : $items[3];
		my $name = $var{name} ne "" ? $var{name} : $items[4];
		my $token = $items[5];
		# new line from $items[5]
		my $userline = "$USER:$pw:$group:$email:$name:$token";
		if($userline eq $adminpw){
			die_message("enter_user_info_to_update", $USER);
		}
		$new_pw = "$userline\n";
	}
	# How did you login when your username is not found?
	die_message("internal_errors") unless($updated);

	write_file($PASSWORD_FILE, $new_pw);
	unlock_file($PASSWORD_FILE);

	die_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE?manage_myself");
}elsif($QUERY_STRING eq "delete_myself" && $REQUEST_METHOD eq "POST" && is_logged_in()){
#-------------------------------------------------------------------------------
# u?delete_myself	Delete myself
# u/PAGE?delete_myself	Delete myself
	my $new_pw = "";
	my $deleted = 0;
	my $nadmins = 0;

	lock_file($PASSWORD_FILE);
	if(-f $PASSWORD_FILE){
		local *FH;
		open FH, $PASSWORD_FILE;
		while(<FH>){
			$nadmins++ if($admin && m/^(?:[^:]*:){2}admin:/);
			if(m/^$USER:/){
				$deleted = 1;
				next;
			}
			$new_pw .= $_;
		}
		close FH;
	}
	# How did you login when your username is not found?
	die_message("internal_errors") unless($deleted);

	# You cannot delete yourself when you are the only admin.
	die_message("cannot_delete_only_admin") if($nadmins == 1);

	clear_user_sessions($USER);

	write_file($PASSWORD_FILE, $new_pw);
	unlock_file($PASSWORD_FILE);

	die_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE");
}elsif(!has_read_access()){
#-------------------------------------------------------------------------------
# Read-secured
	die_message("read_secured");
################################################################################
# User actions
}elsif($QUERY_STRING eq "login" || $QUERY_STRING eq ""){
#-------------------------------------------------------------------------------
# u?login		After a successful login
# u/PAGE?login		After a successful login
# u/PAGE/FILE?login	After a successful login
# u			No action specified
# u/PAGE		No action specified
# u/PAGE/FILE		No action specified
	die_path("$PAGE/$FILE") if($FILE ne "" ||
		($PAGE ne "" && "/" eq substr $PATH_INFO, -1));
	die_redirect("$HTTP_BASE$SCRIPT_NAME/$INDEX_PAGE") if($PAGE eq "");
	unless(-f "$PAGE.txt"){
		my $msg_id = has_write_access() ?
			"create_page" : "page_not_found";
		die_message($msg_id, $PAGE);
	}
}elsif($QUERY_STRING ne "delete" && $FILE ne ""){
#-------------------------------------------------------------------------------
# u/PAGE/FILE		Show/download PAGE/FILE
	die_path("$PAGE/$FILE");
}elsif($QUERY_STRING =~ m/^goto(?:[&=].+)?$/){
#-------------------------------------------------------------------------------
# u?goto		Create the goto form
# u?goto=PAGE		Go to or create PAGE using a form (admin only)
	my %var = get_var();
	if($var{goto} eq ""){
		local $TITLE = get_msg("goto_form");
		print_header();
		create_goto_form(1);
		print_footer();
		die;
	}

	$_ = $var{goto};
	s#\.html$##;
	y#[/+]# #;

	die_redirect("$HTTP_BASE$SCRIPT_NAME/$_");
}elsif($QUERY_STRING eq "refresh" && $PAGE ne ""){
#-------------------------------------------------------------------------------
# u/PAGE?refresh	Refresh
	if(-f "$PAGE.txt"){
		$rebuild = 1;
	}else{
		my $msg_id = has_write_access() ?
			"create_page" : "page_not_found";
		die_message($msg_id, $PAGE);
	}
}elsif($QUERY_STRING =~ m/^diff(?:=(-?[0-9]+))?$/){
#-------------------------------------------------------------------------------
# u/PAGE?diff		Diff current and previous version
# u/PAGE?diff=([0-9]+)	Diff current and \1 version
# u/PAGE?diff=-([0-9]+)	Diff current and current-\1 version
	die_message("page_not_found", $PAGE) unless(-f "$PAGE.txt");

	my $current_version = get_version($PAGE);
	my $version = $1 > 0 ? $1 : $current_version + ($1 < 0 ? $1 : -1);

	if($version >= $current_version || $version <= 0){
		die_message("current_version", $PAGE, $current_version)
	}

	my $title = get_msg("differences", $PAGE, $version, $current_version);
	local $TITLE = $title;

	my $current_text = read_file("$PAGE.txt");

	my $text = $current_text;
	open FH, "$PAGE.txt.v"; local $/ = "\x00\n";
	while(<FH>){
		m/^([0-9]+):.*?\n(.*)\x00\n$/s;
		$text = patch($text, $2);
		last if($version == $1 - 1);
	}
	close FH;

	print_header();
	print qq(<div id="diff">\n<h1>$title</h1>\n);

	my @line0 = split /\n/, $text, -1; $#line0--;
	my @line1 = split /\n/, $current_text, -1; $#line1--;
	my ($s, @delta) = lcs(\@line0, \@line1);
	my $m = $s;
	my $n;
	for($n = 0; $n < $s; $n++){
		$_ = $line1[$n];
		s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g;
		print qq(<div class="diff-unchanged">= $_</div>\n);
	}
	eval "use Encode qw(decode);";
	my $encode = $@ ? 0 : 1;
	for(my $i = 0; $i <= $#delta; $i++, $m++, $n++){
		my ($x, $y) = split /,/, $delta[$i];
		if($x > $m && $y > $n){
			for(; $m < $x && $n < $y; $m++, $n++){
				print qq(<div class="diff-modified">* );
				my $l0 = $line0[$m];
				my $l1 = $line1[$n];
				if($encode){
					$l0 = decode($CHARSET, $l0);
					$l1 = decode($CHARSET, $l1);
				}
				my @l0 = split //, $l0, -1; $#l0--;
				my @l1 = split //, $l1, -1; $#l1--;
				my ($is, @idelta) = lcs(\@l0, \@l1);
				my $im = $is;
				my $in;
				for($in = 0; $in < $is; $in++){
					$_ = $l1[$in];
					s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g;
					print;
				}
				for(my $ii=0; $ii<=$#idelta; $ii++,$im++,$in++){
					my ($ix, $iy) = split /,/, $idelta[$ii];
					if($ix > $im){
						print qq(<span class="diff-modified-deleted">);
						$_ = "";
						for(; $im < $ix; $im++){
							$_ .= $l0[$im];
						}
						s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g;
						print qq($_</span>);
					}
					if($iy > $in){
						print qq(<span class="diff-modified-added">);
						$_ = "";
						for(; $in < $iy; $in++){
							$_ .= $l1[$in];
						}
						s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g;
						print qq($_</span>);
					}
					if($in <= $#l1){
						$_ = $l1[$in];
						s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g;
						print;
					}
				}
				for(; $in <= $#l1; $in++){
					$_ = $l1[$in];
					s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g;
					print;
				}
				print qq(</div>\n);
			}
		}
		if($x > $m){
			for(; $m < $x; $m++){
				$_ = $line0[$m];
				s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g;
				print qq(<div class="diff-deleted">- $_</div>\n);
			}
		}
		if($y > $n){
			for(; $n < $y; $n++){
				$_ = $line1[$n];
				s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g;
				print qq(<div class="diff-added">+ $_</div>\n);
			}
		}
		if($n <= $#line1){
			$_ = $line1[$n];
			s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g;
			print qq(<div class="diff-unchanged">= $_</div>\n);
		}
	}
	for(; $n <= $#line1; $n++){
		$_ = $line1[$n];
		s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g;
		print qq(<div class="diff-unchanged">= $_</div>\n);
	}

	print qq(</div>\n);
	print_footer();
	die;
}elsif($QUERY_STRING =~ m/^ls(?:[&=].+)?$/){
#-------------------------------------------------------------------------------
# u?ls			List all pages in alphabetical order
# u?ls=az		List all pages in alphabetical order
# u?ls=za		List all pages in reverse order
# u?ls=taz		List all pages in alphabetical order of titles
# u?ls=tza		List all pages in reverse order of titles
# u?ls=rc		Recent changes
# u?ls=oc		Old changes
# u?ls&n=([0-9]+)	List only \1 pages in alphabetical order
# u?ls&title=1		Print page titles instead of page names
# u?ls&glob=GLOB	List all GLOB pages in alphabetical order
	my %var = get_var();
	my ($msg_id, $title);
	if($var{glob} eq ""){
		$msg_id = $var{ls} eq "rc" ? "recent_changes" :
			($var{ls} eq "oc" ? "old_changes" :
			($var{ls} eq "za" ? "all_pages_reversed" :
			"all_pages"));
		$title = get_msg($msg_id);
	}else{
		$msg_id = $var{ls} eq "rc" ? "recent_changes_matching" :
			($var{ls} eq "oc" ? "old_changes_matching" :
			($var{ls} eq "za" ? "all_pages_reversed_matching" :
			"all_pages_matching"));
		$title = get_msg($msg_id, $var{glob});
	}
	my $glob = $var{glob} eq "" ? "*" : $var{glob};

	local $TITLE = $title;
	print_header();
	print qq(<div id="ls">\n<h1>$title</h1>\n<ul>\n);

	my $tls = $var{ls} eq "taz" || $var{ls} eq "tza" ? 1 : 0;
	my $roc = $var{ls} eq "rc" || $var{ls} eq "oc" ? 1 : 0;
	my $n = $var{n} eq "" ? 0 : $var{n};
	my $i = 0;
	my @list;
	foreach(<$glob.txt>){
		next if(substr($_,0,1) eq "." || index($_,"/") >= 0 || !-f $_);
		s/\.txt$//;
		if($PAGES_NOT_ALLOWED ne "" && m/$PAGES_NOT_ALLOWED/o){
			next;
		}
		my $page = $_;
		next unless(-f "$page.html");

		my $title = $page;
		my @t = localtime((stat "$page.txt")[9]);
		my $time = sprintf "%d-%02d-%02d %02d:%02d:%02d",
			$t[5]+1900, $t[4]+1, $t[3], $t[2], $t[1], $t[0];
		if($tls || $var{title} eq "1"){
			my $text = read_file("$page.html");
			if($text ne ""){
				$text =~ s#<(script|style).*?</\1>##sgi;
				if($text =~ m#<h1[^>]*>(.+?)</h1>#si){
					$_ = $1;
					s/<[^>]*>//g; s/[<>]//g;
					$title = $_;
				}
			}
		}
		if($roc){
			if($var{title} eq "1"){
				$list[$i++] = "$time\x00$title\x00$page";
			}else{
				$list[$i++] = "$time\x00$page\x00$title";
			}
		}elsif($tls){
			$list[$i++] = "$title\x00$page\x00$time";
		}else{
			$list[$i++] = "$page\x00$title\x00$time";
		}
	}
	@list = sort @list;
	@list = reverse @list
		if($var{ls} eq "rc" || $var{ls} eq "za" || $var{ls} eq "tza");
	$n = $i if($n > $i || !$n);
	$i = 0;
	foreach(@list){
		my ($page, $title, $time);
		m/^(.*)\x00(.*)\x00(.*)$/;
		if($roc){
			if($var{title} eq "1"){
				$page = $3;
				$title = $2;
			}else{
				$page = $2;
				$title = $3;
			}
			$time = $1;
		}else{
			if($tls){
				$page = $2;
				$title = $var{title} eq "1" ? $1 : $page;
			}else{
				$page = $1;
				$title = $2;
			}
			$time = $3;
		}
		print qq(<li><a href="$page.html">$title</a> <span class="ls-time">$time</span></li>\n);
		last if(++$i == $n);
	}

	print qq(</ul>\n</div>\n);
	print_footer();
	die;
}elsif($QUERY_STRING =~ m/^rss(?:[&=].+)?$/){
#-------------------------------------------------------------------------------
# u?rss			RSS for recent 10 pages
# u?rss=([0-9]+)	RSS for recent \1 pages
# u?rss&glob=GLOB	RSS for recent 10 GLOB pages
	my %var = get_var();
	my $glob = $var{glob} eq "" ? "*" : $var{glob};

	my $t = time;
	my @g = gmtime $t;
	my @l = localtime $t;
	my $g = $g[5]*31536000+$g[4]*2592000+$g[3]*86400+$g[2]*3600+$g[1]*60+
		$g[0];
	my $l = $l[5]*31536000+$l[4]*2592000+$l[3]*86400+$l[2]*3600+$l[1]*60+
		$l[0];
	my $i = 0;
	my @list;
	foreach(<$glob.txt>){
		next if(substr($_,0,1) eq "." || index($_,"/") >= 0 || !-f $_);
		s/\.txt$//;
		if($PAGES_NOT_ALLOWED ne "" && m/$PAGES_NOT_ALLOWED/o){
			next;
		}
		my $page = $_;
		next unless(-f "$page.html");

		my $t = (stat "$page.txt")[9];
		my @t = split / +/, scalar gmtime($t);
		$list[$i++] = sprintf "%d %s, %02d %s %d %s GMT %s",
			$t, $t[0], $t[2], $t[1], $t[4], $t[3], $page;
	}
	my $n = 10;
	$n = $1 if($var{rss} =~ m/^([0-9]+)$/);
	$n = $i if($n > $i || !$n);
	(my $site_title = $SITE_TITLE) =~ s/<[^>]*>//g;
	(my $site_description = $SITE_DESCRIPTION) =~ s/<[^>]*>//g;
	print <<EOT;
Content-Type: text/xml

<?xml version="1.0" encoding="$CHARSET"?>
<rss version="2.0">
<channel>
<title>$site_title</title>
<link>$DOC_BASE</link>
<description>$site_description</description>
EOT
	undef $/;
	$i = 0;
	foreach(reverse sort @list){
		my ($time, $page) = m/^[0-9]+ (.+? GMT) (.*)$/;
		local *FH;
		open FH, "$page.html";
		my $text = <FH>;
		close FH;

		$text =~ s/\r//g;
		$text =~ s/^.*<!-- start text -->|<!-- end text -->.*$//sgi;

		my $has_more = ($text =~ s/<!-- more -->.*$//s);
		my $title;
		if($text =~ m#<h1[^>]*>(.+?)</h1>(.*)$#si){
			$title = $1;
			$text = $2;
			$title =~ s/<[^>]*>//g;
			$title =~ s/&[^ ]*;/ /g;
			$title =~ s/[ \t\n]+/ /g;
			$title =~ s/^ //;
			$title =~ s/ $//;
		}else{
			$title = $page;
		}
		$text =~ s#<(script|style).*?</\1>##sgi;
		$text =~ s/<[^>]*>//g;
		$text =~ s/&[^ ]*;/ /g;
		$text =~ s/[ \t\n]+/ /g;
		$text =~ s/^ //;
		$text =~ s/ $//;
		if($text =~ m/^((?:[^ ]+ ){20})/){
			$text = "$1...";
		}elsif($has_more){
			$text .= " ...";
		}
		print <<EOT;
<item>
<title>$title</title>
<link>$DOC_BASE/$page.html</link>
<description>$text</description>
<pubDate>$time</pubDate>
</item>
EOT
		last if(++$i == $n);
	}
	print <<EOT;
</channel>
</rss>
EOT
	die;
}elsif($QUERY_STRING =~ m/^search(?:[&=].+)?$/){
#-------------------------------------------------------------------------------
# u?search=(.*)			Search using regular expressions
# u?search=(.*)&simple=1	Search using space separated words
# u?search=(.*)&icase=1		Case-insensitive search
# u?search=(.*)&link=1		Search for pages which link to \1 page
# u?search=(.*)&title=1		Print page titles instead of page names
# u?search=(.*)&nomatch=1	Don't print matches
# u?search=(.*)&glob=GLOB	Search GLOB pages
	my %var = get_var();
	if($var{search} eq ""){
		local $TITLE = get_msg("search_form");
		print_header();
		create_search_form(1);
		print_footer();
		die;
	}

	my $glob = $var{glob} eq "" ? "*" : $var{glob};

	$_ = $var{search};
	if($var{simple} eq "1"){
		s/[<>\r]//g; s/[\t\n]/ /g; s/ +/ /g; s/^ //; s/ $//;
		$_ = quotemeta;
		s/\\ />/g;
		s/\\"([^"]*)\\"/\x01$1\x02/g;
		while(s/\x01([^\x02]*)>([^\x02]*)\x02/\x01$1 +$2\x02/g){}
		s/[\x01\x02]//g; s/\\"//g;
	}
	my @search = split />/;

	$_ = $var{search};
	s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g;

	local $TITLE;
	if($var{glob} eq ""){
		$TITLE = get_msg("search", $_);
	}else{
		$TITLE = get_msg("search_matching", $var{glob}, $_);
	}
	print_header();
	print qq(<div id="search">\n<h1>$TITLE</h1>\n<ul>\n);

	foreach(<$glob.txt>){
		next if(substr($_,0,1) eq "." || index($_,"/") >= 0 || !-f $_);
		s/\.txt$//;
		if($PAGES_NOT_ALLOWED ne "" && m/$PAGES_NOT_ALLOWED/o){
			next;
		}
		my $page = $_;
		next unless(-f "$page.html");

		my $text = read_file("$page.html");
		next if($text eq "");

		my $page_name = $page;
		$text =~ s/^.*<!-- start text -->|<!-- end text -->.*$//sgi;
		$text =~ s#<(script|style).*?</\1>##sgi;

		if($var{title} eq "1" && $text =~ m#<h1[^>]*>(.+?)</h1>#si){
			$_ = $1;
			s/<[^>]*>//g; s/[<>]//g;
			$page_name = $_;
		}
		my ($i, $line, $search, $found, @found, @result);
		if($var{link} eq "1"){
			foreach(split /\n/, $text){
				$line = $_;
				$found = "";
				for($i = 0; $i <= $#search; $i++){
					$search = $search[$i];
					$search = "(?i)$search"
						if($var{icase} eq "1");
					if($line =~ m#<[aA][ \t][^>]*(?:href|HREF)[ \t]*=[ \t]*"(?:$search)"[^>]*>[^<]+</[aA]>#){
						$found = $line if($found eq "");
						$found =~ s#<[aA][ \t][^>]*(?:href|HREF)[ \t]*=[ \t]*"(?:$search)"[^>]*>([^<]+)</[aA]>#\x01$1\x02#g;
						$found[$i] = 1;
					}
				}
				if($found ne ""){
					$_ = $found;
					s/<[^>]*>//g; s/<.*$//; s/^.*>//;
					push @result, $_;
				}
			}
		}else{
			$text =~ s/<[^>]*>//g; $text =~ s/[<>]//g;
			foreach(split /\n/, $text){
				$line = $_;
				$found = "";
				for($i = 0; $i <= $#search; $i++){
					$search = $search[$i];
					$search = "(?i)$search"
						if($var{icase} eq "1");
					if($line =~ m#$search#){
						$found = $line if($found eq "");
						$found =~ s#($search)#\x01$1\x02#g;
						$found[$i] = 1;
					}
				}
				push @result, $found if($found ne "");
			}
		}
		for($i = 0; $i <= $#search; $i++){
			last if(!$found[$i]);
		}
		next if($i <= $#search);
		if($var{nomatch} eq "1"){
			print qq(<li><a href="$page.html">$page_name</a></li>\n);
			next;
		}
		print qq(<li><a href="$page.html">$page_name</a>\n<ul>\n);
		foreach(@result){
			s#\x01#<span class="search-highlight">#g;
			s#\x02#</span>#g;
			print qq(<li>$_</li>\n);
		}
		print qq(</ul>\n);
	}

	print qq(</ul>\n</div>\n);
	print_footer();
	die;
}elsif($QUERY_STRING =~ m/^comment(?:[&=].+)?$/){
#-------------------------------------------------------------------------------
# u/PAGE?comment			Generate the comment form for PAGE
#					(id=comment, down, rows=80, cols=6)
# u/PAGE?comment&direction=(up|down)	Generate the comment form for PAGE
#					(id=comment, (up|down), rows=80, cols=6)
# u/PAGE?comment&rows=([0-9]+)		Generate the comment form for PAGE
#					(id=comment, down, rows=\1, cols=6)
# u/PAGE?comment&cols=([0-9]+)		Generate the comment form for PAGE
#					(id=comment, down, rows=80, cols=\1)
# u/PAGE?comment=COMMENT		Generate the comment form for PAGE
#					(id=COMMENT, down, rows=80, cols=6)
# u?comment&page=PAGE			Generate the comment form for PAGE
#					(id=comment, down, rows=80, cols=6)
	my %var = get_var();
	if($REQUEST_METHOD eq "GET"){
		$PAGE = $var{page} if($var{page} ne "");
		if($PAGE eq ""){
			die_message("specify_comment_page");
		}elsif(!-f "$PAGE.txt"){
			die_message("page_not_found", $PAGE);
		}

		local $TITLE = get_msg("comment_form");
		print_header();
		create_comment_form($PAGE, $var{comment}, $var{direction},
			$var{rows}, $var{cols}, 1);
		print_footer();
		die;
	}
	die_rebuild($var{page}) unless(verify_input_data("comment", \%var));

	$PAGE = $var{page};
	die_message("page_not_found", $PAGE) unless(-f "$PAGE.txt");

	die_message("invalid_comment_tag", $var{comment})
		unless($var{comment} =~ m/^[a-zA-Z0-9_-]+$/);

	$var{text} = escape_comment($var{text});

	my $TEXT = "";
	my $time = format_time(time);
	my $added = 0;

	lock_file("$PAGE.txt");
	local *FH;
	if(open FH, "$PAGE.txt"){
		while(<FH>){
			if(m/^#%$var{comment}$/){
				if($var{direction} eq "up"){
					$TEXT .= "$_#%$time\n$var{text}\n\n";
				}else{
					$TEXT .= "#%$time\n$var{text}\n\n$_";
				}
				$added = 1;
			}else{
				$TEXT .= $_;
			}
		}
		close FH;
	}
	die_message("comment_tag_not_found", "#%$var{comment}") unless($added);
	save($PAGE, $TEXT);
	unlock_file("$PAGE.txt");
}elsif($QUERY_STRING =~ m/^wiki_/){
#-------------------------------------------------------------------------------
# Uniqki Wiki
	unless(has_write_access()){
		my $msg_id;
		if($wiki){
			if(-f "$PAGE.txt"){
				$msg_id = "not_allowed_to_edit_wiki_page";
			}else{
				$msg_id = "not_allowed_to_create_wiki_page";
			}
		}else{
			if(-f "$PAGE.txt"){
				$msg_id = "not_wiki_page";
			}else{
				$msg_id = "not_allowed_to_create_nonwiki_page";
			}
		}
		die_message($msg_id, $PAGE);
	}
	if($REQUEST_METHOD eq "GET"){
		if($QUERY_STRING =~ m/^wiki_edit(?:=(-?[0-9]+))?$/){
#-------------------------------------------------------------------------------
# u/PAGE?wiki_edit		Create/edit PAGE
# u/PAGE?wiki_edit=([0-9]+)	Edit the version \1 of PAGE
# u/PAGE?wiki_edit=-([0-9]+)	Edit the current-\1 version of PAGE
			if($1 ne "" && !-f "$PAGE.txt"){
				die_message("page_not_found", $PAGE);
			}

			local $TITLE = $PAGE;
			local $TEXT = "";
			local $VERSION = get_version($PAGE);

			if($1 eq "" && -f "$PAGE.txt"){
				$TEXT = read_file("$PAGE.txt");
				if("#!wiki\n" ne substr $TEXT, 0, 7){
					die_message("internal_errors");
				}

				$TEXT = substr $TEXT, 7;
				$TEXT =~ s/&/&amp;/g;
				$TEXT =~ s/</&lt;/g;
				$TEXT =~ s/>/&gt;/g;
			}elsif($1 ne ""){
				local *FH;

				my $version = $1 > 0 ? $1 : $VERSION + $1;

				$TEXT = read_file("$PAGE.txt");
				if("#!wiki\n" ne substr $TEXT, 0, 7){
					die_message("internal_errors");
				}

				if($version >= $VERSION || $version <= 0){
					die_message("current_version", $PAGE,
						$version);
				}

				open FH, "$PAGE.txt.v"; local $/ = "\x00\n";
				while(<FH>){
					m/^([0-9]+):.*?\n(.*)\x00\n$/s;
					$TEXT = patch($TEXT, $2);
					last if($version == $1 - 1);
				}
				close FH;
				if("#!wiki\n" ne substr $TEXT, 0, 7){
					# Previous version was not a wiki page
					die_message("not_wiki_page", $PAGE);
				}

				$TEXT = substr $TEXT, 7;
				$TEXT =~ s/&/&amp;/g;
				$TEXT =~ s/</&lt;/g;
				$TEXT =~ s/>/&gt;/g;
			}
			$VERSION++;
			print_wiki_edit();
		}
		die;
	}

	my %var = get_var();
	die_rebuild($PAGE) unless(verify_input_data($QUERY_STRING, \%var));

	local *FH;
	my $t = time;
	if($QUERY_STRING eq "wiki_upload"){
#-------------------------------------------------------------------------------
# Wiki upload
		die_message("internal_errors") if($var{file} eq "");
		die_message("page_not_found", $PAGE) unless(-f "$PAGE.txt");
		die_message("wiki_file_not_allowed", $var{file})
			if($WIKI_FILES_ALLOWED eq "" ||
				$var{file} !~ m/$WIKI_FILES_ALLOWED/oi);

		open FH, "$PAGE.txt";
		if(<FH> ne "#!wiki\n"){
			close FH;
			die_message("internal_errors");
		}
		close FH;

		mkdir $PAGE, 0755 if(!-d $PAGE);
		write_file("$PAGE/$t.$var{file}", $var{"file="}, 1);
		chmod 0755, "$PAGE/$t.$var{file}" if($hosting eq "awardspace");
		die_message("wiki_file_uploaded", $var{file}, "$t.$var{file}");
	}
	if(-f "$PAGE.txt"){
		open FH, "$PAGE.txt";
		if(<FH> ne "#!wiki\n"){
			close FH;
			die_message("internal_errors");
		}
		close FH;
	}

	local $VERSION = $var{version};
	local $TEXT = $var{text};
	if($VERSION != get_version($PAGE) + 1){
		print_updated();
		die;
	}
	if($var{file} ne "" && $var{file} =~ m/$WIKI_FILES_ALLOWED/oi){
		mkdir $PAGE, 0755 if(!-d $PAGE);
		write_file("$PAGE/$t.$var{file}", $var{"file="}, 1);
		chmod 0755, "$PAGE/$t.$var{file}" if($hosting eq "awardspace");
		if($var{preview} eq ""){
			(my $f = $var{file}) =~ s/ /%20/g;
			$TEXT .= "\n[$PAGE/$t.$f $var{file}]";
		}
	}
	if($var{preview} ne ""){
		my $uploaded;
		if($var{file} ne "" && -f "$PAGE/$t.$var{file}"){
			$uploaded = get_msg("wiki_file_uploaded", $var{file},
				"$t.$var{file}");
		}

		preview($PAGE, $TEXT, $uploaded, 1);
		die;
	}

	lock_file("$PAGE.txt");
	save($PAGE, "#!wiki\n$TEXT\n");
	unlock_file("$PAGE.txt");
}elsif(!$admin){
################################################################################
# Admin actions
	die_message("admin_actions_not_allowed");
}elsif($insecure_pw){
#-------------------------------------------------------------------------------
# Admin password is still temporary. No admin actions are allowed other than
# changing the password.
	die_message("change_admin_password");
}elsif($QUERY_STRING eq "manage_pages"){
#-------------------------------------------------------------------------------
# u?manage_pages	Manage pages
# u/PAGE?manage_pages	Manage pages
	print_manage_pages();
	die;
}elsif($QUERY_STRING eq "backup"){
#-------------------------------------------------------------------------------
# u?backup		Backup all pages
# u/PAGE?backup		Backup PAGE
	eval "use Archive::Zip;";
	die_message("perl_module_not_installed", "Archive::Zip") if($@);

	my $zip = Archive::Zip->new();
	my $file;
	if($PAGE eq ""){
		$file = "uniqki.zip";
		$zip->addTree(".");
	}else{
		$file = "$PAGE.zip";
		foreach("txt", "txt.v", "html"){
			$zip->addFile("$PAGE.$_") if(-f "$PAGE.$_");
		}
		$zip->addTree($PAGE, $PAGE) if(-d $PAGE);
	}
	print <<EOT;
Content-Type: application/zip
Content-Disposition: attachment; filename="$file"

EOT
	$zip->writeToFileHandle(*STDOUT);
	die;
}elsif($QUERY_STRING eq "restore"){
#-------------------------------------------------------------------------------
# u?restore		Restore
# u/PAGE?restore	Restore
	eval "use Archive::Zip;";
	die_message("perl_module_not_installed", "Archive::Zip") if($@);

	my $boundary = <STDIN>;
	my $file = <STDIN>; my $tmp = $file.<STDIN>.<STDIN>;
	$file =~ s#^.*?filename="(.*?)".*$#$1#s; $file =~ s#^.*[/\\]##;
	my $length = $CONTENT_LENGTH - length($tmp) - 2 *
		length($boundary) - 4;
	read STDIN, my $content, $length;
	my ($fh, $name) = Archive::Zip::tempFile(".");
	print $fh $content;
	my $zip = Archive::Zip->new();
	$zip->readFromFileHandle($fh);
	(my $cgi = $CGI) =~ s#^(?:/~[^/]+)?/##;
	$zip->removeMember($cgi);
	$zip->removeMember($PASSWORD_FILE);
	foreach($zip->memberNames()){
		$zip->removeMember($_) if(-f $_ && !-w $_);
		if($hosting eq "awardspace" &&
			(m#\.html$# || m#/#)){
			my $member = $zip->memberNamed($_);
			$member->unixFileAttributes(0755);
		}
	}
	$zip->extractTree();
	close $fh;
	unlink $name;

	if($hosting eq "awardspace"){
		foreach($zip->memberNames()){
			chmod 0755, $_ if(m#\.html$# || m#/#);
		}
	}

	die_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE?manage_pages");
}elsif($QUERY_STRING =~ m/^refresh(?:&.+)?$/){
#-------------------------------------------------------------------------------
# u?refresh		Refresh all
# u?refresh&glob=GLOB	Refresh GLOB pages
	my %var = get_var();
	my $glob = $var{glob};
	my $title = $glob eq "" ? get_msg("refresh_pages") :
		get_msg("refresh_pages_matching", $glob);

	local $TITLE = $title;
	print_header();
	print qq(<div id="ls">\n<h1>$title</h1>\n<ul>\n);
	foreach($glob eq "" ? (<.*.txt>, <*.txt>) : <$glob.txt>){
		next if(index($_, "/") >= 0 || !-f $_);
		s/\.txt$//;
		if($PAGES_NOT_ALLOWED ne "" && m/$PAGES_NOT_ALLOWED/o){
			next;
		}
		$PAGE = $_;
		make_html($PAGE);
		print qq(<li><a href="$PAGE.html">$PAGE</a></li>\n);
	}
	print qq(</ul>\n</div>\n);
	print_footer();
	die;
}elsif($QUERY_STRING eq "manage_users"){
#-------------------------------------------------------------------------------
# u?manage_users	Manage users
# u/PAGE?manage_users	Manage users
	print_manage_users();
	die;
}elsif($QUERY_STRING eq "add_user" && $REQUEST_METHOD eq "POST"){
#-------------------------------------------------------------------------------
# u?add_user		Add user
# u/PAGE?add_user	Add user
	my %var = get_var();
	if($var{user} eq ""){
		die_message("enter_username");
	}
	if(!is_username($var{user})){
		die_message("check_username");
	}
	if($var{user} eq $USER){
		die_message("cannot_add_yourself");
	}
	if($var{email} eq ""){
		die_message("enter_email_address");
	}
	if(!is_email_address($var{email})){
		die_message("check_email_address");
	}
	if($var{name} eq ""){
		die_message("enter_full_name");
	}
	if(!is_full_name($var{name})){
		die_message("check_full_name");
	}
	if($var{pw} ne $var{pw2}){
		die_message("confirm_password");
	}
	if($var{pw} ne "" && !is_password($var{pw})){
		die_message("check_password");
	}

	(my $escaped_email = $var{email}) =~ s/\./\\./g;
	my $new_pw = "";

	lock_file($PASSWORD_FILE);
	if(-f $PASSWORD_FILE){
		local *FH;
		open FH, $PASSWORD_FILE;
		while(<FH>){
			if(m/^$var{user}:/){
				close FH;
				die_message("user_already_exists", $var{user});
			}
			if(m/:$escaped_email(?::[^:]*){2}$/i){
				close FH;
				die_message("email_address_already_registered",
					$var{email});
			}
			$new_pw .= $_;
		}
		close FH;
	}elsif($adminpw =~ m/:$escaped_email(?::[^:]*){2}$/i){
		die_message("email_address_already_registered", $var{email});
	}else{
		$new_pw = "$adminpw\n";
	}

	# Add a new user if user was not found
	my $group = $var{admin} eq "yes" ? "admin" : "user";
	my $pw;
	my $token;
	if($var{pw} eq ""){
		$pw = "reset";
		$token = generate_password_set_token($var{user});

		my $link = "$HTTP_BASE$SCRIPT_NAME?reset_password=$token";
		my $subject = get_msg("new_user_email_subject", $DOC_BASE);
		my $text = get_msg("new_user_email_text", $var{user}, $DOC_BASE,
			$link, $SET_PASSWORD_TIMEOUT);
		if(!send_email($var{email}, $subject, $text)){
			die_message("email_notification_failed", $var{user},
				$var{email});
		}
	}else{
		$pw = hash_password($var{user}, $var{pw});
		$token = "";
	}
	$new_pw .= "$var{user}:$pw:$group:$var{email}:$var{name}:$token\n";

	write_file($PASSWORD_FILE, $new_pw);
	unlock_file($PASSWORD_FILE);

	die_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE?manage_users");
}elsif($QUERY_STRING eq "update_user" && $REQUEST_METHOD eq "POST"){
#-------------------------------------------------------------------------------
# u?update_user		Update user
# u/PAGE?update_user	Update user
	my %var = get_var();
	if($var{user} eq ""){
		die_message("enter_username");
	}
	if(!is_username($var{user})){
		die_message("check_username");
	}
	if($var{name} ne "" && !is_full_name($var{name})){
		die_message("check_full_name");
	}
	if($var{pw} ne $var{pw2}){
		die_message("confirm_password");
	}
	if($var{pw} ne "" && !is_password($var{pw})){
		die_message("check_password");
	}
	if($var{pw} eq "" && $var{email} eq "" &&
		$var{admin} ne "yes" && $var{admin} ne "no"){
		die_message("enter_user_info_to_update");
	}

	my $new_pw = "";
	my $updated = 0;

	lock_file($PASSWORD_FILE);
	if(-f $PASSWORD_FILE){
		local *FH;
		open FH, $PASSWORD_FILE;
		while(<FH>){
			if(m/^$var{user}:/){
				$updated = 1;
				my @items = split /:/;
				my $pw = $var{pw} ne "" ?
					hash_password($var{user}, $var{pw}) :
					$items[1];
				my $group = $var{admin} eq "yes" ? "admin" :
					($var{admin} eq "no" ? "user" :
						$items[2]);
				my $email = $var{email} ne "" ?
					$var{email} : $items[3];
				my $name = $var{name} ne "" ?
					$var{name} : $items[4];
				my $token = $items[5];
				# new line from $items[5]
				my $userline = "$var{user}:$pw:$group:$email:$name:$token";
				if($userline eq $_){
					close FH;
					die_message("enter_user_info_to_update", $var{user});
				}
				$_ = $userline;
			}
			$new_pw .= $_;
		}
		close FH;
	}else{
		my @items = split /:/, $adminpw;
		if($var{user} ne $items[0]){
			# Something's wrong because you're the only user, but
			# the user line in this script is not you! How did you
			# login?
			die_message("internal_errors");
		}

		$updated = 1;
		my $pw = $var{pw} ne "" ? hash_password($var{user}, $var{pw}) :
			$items[1];
		my $group = $var{admin} eq "yes" ? "admin" :
			($var{admin} eq "no" ? "user" : $items[2]);
		my $email = $var{email} ne "" ? $var{email} : $items[3];
		my $name = $var{name} ne "" ? $var{name} : $items[4];
		my $token = $items[5];
		# new line from $items[5]
		my $userline = "$var{user}:$pw:$group:$email:$name:$token";
		if($userline eq $adminpw){
			die_message("enter_user_info_to_update", $var{user});
		}
		$new_pw = "$userline\n";
	}
	die_message("user_not_found", $var{user}) unless($updated);

	write_file($PASSWORD_FILE, $new_pw);
	unlock_file($PASSWORD_FILE);

	die_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE?manage_users");
}elsif($QUERY_STRING eq "block_user" && $REQUEST_METHOD eq "POST"){
#-------------------------------------------------------------------------------
# u?block_user		Block user
# u/PAGE?block_user	Block user
	my %var = get_var();
	if($var{user} eq ""){
		die_message("enter_username");
	}
	if(!is_username($var{user})){
		die_message("check_username");
	}
	if($var{user} eq $USER){
		die_message("cannot_block_yourself");
	}

	my $new_pw = "";
	my $blocked = 0;

	lock_file($PASSWORD_FILE);
	if(-f $PASSWORD_FILE){
		local *FH;
		open FH, $PASSWORD_FILE;
		while(<FH>){
			if(m/^$var{user}:/){
				my @items = split /:/;
				if($items[1] eq "blocked"){
					close FH;
					die_message("user_already_blocked",
						$var{user});
				}
				$blocked = 1;
				clear_user_sessions($var{user});
				$_ = "$var{user}:blocked:$items[2]:$items[3]:$items[4]:\n";
			}
			$new_pw .= $_;
		}
		close FH;
	}
	die_message("user_not_found", $var{user}) unless($blocked);

	write_file($PASSWORD_FILE, $new_pw);
	unlock_file($PASSWORD_FILE);

	die_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE?manage_users");
}elsif($QUERY_STRING eq "unblock_user" && $REQUEST_METHOD eq "POST"){
#-------------------------------------------------------------------------------
# u?unblock_user	Unblock user
# u/PAGE?unblock_user	Unblock user
	my %var = get_var();
	if($var{user} eq ""){
		die_message("enter_username");
	}
	if(!is_username($var{user})){
		die_message("check_username");
	}
	if($var{user} eq $USER){
		die_message("cannot_unblock_yourself");
	}

	if($var{pw} ne $var{pw2}){
		die_message("confirm_password");
	}
	if($var{pw} ne "" && !is_password($var{pw})){
		die_message("check_password");
	}

	my $new_pw = "";
	my $unblocked = 0;
	my $token = "";

	lock_file($PASSWORD_FILE);
	if(-f $PASSWORD_FILE){
		local *FH;
		open FH, $PASSWORD_FILE;
		while(<FH>){
			if(m/^$var{user}:/){
				my @items = split /:/;
				if($items[1] ne "blocked"){
					close FH;
					die_message("user_already_unblocked",
						$var{user});
				}
				$unblocked = 1;
				my $pw;
				if($var{pw} eq ""){
					$pw = "reset";
					$token = generate_password_set_token($var{user});
				}else{
					$pw = hash_password($var{user},
						$var{pw});
					$token = "";
				}
				$_ = "$var{user}:$pw:$items[2]:$items[3]:$items[4]:$token\n";
			}
			$new_pw .= $_;
		}
		close FH;
	}
	die_message("user_not_found", $var{user}) unless($unblocked);

	if($token ne ""){
		my $link = "$HTTP_BASE$SCRIPT_NAME?reset_password=$token";
		my $subject = get_msg("unblocked_user_email_subject",
			$DOC_BASE);
		my $text = get_msg("unblocked_user_email_text", $var{user},
			$DOC_BASE, $link, $SET_PASSWORD_TIMEOUT);
		if(!send_email($var{email}, $subject, $text)){
			die_message("email_notification_failed", $var{user},
				$var{email});
		}
	}

	write_file($PASSWORD_FILE, $new_pw);
	unlock_file($PASSWORD_FILE);

	die_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE?manage_users");
}elsif($QUERY_STRING eq "delete_user" && $REQUEST_METHOD eq "POST"){
#-------------------------------------------------------------------------------
# u?delete_user		Delete user
# u/PAGE?delete_user	Delete user
	my %var = get_var();
	if($var{user} eq ""){
		die_message("enter_username");
	}
	if(!is_username($var{user})){
		die_message("check_username");
	}
	if($var{user} eq $USER){
		die_message("cannot_delete_yourself");
	}

	my $new_pw = "";
	my $deleted = 0;

	lock_file($PASSWORD_FILE);
	if(-f $PASSWORD_FILE){
		local *FH;
		open FH, $PASSWORD_FILE;
		while(<FH>){
			if(m/^$var{user}:/){
				$deleted = 1;
				clear_user_sessions($var{user});
				next;
			}
			$new_pw .= $_;
		}
		close FH;
	}
	die_message("user_not_found", $var{user}) unless($deleted);

	write_file($PASSWORD_FILE, $new_pw);
	unlock_file($PASSWORD_FILE);

	die_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE?manage_users");
}elsif($QUERY_STRING eq "install_password"){
#-------------------------------------------------------------------------------
# u?install_password		Install the password file, but don't overwrite
# u/PAGE?install_password	Install the password file, but don't overwrite
	write_pw();
	die_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE");
}elsif($QUERY_STRING eq "install_config"){
#-------------------------------------------------------------------------------
# u?install_config	Install the config file, but don't overwrite
# u/PAGE?install_config	Install the config file, but don't overwrite
	process_cfg(1);
	die_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE");
}elsif($QUERY_STRING eq "install_messages"){
#-------------------------------------------------------------------------------
# u?install_messages		Install the messages file, but don't overwrite
# u/PAGE?install_messages	Install the messages file, but don't overwrite
	process_msg(1);
	die_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE");
}elsif($QUERY_STRING eq "install_template"){
#-------------------------------------------------------------------------------
# u?install_template		Install the template files, but don't overwrite
# u/PAGE?install_template	Install the template files, but don't overwrite
	if($TEMPLATE_DIRECTORY ne ""){
		mkdir $TEMPLATE_DIRECTORY, 0755 unless(-d $TEMPLATE_DIRECTORY);
		print_header(1);
		print_footer(1);
		print_login(1);
		print_manage_pages(1);
		print_manage_users(1);
		print_manage_myself(1);
		print_forgot_password(1);
		print_reset_password(1);
		print_message(1);
		print_view(1);
		print_edit(1);
		print_preview(1);
		print_updated(1);
		print_wiki_view(1);
		print_wiki_edit(1);
		print_wiki_preview(1);
		print_css(1);
		print_js(1);
	}
	die_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE");
}elsif($PAGE eq ""){
#-------------------------------------------------------------------------------
# u?ACTION		Redirect to index
	die_redirect("$HTTP_BASE$SCRIPT_NAME/$INDEX_PAGE");
}elsif($QUERY_STRING eq "upload"){
#-------------------------------------------------------------------------------
# u/PAGE?upload		Upload PAGE/FILE
	my %var = get_var();
	die_rebuild($PAGE) unless(verify_input_data("upload", \%var));

	if($var{file} ne ""){
		mkdir $PAGE, 0755 if(!-d $PAGE);
		write_file("$PAGE/$var{file}", $var{"file="}, 1);
		chmod 0755, "$PAGE/$var{file}" if($hosting eq "awardspace");
		$rebuild = 1;
	}
}elsif($QUERY_STRING eq "delete" && $FILE ne ""){
#-------------------------------------------------------------------------------
# u/PAGE/FILE?delete	Delete PAGE/FILE
	my $dir = "";
	if(unlink "$PAGE/$FILE"){
		$dir = "$PAGE/$FILE"; $dir =~ s#/[^/]+$##;
	}elsif(-d "$PAGE/$FILE"){
		$dir = "$PAGE/$FILE";
	}
	if($dir ne ""){
		while(index($dir, "/") >= 0){
			rmdir $dir;
			$dir =~ s#/[^/]*$##;
		}
		rmdir $dir;
	}
	$rebuild = 1;
}elsif($QUERY_STRING =~ m/^edit(?:=(-?[0-9]+))?$/){
#-------------------------------------------------------------------------------
# u/PAGE?edit		Create/edit PAGE
# u/PAGE?edit=([0-9]+)	Edit the version \1 of PAGE
# u/PAGE?edit=-([0-9]+)	Edit the current-\1 version of PAGE
	local $TITLE = $PAGE;
	local ($VERSION, $TEXT);
	if($REQUEST_METHOD eq "GET"){
		$VERSION = get_version($PAGE);
		my $version = $1 > 0 ? $1 : $VERSION + $1;
		$TEXT = read_file("$PAGE.txt");
		if($TEXT ne ""){
			if($version > 0 && $version < $VERSION){
				local *FH;
				open FH, "$PAGE.txt.v"; local $/ = "\x00\n";
				while(<FH>){
					m/^([0-9]+):.*?\n(.*)\x00\n$/s;
					$TEXT = patch($TEXT, $2);
					last if($version == $1 - 1);
				}
				close FH;
			}
			$TEXT =~ s/&/&amp;/g;
			$TEXT =~ s/</&lt;/g;
			$TEXT =~ s/>/&gt;/g;
		}
		$VERSION++;
		print_edit();
		die;
	}

	my %var = get_var();
	die_rebuild($PAGE) unless(verify_input_data("edit", \%var));

	$VERSION = $var{version};
	$TEXT = $var{text};
	if($VERSION != get_version($PAGE) + 1){
		print_updated();
		die;
	}
	if($var{file} ne ""){
		mkdir $PAGE, 0755 if(!-d $PAGE);
		write_file("$PAGE/$var{file}", $var{"file="}, 1);
		chmod 0755, "$PAGE/$var{file}" if($hosting eq "awardspace");
	}
	if($var{preview} ne ""){
		my $uploaded;
		if($var{file} ne "" && -f "$PAGE/$var{file}"){
			$uploaded = get_msg("file_uploaded", $var{file});
		}

		preview($PAGE, $TEXT, $uploaded, 0);
		die;
	}
	lock_file("$PAGE.txt");
	save($PAGE, "$TEXT\n");
	unlock_file("$PAGE.txt");
}elsif($QUERY_STRING =~ m/^revert(?:=(-?[0-9]+))?$/){
#-------------------------------------------------------------------------------
# u/PAGE?revert			Go back to the previous version of PAGE
# u/PAGE?revert=([0-9]+)	Go back to the \1 version of PAGE
# u/PAGE?revert=-([0-9]+)	Go back to the current-\1 version of PAGE
	unless(-f "$PAGE.txt"){
		die_message("page_not_found", $PAGE);
	}

	lock_file("$PAGE.txt");
	my $current_version = get_version($PAGE);
	my $version = $1 > 0 ? $1 : $current_version + ($1 < 0 ? $1 : -1);
	if($version > 0 && $version < $current_version){
		local *FH;
		my $text = read_file("$PAGE.txt");
		open FH, "$PAGE.txt.v"; local $/ = "\x00\n";
		while(<FH>){
			m/^([0-9]+):.*?\n(.*)\x00\n$/s;
			$text = patch($text, $2);
			if($version == $1 - 1){
				$rebuild = 1;
				last;
			}
		}
		if($rebuild){
			local $/ = "\n";
			my $line = <FH>;
			my @items = split /:/, $line;
			my $time = $items[2];

			local $/ = undef;
			my $txtv = $line.<FH>;
			close FH;

			write_file("$PAGE.txt.v", $txtv);
			write_file("$PAGE.txt", $text);
			utime $time, $time, "$PAGE.txt";
		}else{
			close FH;
		}
	}
	unlock_file("$PAGE.txt");
}elsif($QUERY_STRING eq "delete"){
#-------------------------------------------------------------------------------
# u/PAGE?delete		Delete PAGE
	unlink "$PAGE.txt", "$PAGE.txt.v", "$PAGE.html";
	rmrf($PAGE);
	$PAGE = $INDEX_PAGE;
}

#-------------------------------------------------------------------------------
# Rebuild, if requested, and redirect
make_html($PAGE) if($rebuild);

if($nonwiki_read_access ne "open" || $wiki_read_access ne "open"){
	die_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE") if($QUERY_STRING ne "");
	die_message("page_not_found", $PAGE) unless(-f "$PAGE.html");

	local *FH;
	start_html();
	open FH, "$PAGE.html";
	print <FH>;
	close FH;
	die;
}

die_redirect("$DOC_BASE/$PAGE.html");
