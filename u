#!/usr/bin/env perl
################################################################################
# Uniqki:	Unique Wiki <http://uniqki.isnew.info>
# Author:	Huidae Cho
# Since:	May 23, 2007
#
# Copyright (C) 2007-2008, 2010-2011, 2016, Huidae Cho <http://geni.isnew.info>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
################################################################################

# The document root directory relative to the server's URL including /~user, if
# any.  For example, if the full URL path to index.html is
# http://example.com/~user/index.html, $doc_root should be set to ".".  Leave
# it blank if you can run this script outside of the cgi-bin directory.
my $doc_root = "";

# Temporary admin user: admin, password: admin.  DO NOT CHANGE THIS VARIABLE.
my $tmp_adminpw = 'admin:7352327a53727a65613d7a4cb055d722c21f1a0f17ad676daccd4ad8bf728134c9ee739e5f51c9af822da15b69985908148c55b6fdea4bc0bcd5aff660a53db428a9898c12743c7d:admin:@:Administrator:';
# Running this script for the first time will create the password file u.pw
# using the $adminpw credential, which is set to $temporary_adminpw by default.
# Since this password is public, make sure to change the admin password after
# the first login to update the password file.  If $adminpw in the following
# line is not the same as $temporary_adminpw, Uniqki will assume that you have
# changed $adminpw to remove the password file and use this script instead for
# login, and will not create the password file again.  Using this feature, it
# is possible to operate a Uniqki site with this file alone by removing the
# password file after setting the $adminpw variable to your new credential in
# u.pw.  Make sure to back up this variable when updating the script.
# Optionally, you can create u.cfg and template files in u.tpl by running
# u?install_config and u?install_template, respectively, but these files are
# only used for customizations and are not required.
my $adminpw = $tmp_adminpw;

################################################################################
use strict;

# HTTP server environment variables
use vars qw(
	$CFG
	$HTTPS $HTTP_COOKIE $HTTP_HOST $SERVER_NAME $SCRIPT_NAME $PATH_INFO
	$QUERY_STRING $REQUEST_METHOD $CONTENT_LENGTH
);

# Useful variables
use vars qw(
	$HTTP_BASE $DOC_BASE $CGI $PAGE $FILE $USER $NAME $AUTHOR
);

# Template variables
use vars qw(
	$TITLE $TEXT $PREVIEW $VERSION $TIME $PASSWORD_RESET_TOKEN $MESSAGE
);

# Config and messages variables
use vars qw(
	$SITE_TITLE $SITE_DESCRIPTION $INDEX_PAGE $LANG $CHARSET $LOCALE
	$TIME_ZONE $TIME_FORMAT
	$SHARE_COOKIES
	$PASSWORD_FILE $SESSIONS_FILE $MESSAGES_FILE $TEMPLATE_DIRECTORY
	$PAGE_NAME_STYLE
	$INACTIVE_TIMEOUT $SET_PASSWORD_TIMEOUT $RESET_PASSWORD_TIMEOUT
	$EMAIL_ADDRESS $SMTP
	$READ_ACCESS $WRITE_ACCESS
	$HEADER_FILE $FOOTER_FILE
	$WIKI_HEADER_FILE $WIKI_FOOTER_FILE
	$WIKI_ALLOWED_PAGES $WIKI_ALLOWED_FILES

	%MESSAGES
);

# verify_input()
use vars qw(
	$verify_input
);

# parse_file() global variables
use vars qw(
	$wiki $begin_parsing $parse_line $end_parsing
);

# parse_file() local variables
use vars qw(
	$text $protocol $protocol_char $protocol_punct $image_ext $code_block
	$syntax_block @syntax_blocks $re_i_start $re_i @re @re_sub $toc $notoc
	%h_i $h_top $h_prev $p $pre $pre_code $list $table $figure
);

umask 022;

# hmac_sha1 routine for password hashing
eval "use Digest::HMAC_SHA1 qw(hmac_sha1);";
exit_message("perl_module_not_installed", "Digest::HMAC_SHA1") if($@);

if(!defined $ENV{GATEWAY_INTERFACE}){
	print "Please run this script from a web browser!\n";
	printf "my \$tmp_adminpw = 'admin:%s:admin:\@:Administrator:';\n",
		hash_password("admin", "admin");
	exit;
}

################################################################################
# CGI variables
$CFG = $ENV{HTTP_UNIQKI_CONFIG};
$HTTPS = $ENV{HTTPS};
$HTTP_COOKIE = $ENV{HTTP_COOKIE};
$HTTP_HOST = $ENV{HTTP_HOST};
$SERVER_NAME = $ENV{SERVER_NAME};
$SCRIPT_NAME = $ENV{SCRIPT_NAME};
$PATH_INFO = $ENV{PATH_INFO};
$QUERY_STRING = $ENV{QUERY_STRING};
$REQUEST_METHOD = $ENV{REQUEST_METHOD};
$CONTENT_LENGTH = $ENV{CONTENT_LENGTH};

################################################################################
# Useful variables
# Supported URLs:
# This script outside cgi-bin: $doc_root = ""
# * https?://host/~user/dir/u/page/path/to/file?query
#   * CGI: u
#   * DOC_BASE: https?://host/~user/dir
# This script inside cgi-bin: $doc_root != ""
# * https?://host/~user/cgi-bin/u/page/path/to/file?query
#   * CGI: /~user/cgi-bin/u
#   * DOC_BASE: https?://host/~user/doc_root
# * HTTP_BASE: https?://host
# * PAGE: page
# * FILE: path/to/file
$CGI = $SCRIPT_NAME;
$HTTP_BASE = ($HTTPS eq "on" ? "https" : "http")."://$HTTP_HOST";
$DOC_BASE = "$HTTP_BASE$CGI"; $DOC_BASE =~ s#/[^/]*$##;
$PAGE = substr $PATH_INFO, 1; $PAGE =~ s#/.*$##;
$PAGE =~ s#\.(?:html|txt|txt\.v)$##;
$FILE = $PATH_INFO; $FILE =~ s#^/[^/]+##; $FILE =~ s#^/##;

################################################################################
# Awardspace.com free web hosting
my $hosting = "";
if(-d "/home/www/$SERVER_NAME"){
	$hosting = "awardspace";
	$_ = "/home/www/$SERVER_NAME$SCRIPT_NAME";
	s#/[^/]*$##;
	chdir $_;
}
if($doc_root eq ""){
	$CGI =~ s#^.*/##;
}else{
	($_ = $CGI) =~ s#/[^/]+$##;
	s#^/~[^/]+##;
	if($_ eq ""){
		chdir $doc_root;
	}else{
		s#^/##; s#[^/]+#..#g;
		chdir "$_/$doc_root";
	}
	$DOC_BASE = $HTTP_BASE.($CGI =~ m#(^/~[^/]+)# ? $1 : "")."/$doc_root";
}

################################################################################
# Config
process_cfg();
$INDEX_PAGE = "index" if($INDEX_PAGE eq "");
if($TIME_ZONE ne ""){
	if($TIME_ZONE =~ m/^gmt([+-])([0-9]+)$/i){
		$TIME_ZONE = "GMT".($1 eq "+" ? "-" : "+").$2;
	}
	$ENV{TIME_ZONE} = $TIME_ZONE;
}

eval "use POSIX qw(setlocale LC_ALL tzset strftime);";
my $use_posix = $@ ? 0 : 1;
if($use_posix){
	setlocale(LC_ALL(), $LOCALE) if($LOCALE ne "");
	tzset() if($TIME_ZONE ne "");
	# Windows does not implement %e. %#d is the same as %e on Windows.
	$TIME_FORMAT =~ s/%e/%#d/g if("" eq strftime("%e", localtime));
}

my $smtp_server = "";
my $smtp_port;
my $smtp_username;
my $smtp_password;
if($SMTP =~ m/^([a-z0-9.-]+\.[a-z]{2,}):([0-9]*):([^:]*):(.*)$/i){
	$smtp_server = $1;
	$smtp_port = $2;
	$smtp_username = $3;
	$smtp_password = $4;
}

my ($page_name_case, $page_name_dots, $page_name_spaces) =
	config_page_name_style();
my ($nonwiki_read_access, $wiki_read_access, $wiki_write_access) =
	config_read_write_access();

################################################################################
# Messages
process_msg();

################################################################################
# Initialization
$USER = "";
$NAME = "Visitor";
my $admin = 0;
my $header_printed = 0;
my $footer_printed = 0;
my $rebuild = 0;
my $insecure_pw = 1;
my $sessions_file = $SESSIONS_FILE eq "" ? ".sessions" : $SESSIONS_FILE;
my $debug_started = 0;
my $html_started = 0;
my %locked_files = ();
my $cookie_domain_path = get_cookie_domain_path();

################################################################################
# Non-user-replaceable subroutines
sub debug{
	my $msg = shift;
	unless($debug_started){
		$debug_started = 1;
		print "Content-Type: text/plain\n\n";
	}
	printf "%s\n", $msg;
}

sub format_time{
	my $time = shift;
	my $ftime;
	if($use_posix && $TIME_FORMAT ne ""){
		$ftime = strftime($TIME_FORMAT, localtime $time);
	}else{
		$ftime = scalar localtime $time;
	}
	return $ftime;
}

sub config_page_name_style{
	my ($case, $dots, $spaces);

	foreach my $item (split /:/, $PAGE_NAME_STYLE){
		if("_case" eq substr $item, -5){
			$case = $item;
			if($case eq "lower_camel_case"){
				$dots = "no_dots";
				$spaces = "no_spaces";
			}elsif($case eq "upper_camel_case"){
				$case = "start_case";
				$dots = "no_dots";
				$spaces = "no_spaces";
			}
		}elsif("dots" eq substr $item, -4){
			$dots = $item;
		}else{
			$spaces = $item;
		}
	}

	if($case ne "upper_case" && $case ne "mixed_case" &&
		$case ne "start_case" && $case ne "lower_camel_case" &&
		$case ne "upper_camel_case"){
		# default lower_case
		$case = "lower_case";
	}

	if($dots ne "no_dots"){
		# default dots
		$dots = "dots";
	}
	if($spaces ne "no_spaces" && $spaces ne "underscores"){
		# default hyphens
		$spaces = "hyphens";
	}
	return ($case, $dots, $spaces);
}

sub config_read_write_access{
	my @items = split /:/, $READ_ACCESS;
	my $nonwiki_read_access = $items[0] ne "open" && $items[0] ne "closed" ?
		"admin" : $items[0];
	my $wiki_read_access = index($READ_ACCESS, ":") == -1 ?
		$nonwiki_read_access :
		($items[1] ne "open" && $items[1] ne "closed" ?
			"admin" : $items[1]);
	my $wiki_write_access = $WRITE_ACCESS ne "open" &&
		$WRITE_ACCESS ne "closed" ? "admin" : $WRITE_ACCESS;
	return ($nonwiki_read_access, $wiki_read_access, $wiki_write_access);
}

sub run_file_mimetype{
	my $file = shift;
	return "" unless(-f $file);
	(my $mimetype = `file --brief --mime-type $file`) =~ y/[\r\n]//d;
	return $mimetype;
}

sub get_mimetype{
	my $file = shift;
	return "" unless(-f $file);
	my $mimetype;
	eval "use MIME::Types;";
	if($@){
		$mimetype = run_file_mimetype($file);
	}else{
		$mimetype = MIME::Types->new(only_iana=>1)->mimeTypeOf($file);
		$mimetype = run_file_mimetype($file) if($mimetype eq "");
	}
	$mimetype = "application/octet-stream" if($mimetype eq "");
	return $mimetype;
}

sub exit_path{
	my $path = shift;
	exit_message("path_not_found", $path) unless(-e $path);

	if(-d $path){
		$path =~ s#/+$##;
		local $TITLE = get_msg("page_files", $path);
		print_header();
		print qq(<div id="ls">\n<h1>$TITLE</h1>\n<ul>\n);
		foreach(<$path/*>){
			my $file = $_;
			s#^[^/]*/##;
			my $url = encode_url($_);
			s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g;
			my $name = $_;
			my @t = localtime((stat $file)[9]);
			my $time = sprintf "%d-%02d-%02d %02d:%02d:%02d",
				$t[5]+1900, $t[4]+1, $t[3], $t[2], $t[1], $t[0];
			print qq(<li><a href="$url">$name</a> <span class="ls-time">$time</span></li>\n);
		}
		print qq(</ul></div>\n);
		print_footer();
		exit;
	}

	my $mimetype = get_mimetype($path);
	(my $file = $path) =~ s#^.*/##;
	print <<EOT;
Content-Type: $mimetype
Content-Disposition: inline; filename="$file"

EOT
	local *FH;
	open FH, $path;
	print <FH>;
	close FH;
	exit;
}

sub exit_message{
	local $MESSAGE = get_msg(@_);
	(local $TITLE = $MESSAGE) =~ s/<[^>]*>//g;
	print_message();
	exit;
}

sub exit_rebuild{
	my $PAGE = shift;
	if(-f "$PAGE.txt"){
		make_html($PAGE);
		exit_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE");
	}
	exit_redirect("$HTTP_BASE$SCRIPT_NAME/$INDEX_PAGE");
}

sub exit_redirect{
	printf "Location: %s\n\n", shift;
	exit;
}

sub exit_text{
	print "Content-Type: text/plain\n\n";
	print shift;
	exit;
}

sub start_html{
	return if($html_started);
	$html_started = 1;
	print "Content-Type: text/html\n\n";
}

sub convert_page_name{
	my $page_name = shift;
	my $forbidden_chars = q(`~!@#\$%^&*=+\\|;:'",\/?()\[\]{}<>);

	# from parse_line
	$page_name =~ y/\x01/&/;
	$page_name =~ y/\x02/</;
	$page_name =~ y/\x03/>/;

	$page_name =~ s/[$forbidden_chars \t_-]+/ /og;
	if($page_name_dots eq "dots"){
		$page_name =~ s/\.+/./g;
		$page_name =~ s/(?:\.? \.?)+/ /g;
	}else{
		$page_name =~ y/.//d;
		$page_name =~ s/ +/ /g;
	}
	# Allow page names starting with a dot.
	$page_name =~ s/^ |[. ]$//g;
	return "" if($page_name eq "");

	if($page_name_case eq "mixed_case"){
		# case as is
	}elsif($page_name_case eq "upper_case"){
		$page_name = uc $page_name;
	}elsif($page_name_case eq "start_case"){
		$page_name =~ s/(?:^|(?<=[ .]))([^ .])([^ .]*)/@{[(uc $1).(lc $2)]}/g;
	}elsif($page_name_case eq "lower_camel_case"){
		$page_name =~ s/^([^ .]*)/@{[lc $1]}/;
		$page_name =~ s/(?<=[ .])([^ .])([^ .]*)/@{[(uc $1).(lc $2)]}/g;
	}else{
		# default: lower_case
		$page_name = lc $page_name;
	}

	if($page_name_spaces eq "no_spaces"){
		$page_name =~ y/ //d;
	}elsif($page_name_spaces eq "underscores"){
		$page_name =~ y/ /_/;
	}else{
		# default: hyphens
		$page_name =~ y/ /-/;
	}

	return $page_name;
}

sub unescape_comment{
	my $text = shift;
	$text =~ y/\x00//d;
	return $text;
}

sub escape_comment{
	my $text = shift;
	$text =~ s/^([#%])/\x00$1/mg;
	$text =~ s/``(.*?)``(?!`)/`\x00`$1`\x00`/g;
	$text =~ s/^(---+)$/\x00$1/mg;
	$text =~ s/^\x00(---+)\n(.*?)\n\x00\1$/$1\n@{[unescape_comment($2)]}\n$1/smg;
	$text =~ s/\x00/''''/g;
	return $text;
}

sub escape_inline_syntax{
	my $text = shift;
	$text =~ s#([`"/*'_!\[{-]|$protocol)#\x00$1#ogi;
	$text =~ s/\x00([&<>])/$1/g;
	return $text;
}

sub link_page{
	my ($page, $section, $title) = @_;

	$page =~ s/^[ \t]+|[ \t]+$//g;
	$section =~ s/^[ \t]+|[ \t]+$//g;
	$title =~ s/^[ \t]+|[ \t]+$//g;

	my $enc_page = encode_url(convert_page_name($page));
	my $enc_section = encode_url(convert_page_name($section));

	if($enc_page eq ""){
		return "" if($enc_section eq "");
		return qq(<a href="#$enc_section">#$section</a>) if($title eq "");
		return qq(<a href="#$enc_section">$title</a>);
	}
	if($enc_section eq ""){
		return qq(<a href="$enc_page.html">$page</a>) if($title eq "");
		return qq(<a href="$enc_page.html">$title</a>);
	}
	return qq(<a href="$enc_page.html#$enc_section">$page#$section</a>) if($title eq "");
	return qq(<a href="$enc_page.html#$enc_section">$title</a>);
}

sub link_image{
	# file: current page's file
	# ./file: current page's file
	# page/file: page's file
	# /file: DOC_BASE's file
	my ($path, $title, $style) = @_;

	$path =~ s/^[ \t]+|[ \t]+$//g;
	$title =~ s/^[ \t]+|[ \t]+$//g;
	$style =~ s/^[ \t]+|[ \t]+$//g;
	return "" if($path eq "." || $path eq "");

	$style = qq( style="$style") if($style ne "");

	my $page = $PAGE;
	my $file = "";

	my $i = rindex($path, "/");
	if($i >= 0){
		my $p = substr $path, 0, $i;
		if($p eq ""){
			# /file
			$page = ".";
		}elsif($p ne "."){
			# page/file
			$page = convert_page_name($p);
			return "" if($page eq "");
		}
		# else ./file
		$file = substr $path, $i + 1;
		return "" if($file eq "");
	}else{
		# file
		$file = $path;
	}

	my $enc_path = encode_url("$page/$file");
	return qq(<img src="$enc_path" alt="$file" title="$file"$style />) if($title eq "");
	return qq(<img src="$enc_path" alt="$title" title="$title"$style />);
}

sub link_file{
	# .: current page's directory
	# ./: current page's directory
	# file: current page's file
	# ./file: current page's file
	# page/: page's directory
	# page/file: page's file
	# /: DOC_BASE
	# /file: DOC_BASE's file
	my ($path, $title) = @_;

	$path =~ s/^[ \t]+|[ \t]+$//g;
	$title =~ s/^[ \t]+|[ \t]+$//g;

	my $page = $PAGE;
	my $file = "";

	my $i = rindex($path, "/");
	if($i >= 0){
		my $p = substr $path, 0, $i;
		if($p eq ""){
			# /, /file
			$page = ".";
		}elsif($p ne "."){
			# page/, page/file
			$page = convert_page_name($p);
			return "" if($page eq "");
		}
		# else ./, ./file
		$file = substr $path, $i + 1;
	}elsif($path eq "."){
		# .
		$file = "";
	}else{
		# file
		$file = $path;
	}

	if($file eq ""){
		return qq(<a href="$page/">$page/</a>) if($title eq "");
		return qq(<a href="$page/">$title</a>);
	}

	my $enc_path = encode_url("$page/$file");
	return qq(<a href="$enc_path">$file</a>) if($title eq "");
	return qq(<a href="$enc_path">$title</a>);
}

sub link_url_image{
	my ($url, $title, $style) = @_;

	$url =~ s/^[ \t]+|[ \t]+$//g;
	$title =~ s/^[ \t]+|[ \t]+$//g;
	$style =~ s/^[ \t]+|[ \t]+$//g;
	$style = qq( style="$style") if($style ne "");

	my $enc_url = encode_url($url);
	return qq(<img src="$enc_url" alt="$url" title="$url"$style />) if($title eq "");
	return qq(<img src="$enc_url" alt="$title" title="$title"$style />);
}

sub link_url{
	my ($url, $title) = @_;

	$url =~ s/^[ \t]+|[ \t]+$//g;
	$title =~ s/^[ \t]+|[ \t]+$//g;

	my $enc_url = encode_url($url);
	return qq(<a href="$enc_url">$url</a>) if($title eq "");
	return qq(<a href="$enc_url">$title</a>);
}

sub is_url{
	my $url = shift;

	# from parse_line
	$url =~ y/\x01/&/;

	# https://en.wikipedia.org/wiki/Percent-encoding
	return $url =~ m/^(?:$protocol)[%!*'();:@&=+\$,\/?#\[\]a-z0-9_.~-]+$/oi;
}

sub protect_urls{
	my $text = shift;
	$text =~ s/($protocol)/\x00$1/ogi;
	return $text;
}

sub encode_urls{
	my $text = shift;
	$text =~ s/(.*?)(.)((?:$protocol).*?)\2/$1$2@{[encode_url($3)]}$2/ogi;
	return $text;
}

sub encode_url{
	my $url = shift;

	# from parse_line
	$url =~ y/\x01/&/;

	# https://en.wikipedia.org/wiki/Percent-encoding
	$url =~ s/([^!*'();:@&=+\$,\/?#\[\]a-zA-Z0-9_.~-])/@{[sprintf "%%%x", ord($1)]}/g;
	return $url;
}

sub create_list{
	my @lines = split /\n/, shift;
	my $list = "";
	my $li_i = 0;
	my @li = ();
	my @li_attr = ();
	my $use_p = 0;
	my $p = 0;

	foreach(@lines){
		m/^( *)(?:([*+-]|: (.*?):) )?(.*)$/;
		my $i = length($1)/2+1;
		if($2 eq ""){
			if(--$i < $li_i){
				if($p){
					$list .= "</p>\n";
					$p = 0;
				}
				while(--$li_i>=$i){
					if($li[$li_i] eq "dl"){
						$list .= "</dd>\n";
					}else{
						$list .= "</li>\n";
					}
					$list .= "</$li[$li_i]>\n";
				}
				$li_i++;
			}
			if($4 eq "" || $4 eq "..."){
				$use_p = 1;
				if($p){
					$list .= "</p>\n";
					$p = 0;
				}
				next;
			}
			if($use_p && !$p){
				$list .= "<p>";
				$p = 1;
			}
			$list .= "$4\n";
			next;
		}
		$use_p = 0;
		if($p){
			$list .= "4</p>\n";
			$p = 0;
		}
		my $tag = substr $2, 0, 1;
		my $term = $3;
		my $item = $4;
		my $attr = "";
		if($tag eq "*"){
			$tag = "ul";
		}elsif($tag eq "+"){
			$tag = "ol";
		}elsif($tag eq "-"){
			$tag = "ol";
			$attr = q( reversed="reversed");
		}else{
			$tag = "dl";
		}
		if($i > $li_i){
			for(; $li_i<$i-1; $li_i++){
				$list .= "<$tag>\n";
				if($tag eq "dl"){
					$list .= "<dd>";
				}else{
					$list .= "<li>";
				}
				$li[$li_i] = $tag;
				$li_attr[$li_i] = "";
			}
			$list .= "<$tag$attr>\n";
			$li[$li_i] = $tag;
			$li_attr[$li_i++] = $attr;
		}elsif($i < $li_i){
			while(--$li_i>=$i){
				if($li[$li_i] eq "dl"){
					$list .= "</dd>\n";
				}else{
					$list .= "</li>\n";
				}
				$list .= "</$li[$li_i]>\n";
			}
			if($li[$li_i] eq $tag && $li_attr[$li_i] eq $attr){
				if($li[$li_i] eq "dl"){
					$list .= "</dd>\n";
				}else{
					$list .= "</li>\n";
				}
				$li_i++;
			}else{
				for(; $li_i>=0 && ($li[$li_i] ne $tag ||
					$li_attr[$li_i] ne $attr); $li_i--){
					if($li[$li_i] eq "dl"){
						$list .= "</dd>\n";
					}else{
						$list .= "</li>\n";
					}
					$list .= "</$li[$li_i]>\n";
				}
				while(++$li_i<$i-1){
					$list .= "<$tag>\n";
					$li[$li_i] = $tag;
					$li_attr[$li_i] = "";
				}
				$list .= "<$tag$attr>\n";
				$li[$li_i] = $tag;
				$li_attr[$li_i++] = $attr;
			}
		}elsif($li[$li_i-1] ne $tag || $li_attr[$li_i-1] ne $attr){
			if($li[$li_i-1] eq "dl"){
				$list .= "</dd>\n";
			}else{
				$list .= "</li>\n";
			}
			$list .= "</$li[$li_i-1]>\n<$tag$attr>\n";
			$li[$li_i-1] = $tag;
			$li_attr[$li_i-1] = $attr;
		}elsif($tag eq "dl"){
			$list .= "</dd>\n";
		}else{
			$list .= "</li>\n";
		}

		if($tag eq "dl"){
			$list .= "<dt>$term</dt>\n<dd>$item\n";
		}else{
			$list .= "<li>$item\n";
		}
	}
	if($p){
		$list .= "</p>\n";
		$p = 0;
	}
	while(--$li_i>=0){
		if($li[$li_i] eq "dl"){
			$list .= "</dd>\n";
		}else{
			$list .= "</li>\n";
		}
		$list .= "</$li[$li_i]>\n";
	}

	# Inline perl code
	$list =~ s/``(.*?)``(?!`)/$1/eeg;
	# Discard NONE characters
	$list =~ y/\x00//d;

	return $list;
}

sub create_table{
	my @lines = split /\n/, shift;
	my $caption = "";
	my $thead = "";
	my $tfoot = "";
	my $tbodies = "";
	my $tbody = "";

	foreach(@lines){
		my $end = substr $_, -1;
		if(m/^![ \t](.*[ \t])?!$/){
			(my $line = $1) =~ s/^[ \t]+|[ \t]+$//g;
			$caption .= " " if($caption ne "");
			$caption .= $line;
		}elsif($end eq "^"){
			$thead .= create_table_row($_);
		}elsif($end eq "!"){
			$tfoot .= create_table_row($_);
		}else{
			$_ = substr $_, 0, length($_) - 1 if($end eq "_");
			$tbody .= create_table_row($_);
			if($end eq "_" && $tbody ne ""){
				$tbody = update_table_rowspan($tbody);
				$tbodies .= "<tbody>\n$tbody</tbody>\n";
				$tbody = "";
			}
		}
	}
	if($tbody ne ""){
		$tbody = update_table_rowspan($tbody);
		$tbodies .= "<tbody>\n$tbody</tbody>\n";
	}

	my $table = "";
	return $table if($caption eq "" && $thead eq "" && $tbodies eq "" &&
		$tfoot eq "");

	$thead = update_table_rowspan($thead);
	$tfoot = update_table_rowspan($tfoot);

	$table = "<table>\n";
	$table .= "<caption>$caption</caption>\n" if($caption ne "");
	$table .= "<thead>\n$thead</thead>\n" if($thead ne "");
	$table .= $tbodies if($tbodies ne "");
	$table .= "<tfoot>\n$tfoot</tfoot>\n" if($tfoot ne "");
	$table .= "</table>\n";

	# Inline perl code
	$table =~ s/``(.*?)``(?!`)/$1/eeg;
	# Discard NONE characters
	$table =~ y/\x00//d;

	return $table;
}

sub create_table_row{
	my $row = shift;

	$row =~ s/(!+)$/@{["|" x length($1)]}/;

	# Empty cells
	$row =~ s#([|^])[ \t]+([|^]*)(?=[|^](?:[ \t]|$))#@{[create_table_cell($1, $2)]}#g;
	# Non-empty cells
	$row =~ s#([|^])[ \t]([ \t]*)([^ \t].*?)([ \t]*)[ \t]([|^]*)(?=[|^](?:[ \t]|$)|<t[hd] )#@{[create_table_cell($1, $5, $2, $3, $4)]}#g;
	$row =~ s/[|^]$//;

	return "<tr>$row</tr>\n";
}

sub create_table_cell{
	my ($type, $colspan, $left, $content, $right) = @_;

	$type = $type eq "^" ? "th" : "td";
	$colspan = length($colspan) + 1;
	$left = length($left);
	$right = length($right);

	$colspan = $colspan == 1 ? "" : qq( colspan="$colspan");
	my $align = $left == 0 ? "left" : ($right == 0 ? "right" : "center");
	return qq(<$type$colspan class="text-$align">$content</$type>);
}

sub update_table_rowspan{
	my $rows = shift;

	(my $rowspan = $rows) =~ s#</?tr>##g;
	$rowspan =~ s#<(t[hd]) [^>]+>\.\.\.</\1>#+#g;
	$rowspan =~ s#<(t[hd]) [^>]+>.*?</\1>#1#g;
	# $rowspan example:
	# 111
	# 1++
	# 11+

	my @rs = split /\n/, $rowspan;
	# Only one row
	return $rows if($#rs == 0);

	# The first row cannot be spanned from above.
	$rs[0] = "1" x length($rs[0]);
	# No row spans
	return $rows if(index(join("\n", @rs), "+") == -1);

	my @counts;
	for my $i (0..$#rs){
		my $c = 0;
		$counts[$i][$c++] = $_ foreach(split //, $rs[$i]);
	}
	# Count the number of row spans.
	for my $i (0..($#rs-1)){
		for my $c (0..$#{$counts[$i]}){
			last if($counts[$i][$c] eq "+");
			for my $j (($i+1)..$#rs){
				last if($counts[$j][$c] ne "+");
				$counts[$i][$c]++;
			}
		}
	}

	# Make it easy to replace back </th> and </td> later.
	# \x01-\x03 have already been converted to &amp;, &lt;, and &gt;.
	$rows =~ s#</th>#\x01\x03#g;
	$rows =~ s#</td>#\x02\x03#g;

	my @cells;
	my @rows = split /\n/, $rows;
	for my $i (0..$#rows){
		my $c = 0;
		$cells[$i][$c++] = $_ foreach(split /\x03/, $rows[$i]);
	}

	for my $i (0..$#rs){
		for my $c (0..$#{$counts[$i]}){
			if($counts[$i][$c] > 1){
				$cells[$i][$c] =~ s/(<t[hd])(?=[> ])/$1 rowspan="$counts[$i][$c]"/;
			}elsif($counts[$i][$c] eq "+"){
				$cells[$i][$c] =~ s/<t[hd][> ].*[\x01\x02]//;
			}
		}
	}

	$rows = "";
	for my $i (0..$#rs){
		$rows .= join("", @{$cells[$i]})."\n";
	}
	$rows =~ s#\x01#</th>#g;
	$rows =~ s#\x02#</td>#g;

	return $rows;
}

sub create_figure{
	my @lines = split /\n/, shift;
	my $content = "";
	my $figcaption = "";
	my $figure = "";

	foreach(@lines){
		my $start = substr $_, 0, 1;
		(my $line = substr $_, 2, length($_)-4) =~ s/^[ \t]+|[ \t]+$//g;
		next if($line eq "");

		if($start eq "@"){
			$content .= " " if($content ne "");
			$content .= $line;
		}else{
			$figcaption .= " " if($figcaption ne "");
			$figcaption .= $line;
		}
	}

	return $figure if($content eq "" && $figcaption eq "");

	$figure = "<figure>\n";
	$figure .= "$content\n" if($content ne "");
	$figure .= "<figcaption>$figcaption</figcaption>\n"
		if($figcaption ne "");
	$figure .= "</figure>\n";

	# Inline perl code
	$figure =~ s/``(.*?)``(?!`)/$1/eeg;
	# Discard NONE characters
	$figure =~ y/\x00//d;

	return $figure;
}

sub is_logged_in{
	return $USER ne "";
}

sub has_read_access{
	return 1 if($admin);
	if($wiki){
		return 1 if($wiki_read_access eq "open");
		return 1 if($wiki_read_access eq "closed" && is_logged_in());
		return 0;
	}
	return 1 if($nonwiki_read_access eq "open");
	return 1 if($nonwiki_read_access eq "closed" && is_logged_in());
	return 0;
}

sub has_write_access{
	return 1 if($admin);
	return 0 unless($wiki);
	return 1 if($wiki_write_access eq "open");
	return 1 if($wiki_write_access eq "closed" && is_logged_in());
	return 0;
}

sub page_exists{
	my $page = shift;
	$page = $PAGE unless(defined $page);
	return -f "$page.txt";
}

#-------------------------------------------------------------------------------
# Password file
sub write_pw{
	my $file = $PASSWORD_FILE eq "" ? "u.pw" : $PASSWORD_FILE;
	write_file($file, "$adminpw\n") unless(-f $file);
}

#-------------------------------------------------------------------------------
# Default config
sub process_cfg{
	# $mode=undef: eval
	# $mode=1: write
	my $mode = shift;
	my $cfg = <<'EOT_UNIQKI';
# Site information: HTML tags are allowed.
$SITE_TITLE = 'Uniqki: A Personal Wiki Builder';
$SITE_DESCRIPTION = 'A <a href="http://uniqki.isnew.info">Uniqki</a> site';

# Index page
$INDEX_PAGE = 'index';

# Language
$LANG = 'en';

# Character set
$CHARSET = 'utf-8';

# Locale: Setting this variable to an empty string uses the default locale.
$LOCALE = '';

# Set time zone if different from the system time
$TIME_ZONE = '';

# Time format interpreted by the POSIX::strftime function.  Set this variable
# to an empty string to use Perl's scalar localtime.
$TIME_FORMAT = '%a %b %e %H:%M:%S %Y';

# Share cookies: [subdomains:][EMPTY|subpaths|all_paths]
# * subdomains: http://example.com/u shares cookies with
# 		http://www.example.com.
# * EMPTY: http://example.com/path1/u does not share cookies with
#	   http://example.com/u, http://example.com/path2/u, nor
#	   http://example.com/path1/subpath1/u.
# * subpaths: http://example.com/path1/u shares cookies with
# 	      http://example.com/path1/subpath1/u, but not with
# 	      http://example.com/u nor http://example.com/path2/u.
# * all_paths: http://example.com/path1/u shares cookies with
#	       http://example.com/u, http://example.com/path2/u, and
#	       http://example.com/path1/subpath1/u.
#
# It is possible to combine subdomains and one of EMPTY, subpaths, and
# all_paths.  For example,
# * subdomains:all_paths: http://example.com/path1/u shares cookies with
#			  http://www.example.com/u.
#
# An empty setting '' means that cookies are not shared with other subdomains
# nor paths.  Subdomains and specified paths have to use the password and
# sessions files in the current domain and path to share login sessions.
# Subpaths does not work with $doc_root because the script and document
# directories are different.
$SHARE_COOKIES = '';

# WARNING: Make sure to protect these files and directories from the user using
# the following directives in .htaccess:
# <Files ~ "(^u\.(cfg|pw|msg)|^\.sessions|\.(tpl|txt|txt\.v))$">
#	Deny from all
# </Files>

# Password file: The admin password can be embedded in the script as $adminpw.
$PASSWORD_FILE = 'u.pw';

# Sessions file: The default sessions file is .sessions.
$SESSIONS_FILE = '.sessions';

# Messages file: The default messages will be printed if missing.
$MESSAGES_FILE = 'u.msg';

# Template directory: The default template will be served by the script if
# missing.
$TEMPLATE_DIRECTORY = 'u.tpl';

# Page name style: case[:dots|:no_dots][:hyphens|:underscores|:no_spaces]
# * lower_case (default): All lower case (e.g., page in a uniqki site)
# * upper_case: All upper case (e.g., PAGE IN A UNIQKI SITE)
# * mixed_case: No special handling of letter case (e.g., Page in a Uniqki site)
# * start_case: Start case (e.g., Page In A Uniqki Site)
# * lower_camel_case: Lower camel case (e.g., pageInAUniqkiSite)
# * upper_camel_case: Upper camel case (e.g., PageInAUniqkiSite)
#
# Dots
# * dots (default): Replace a series of dots with a dot.  Dots separate words
#		    for a case conversion.
# * no_dots: Remove dots.  The lower_camel_case and upper_camel_case styles
#	     imply this option.  For example, upper_camel_case is the same as
#	     start_case:no_dots:no_spaces.
#
# Spaces
# * hyphens (default): Replace a series of whitespaces with a hyphen
# * underscores: Replace a series of whitespaces with an underscore
# * no_spaces: Remove whitespaces.  The lower_camel_case and upper_camel_case
# 	       styles imply this option.  For example, lower_camel_case is the
# 	       same as lower_camel_case:no_dots:no_spaces.
#
# The following special characters will be replaced with spaces and separate
# words before a case conversion: `~!@#$%^&*=+\|;:'",/?()[]{}<>
#
# Hyphens (-) and underscores (_) will be converted to spaces and may be
# converted back to hyphens or underscores depending on the page name style.
#
# For example, "'page' in a uniqki site!!!" excluding double quotes in the
# start_case style will create and link to Page-In-A-Uniqki-Site.html.  The
# same page name in the upper_camel_case style will use PageInAUniqkiSite.html.
$PAGE_NAME_STYLE = 'lower_case:dots:hyphens';

# Login session will be extended by this number of minutes whenever any action
# is taken by the user.
$INACTIVE_TIMEOUT = 24*60;

# Change password timeout in minutes
$SET_PASSWORD_TIMEOUT = 60;

# Reset password timeout in minutes
$RESET_PASSWORD_TIMEOUT = 1;

# Email address from which user notifications are sent: 'Your Name
# <you@example.com>' is not supported.  Enter your email address only as in
# 'you@example.com'.  Make sure to use single quotes instead of double quotes.
$EMAIL_ADDRESS = '';

# SMTP settings: If this variable is empty, email will be sent using sendmail.
# The format of this variable is 'server:port:username:password'.  The password
# may contain colons (:), but the username cannot.
$SMTP = '';

# Read access control
# * open: Opens both non-wiki and wiki pages to the public and anyone will be
# 	  able to read those pages with or without a login.
# * closed: Requires a login to perform any read actions including search, diff,
#	    etc.  In addition, the following directives in .htaccess will
#	    prevent direct access to *.html files, effectively making the
#	    entire site read-secured.
# * admin: Allows only admin users access to non-wiki and wiki pages.  The
#	   .htaccess directives are required.
#
# Non-wiki and wiki pages can have different settings separated by a colon.
# For example, closed:open means closed non-wiki and open wiki pages.  One
# setting applies to both non-wiki and wiki pages.  That is, open is the same
# as open:open (open non-wiki and open wiki).
#
# Unless this variable is open:open, the following .htaccess directives are
# required to secure *.html files:
# RewriteEngine On
# RewriteBase /
# RewriteRule ^$ u [R,L]
# RewriteRule ^([^/]*)\.html$ u/$1 [R,L]
# RewriteRule ^(u/[^/]*)\.html$ $1 [R,L]
# RewriteCond %{REQUEST_URI} !/u($|[/?])
# RewriteRule .* "-" [F]
$READ_ACCESS = 'open';

# Write access control
# * open: Allows anyone to edit or create wiki pages with or without a login.
# * closed: Requires a login to edit or create wiki pages.
# * admin: Requires admin rights to edit or create wiki pages.
#
# Creating new wiki pages also depends on $WIKI_ALLOWED_PAGES.  For security
# reasons, non-wiki pages are writable only by admin users and this variable
# cannot affect that behavior.
$WRITE_ACCESS = 'open';

# Header and footer files for the parser
$HEADER_FILE = '';
$FOOTER_FILE = '';

# Header and footer files for the wiki parser
$WIKI_HEADER_FILE = '';
$WIKI_FOOTER_FILE = '';

# Regular expression for wiki page names that are allowed to be created by
# non-admin users
$WIKI_ALLOWED_PAGES = q();

# Regular expression for file names that are allowed to be uploaded by
# non-admin users to a wiki page
$WIKI_ALLOWED_FILES = q(\.(png|gif|jpg|jpeg|txt|zip)$);
EOT_UNIQKI
	my $file = $CFG eq "" ? "u.cfg" : $CFG;
	if($mode == 1){
		write_file($file, $cfg) unless(-f $file);
	}else{
		eval $cfg;
		do $file if(-f $file);
	}
}

#-------------------------------------------------------------------------------
# Default messages
sub process_msg{
	# $mode=undef: eval if file does not exist, do file otherwise
	# $mode=1: write
	my $mode = shift;
	my $msg = <<'EOT_UNIQKI';
%MESSAGES = (
################################################################################
# Template messages: These messages don't support printf format specifiers such
# as %s because there is no way to pass arguments to these messages from the
# template.  However, the [[PAGE]] tag can be used to generate dynamic text.
powered_by_uniqki => q(Powered by <a href="http://uniqki.isnew.info">Uniqki</a>!),

username => q(Username),
password => q(Password),
logout_from_other_computers => q(Logout from other computers),
view => q(View),

manage_pages => q(Manage pages),
backup => q(Backup),
restore => q(Restore),

manage_users => q(Manage users),
add_user => q(Add user),
update_user => q(Update user),
block_user => q(Block user),
unblock_user => q(Unblock user),
delete_user => q(Delete user),
email_address => q(Email address),
full_name => q(Full name),
non_admin => q(Non-admin),
admin => q(Admin),
dont_change => q(Don't change),
type_password_again => q(Type password again),
username_requirements => q(Username requirements: 4 or more letters (a-z, A-Z) and digits (0-9).),
full_name_requirements => q(Full name requirements: 5 or more letters without digits (0-9) and special characters.),
password_requirements => q(Password requirements: 8 or more characters with at least one letter (a-z, A-Z), one digit (0-9), and one special character excluding spaces and tabs.),
leave_password_blank_for_email_notification => q(Leave the password field blank for an email notification with a temporary link for resetting the password.),

manage_myself => q(Manage myself),
update_myself => q(Update myself),
delete_myself => q(Delete myself),

forgot_password => q(Forgot password),
enter_username_or_email_address => q(Please enter a username or an email address.),
user_info_mismatch => q(User information mismatch!),
email_address_not_found => q(%s: Email address not found.),
user_blocked => q(%s: User blocked.),

reset_password => q(Reset password),
password_reset_token_expired => q(Password reset token expired.),
password_reset_token_still_valid => q(You still have a valid password reset token. Please refer to the last email notification.),
invalid_password_reset_token => q(Invalid password reset token.),
password_reset_token_not_found => q(Password reset token not found.),

refresh => q(Refresh),
edit => q(Edit),
index => q(Index),
loginout => q(Loginout),
login => q(Login),
logout => q(Logout),
diff => q(Diff),
backlinks => q(Backlinks),
last_modified => q([[TIME]] by [[AUTHOR]]),
unknown_author => q(Unknown),
xhtml => q(XHTML),
css => q(CSS),

preview => q(Preview),
save => q(Save),
file_upload => q(File upload: ),
cancel => q(Cancel),
preview_warning => q(This document is preview. Please make sure to save your changes.),

page_updated => q([[PAGE]] updated!),
save_your_changes_and_read_latest_version => q(Please save your changes and read <a href="[[PAGE]].html">the latest version</a>!),

edit_page => q(Edit [[PAGE]]),
wiki_edit_page => q(WikiEdit [[PAGE]]),

################################################################################
# Non-template messages: These messages support printf format specifiers such
# as %s, but [[...]] tags cannot be used.
internal_errors => q(Internal errors),
session_errors => q(Session errors),
perl_module_not_installed => q(%s: Perl module not installed.),

change_admin_password => q(The admin password cannot be the same as the temporary password. <a href="?manage_myself">Change your password.</a>),

read_secured => q(You are not allowed to read this page.),
login_not_allowed => q(Login is not allowed.),
login_failed => q(Login failed.),
admin_actions_not_allowed => q(Admin actions are not allowed. Please <a href="?login">login</a> first.),

cannot_add_yourself => q(You cannot add yourself.),
cannot_block_yourself => q(You cannot block yourself.),
cannot_unblock_yourself => q(You cannot unblock yourself.),
cannot_delete_yourself => q(You cannot delete yourself.),
cannot_delete_only_admin => q(You cannot delete yourself because you are the only admin.),
user_already_blocked => q(%s: User already blocked.),
user_already_unblocked => q(%s: User already unblocked.),
user_already_exists => q(%s: User already exists.),
email_address_already_registered => q(%s: Email address already registered.),
enter_user_info_to_update => q(%s: Please enter user information to update.),
user_not_found => q(%s: User not found.),

enter_username => q(Please enter a username to manage.),
check_username => q(Please enter a username that meets character requirements.),
enter_email_address => q(Please enter an email address.),
check_email_address => q(Please enter a valid email address.),
leave_email_address_blank => q(Please leave the email address blank.),
enter_full_name => q(Please enter the user's full name.),
check_full_name => q(Please enter a full name that meets character requirements.),
check_password => q(Please enter a password that meets the length and character requirements.),
confirm_password => q(Please confirm the password.),
leave_password_blank => q(Please leave the password blank.),

new_user_email_subject => q(%s: Registered),
new_user_email_text => q(Your username %s is registered at %s. Please set your password by visiting %s within %d minutes.),
unblocked_user_email_subject => q(%s: Unblocked),
unblocked_user_email_text => q(Your username %s is unblocked at %s. Please set your password by visiting %s within %d minutes.),
reset_password_email_subject => q(%s: Reset password),
reset_password_email_text => q(Please reset your password for username %s at %s by visiting %s within %d minutes.),
email_notification_failed => q(Email notification failed for user %s <%s>.),

page_not_found => q(%s: Page not found.),
create_page => q(%s: Page not found. <a href="?edit">Create this page.</a>),
not_wiki_page => q(%s: This page is not a wiki page.),
not_allowed_to_create_nonwiki_page => q(%s: You are not allowed to create this non-wiki page.),
not_allowed_to_create_wiki_page => q(%s: You are not allowed to create this wiki page.),
not_allowed_to_edit_wiki_page => q(%s: You are not allowed to edit this wiki page.),
path_not_found => q(%s: Path not found.),

recent_changes => q(Recent changes),
recent_changes_matching => q(Recent changes matching %s pattern),
old_changes => q(Old changes),
old_changes_matching => q(Old changes matching %s pattern),
all_pages => q(All pages),
all_pages_matching => q(All pages matching %s pattern),
all_pages_reversed => q(All pages in reversed order),
all_pages_reversed_matching => q(All pages matching %s pattern in reverse order),
refresh_pages => q(Refresh pages),
refresh_pages_matching => q(Refresh pages matching %s pattern),
search => q(Search for %s),
search_matching => q(Search %s for %s),
differences => q(Differences of <a href="%s">%1$s</a> between versions %d and %d),

goto_form => q(Goto form),
goto_form_goto => q(Go to),
search_form => q(Search form),
search_form_search => q(Search),
search_form_simple => q(Simple),
search_form_ignore_case => q(Ignore case),
search_form_links => q(Links),
search_form_print_titles => q(Print titles),
search_form_dont_print_matches => q(Don't print matches),
comment_form => q(Comment form),
comment_form_leave_this_field_blank => q(Please leave this field blank: ),
comment_form_write => q(Write),
specify_comment_page => q(Please specify a comment page.),
comment_tag_not_found => q(%s: Comment tag not found.),
invalid_comment_tag => q(%s: Invalid comment tag.),

current_version => q(The current version of <a href="%s">%1$s</a> is %d.),
wiki_file_uploaded => q(%s: File uploaded. Copy and paste the link below:<pre id="file-link-example">{{%s|%1$s}}</pre>),
file_uploaded => q(%s: File uploaded. Copy and paste the link below:<pre id="file-link-example">{{%1$s}}</pre>),
page_files => q(Files belonging to <a href="../%s">%1$s</a>),

table_of_contents => q(Table of contents),
);
EOT_UNIQKI
	my $file = $MESSAGES_FILE eq "" ? "u.msg" : $MESSAGES_FILE;
	if($mode == 1){
		write_file($file, $msg) unless(-f $file);
	}else{
		eval $msg;
		do $file if(-f $file);
	}
}

sub get_msg{
	my $msg_id = shift;
	return sprintf $MESSAGES{$msg_id}, @_;
}

sub is_username{
	my $user = shift;
	my $len = length($user);
	return $len >= 4 && $len <= 64 && $user =~ m/^[a-zA-Z0-9]+$/;
}

sub is_password{
	my $pw = shift;
	my $len = length($pw);
	return $len >= 8 && $len <= 128 &&
		$pw =~ m/[a-zA-Z]/ && $pw =~ m/[0-9]/ &&
		$pw =~ m/[`~!@#\$%^&*_+=\\|;:'",.\/?()\[\]{}<>]/;
}

sub is_email_address{
	# Regex: http://www.regular-expressions.info/email.html
	my $email = shift;
	my $len = length($email);
	return $len >= 6 && $len <= 254 &&
		$email =~ m/^[a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,}$/i;
}

sub is_full_name{
	my $name = shift;
	$name =~ s/[ \t]+/ /g;
	$name =~ s/^ | $//g;
	my $len = length($name);
	return $len >= 5 && $name !~ m/[`~!@#\$%^&*_=+\\|;:'",\/?()\[\]{}<>0-9-]/;
}

sub is_session_id{
	my $session_id = shift;
	my $len = length($session_id);
	return $len == 64 && $session_id =~ m/^[a-zA-Z0-9]+$/;
}

sub is_password_reset_token_valid{
	my $token = shift;
	if($token !~ m/^[a-zA-Z0-9]{8}[0-9a-f]{40}\.([0-9]+)$/){
		return 0;
	}
	my $expires = $1;
	my $time = time;
	return $time < $expires;
}

#-------------------------------------------------------------------------------
# Default template
sub process_tpl_tag{
	my $tag = shift;
	local *FH;
	my $txt = "";

	open FH, ">", \$txt; my $fh = select FH;
	if($tag eq "HEADER"){
		print_header();
	}elsif($tag eq "FOOTER"){
		print_footer();
	}elsif($tag eq "EDIT"){
		print_edit();
	}elsif($tag eq "WIKI_EDIT"){
		print_wiki_edit();
	}elsif($tag =~ m/^[A-Z_]+$/){
		my @tags = qw(
			SITE_TITLE SITE_DESCRIPTION INDEX_PAGE TITLE LANG
			CHARSET PAGE VERSION TEXT HTTP_BASE DOC_BASE PREVIEW
			TIME CGI MESSAGE PASSWORD_RESET_TOKEN NAME AUTHOR
		);
		my %hash;
		@hash{@tags} = undef;

		no strict;
		$txt = $$tag if(exists $hash{$tag});
	}elsif($tag =~ m/^[a-z_]+$/){
		$txt = get_msg($tag);
		my @tags = qw(
			PAGE TIME AUTHOR
		);

		no strict;
		foreach(@tags){
			$txt =~ s/\[\[$_\]\]/$$_/g;
		}
	}
	close FH; select $fh;
	chomp $txt;

	return $txt;
}

sub process_tpl{
	# $mode=undef: print
	# $mode=1: write
	# $mode=2: print for CSS and JavaScript only
	my ($file, $mode, $tpl) = @_;
	my $path = "$TEMPLATE_DIRECTORY/$file";

	start_html() unless(defined $mode);
	if($mode == 2){
		if(".css" eq substr $file, -4){
			print "Content-Type: text/css\n\n";
		}elsif(".js" eq substr $file, -3){
			print "Content-Type: text/javascript\n\n";
		}
	}

	if($mode == 1){
		write_file($path, $tpl) if(-d $TEMPLATE_DIRECTORY && !-f $path);
		return;
	}elsif(-f $path){
		$tpl = read_file($path);
	}

	$tpl =~ s/\[\[([A-Za-z_]*)\]\]/@{[process_tpl_tag($1)]}/g;
	print $tpl;
}

sub print_header{
	my $mode = shift;
	return if(!defined $mode && $header_printed);

	$header_printed = 1;
	process_tpl("header.tpl", $mode, <<'EOT_UNIQKI'
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="[[LANG]]">
<head>
<title>[[TITLE]]</title>
<meta charset="[[CHARSET]]" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="stylesheet" type="text/css" href="[[CGI]]?css" />
<link rel="alternate" type="application/rss+xml" title="[[recent_changes]]" href="[[CGI]]?rss" />
<script src="[[CGI]]/[[PAGE]]?js"></script>
</head>
<body>
<div id="container">
<div id="top">
<div id="site-title"><a href="[[DOC_BASE]]">[[SITE_TITLE]]</a></div>
<div id="site-description">[[SITE_DESCRIPTION]]</div>
</div>
<div id="main">
EOT_UNIQKI
	)
}

sub print_footer{
	my $mode = shift;
	return if(!defined $mode && $footer_printed);

	$footer_printed = 1;
	process_tpl("footer.tpl", $mode, <<'EOT_UNIQKI'
</div>
<div id="bottom">
<span id="validators">
<a href="https://validator.w3.org/check?uri=referer">[[xhtml]]</a> .
<a href="https://jigsaw.w3.org/css-validator/check/referer">[[css]]</a>
</span> .
[[powered_by_uniqki]]
</div>
</div>
</body>
</html>
EOT_UNIQKI
	)
}

sub print_login{
	process_tpl("login.tpl", shift, <<'EOT_UNIQKI'
[[HEADER]]
<div id="login">
<h1>[[login]]</h1>
<form action="[[PAGE]]?login" method="post">
<div>
<input accesskey="u" type="text" id="user" name="user" placeholder="[[username]]" />
<input accesskey="p" type="password" id="pw" name="pw" placeholder="[[password]]" />
<input accesskey="l" type="submit" value="[[login]]" />
<br />
<input type="checkbox" id="logout_others" name="logout_others" value="1" /> [[logout_from_other_computers]]
</div>
</form>
</div>
<hr />
<div id="menu">
<span class="read-access"><a accesskey="v" href="[[PAGE]].html">[[view]]</a> .</span>
<a accesskey="i" href="[[INDEX_PAGE]].html">[[index]]</a>
</div>
[[FOOTER]]
EOT_UNIQKI
	)
}

sub print_manage_pages{
	process_tpl("manage_pages.tpl", shift, <<'EOT_UNIQKI'
[[HEADER]]
<div id="manage-pages">
<h1>[[manage_pages]]</h1>
<form action="?restore" method="post" enctype="multipart/form-data">
<div>
[[backup]]: <a href="[[CGI]]?backup">[[all_pages]]</a> .
<a href="?backup">[[PAGE]]</a>
<br />
[[restore]]: <input accesskey="f" type="file" id="file" name="file" />
<input accesskey="r" type="submit" value="[[restore]]" />
</div>
</form>
</div>
<hr />
<div id="menu">
<span class="read-access"><a accesskey="v" href="[[PAGE]].html">[[view]]</a> .</span>
<a accesskey="i" href="[[INDEX_PAGE]].html">[[index]]</a> .
<a accesskey="l" href="[[PAGE]]?logout">[[logout]]</a>
</div>
[[FOOTER]]
EOT_UNIQKI
	)
}

sub print_manage_users{
	process_tpl("manage_users.tpl", shift, <<'EOT_UNIQKI'
[[HEADER]]
<div id="manage-users">
<h1>[[manage_users]]</h1>
<ul>
<li>[[username_requirements]]</li>
<li>[[full_name_requirements]]</li>
<li>[[password_requirements]]</li>
<li>[[leave_password_blank_for_email_notification]]</li>
</ul>

<h2>[[add_user]]</h2>
<form action="?add_user" method="post">
<div>
<input accesskey="u" type="text" id="user" name="user" placeholder="[[username]]" />
<input accesskey="e" type="text" id="email" name="email" placeholder="[[email_address]]" />
<input accesskey="f" type="text" id="name" name="name" placeholder="[[full_name]]" />
<br />
<input type="radio" id="admin" name="admin" value="no" /> [[non_admin]]
<input type="radio" id="admin" name="admin" value="yes" /> [[admin]]
<br />
<input accesskey="p" type="password" id="pw" name="pw" placeholder="[[password]]" />
<input type="password" id="pw2" name="pw2" placeholder="[[type_password_again]]" />
<br />
<input type="submit" value="[[add_user]]" />
</div>
</form>

<h2>[[update_user]]</h2>
<form action="?update_user" method="post">
<div>
<input accesskey="u" type="text" id="user" name="user" placeholder="[[username]]" />
<input accesskey="e" type="text" id="email" name="email" placeholder="[[email_address]]" />
<input accesskey="f" type="text" id="name" name="name" placeholder="[[full_name]]" />
<br />
<input type="radio" id="admin" name="admin" value="no" /> [[non_admin]]
<input type="radio" id="admin" name="admin" value="yes" /> [[admin]]
<input type="radio" id="admin" name="admin" value="keep" /> [[dont_change]]
<br />
<input accesskey="p" type="password" id="pw" name="pw" placeholder="[[password]]" />
<input type="password" id="pw2" name="pw2" placeholder="[[type_password_again]]" />
<br />
<input type="submit" value="[[update_user]]" />
</div>
</form>

<h2>[[block_user]]</h2>
<form action="?block_user" method="post">
<div>
<input accesskey="u" type="text" id="user" name="user" placeholder="[[username]]" />
<br />
<input type="submit" value="[[block_user]]" />
</div>
</form>

<h2>[[unblock_user]]</h2>
<form action="?unblock_user" method="post">
<div>
<input accesskey="u" type="text" id="user" name="user" placeholder="[[username]]" />
<br />
<input accesskey="p" type="password" id="pw" name="pw" placeholder="[[password]]" />
<input type="password" id="pw2" name="pw2" placeholder="[[type_password_again]]" />
<br />
<input type="submit" value="[[unblock_user]]" />
</div>
</form>

<h2>[[delete_user]]</h2>
<form action="?delete_user" method="post">
<div>
<input accesskey="u" type="text" id="user" name="user" placeholder="[[username]]" />
<br />
<input type="submit" value="[[delete_user]]" />
</div>
</form>
</div>
<hr />
<div id="menu">
<span class="read-access"><a accesskey="v" href="[[PAGE]].html">[[view]]</a> .</span>
<a accesskey="i" href="[[INDEX_PAGE]].html">[[index]]</a> .
<a accesskey="l" href="[[PAGE]]?logout">[[logout]]</a>
</div>
[[FOOTER]]
EOT_UNIQKI
	)
}

sub print_manage_myself{
	process_tpl("manage_myself.tpl", shift, <<'EOT_UNIQKI'
[[HEADER]]
<div id="manage-myself">
<h1>[[manage_myself]]</h1>

<h2>[[update_myself]]</h2>
<ul>
<li>[[full_name_requirements]]</li>
<li>[[password_requirements]]</li>
</ul>

<form action="?update_myself" method="post">
<div>
<input accesskey="e" type="text" id="email" name="email" placeholder="[[email_address]]" />
<input accesskey="f" type="text" id="name" name="name" placeholder="[[full_name]]" />
<br />
<input accesskey="p" type="password" id="pw" name="pw" placeholder="[[password]]" />
<input type="password" id="pw2" name="pw2" placeholder="[[type_password_again]]" />
<br />
<input type="submit" value="[[update_myself]]" />
</div>
</form>

<h2>[[delete_myself]]</h2>
<form action="?delete_myself" method="post">
<div>
<input type="submit" value="[[delete_myself]]" />
</div>
</form>
</div>
<hr />
<div id="menu">
<span class="read-access"><a accesskey="v" href="[[PAGE]].html">[[view]]</a> .</span>
<a accesskey="i" href="[[INDEX_PAGE]].html">[[index]]</a> .
<a accesskey="l" href="[[PAGE]]?logout">[[logout]]</a>
</div>
[[FOOTER]]
EOT_UNIQKI
	)
}

sub print_forgot_password{
	process_tpl("forgot_password.tpl", shift, <<'EOT_UNIQKI'
[[HEADER]]
<div id="forgot-password">
<h1>[[forgot_password]]</h1>
<form action="?forgot_password" method="post">
<div>
<input accesskey="u" type="text" id="user" name="user" placeholder="[[username]]" />
<input accesskey="e" type="text" id="email" name="email" placeholder="[[email_address]]" />
<br />
<input type="submit" value="[[forgot_password]]" />
</div>
</form>
</div>
<hr />
<div id="menu">
<span class="read-access"><a accesskey="v" href="[[PAGE]].html">[[view]]</a> .</span>
<a accesskey="i" href="[[INDEX_PAGE]].html">[[index]]</a>
</div>
[[FOOTER]]
EOT_UNIQKI
	)
}

sub print_reset_password{
	process_tpl("reset_password.tpl", shift, <<'EOT_UNIQKI'
[[HEADER]]
<div id="reset-password">
<h1>[[reset_password]]</h1>
<ul>
<li>[[password_requirements]]</li>
</ul>

<form action="?reset_password" method="post">
<div>
<input type="hidden" id="token" name="token" value="[[PASSWORD_RESET_TOKEN]]" />
<input accesskey="p" type="password" id="pw" name="pw" placeholder="[[password]]" />
<input type="password" id="pw2" name="pw2" placeholder="[[type_password_again]]" />
<br />
<input type="submit" value="[[reset_password]]" />
</div>
</form>
</div>
<hr />
<div id="menu">
<span class="read-access"><a accesskey="v" href="[[PAGE]].html">[[view]]</a> .</span>
<a accesskey="i" href="[[INDEX_PAGE]].html">[[index]]</a>
</div>
[[FOOTER]]
EOT_UNIQKI
	)
}

sub print_message{
	process_tpl("message.tpl", shift, <<'EOT_UNIQKI'
[[HEADER]]
<div id="message">
[[MESSAGE]]
</div>
<hr />
<div id="menu">
<span class="read-access"><a accesskey="v" href="[[PAGE]].html">[[view]]</a> .</span>
<span class="write-access"><a accesskey="v" href="[[PAGE]]?edit">[[edit]]</a> .</span>
<a accesskey="i" href="[[INDEX_PAGE]].html">[[index]]</a> .
<a class="visitor" accesskey="l" href="[[PAGE]]?login">[[login]]</a>
<a class="user" accesskey="l" href="[[PAGE]]?logout">[[logout]]</a>
</div>
[[FOOTER]]
EOT_UNIQKI
	)
}

sub print_view{
	# View templates are never served dynamically, so don't print a
	# content-type header
	$html_started = 1;
	process_tpl("view.tpl", shift, <<'EOT_UNIQKI'
[[HEADER]]
<div id="view">
<!-- start text -->
[[TEXT]]
<!-- end text -->
</div>
<hr />
<div id="menu">
<a accesskey="r" href="[[CGI]]/[[PAGE]]?refresh">[[refresh]]</a> .
<span class="write-access"><a accesskey="e" href="[[CGI]]/[[PAGE]]?edit">[[edit]]</a> .</span>
<a accesskey="i" href="[[INDEX_PAGE]].html">[[index]]</a> .
<a class="visitor" accesskey="l" href="[[CGI]]/[[PAGE]]?login">[[login]]</a>
<a class="user" accesskey="l" href="[[CGI]]/[[PAGE]]?logout">[[logout]]</a>
</div>
<div id="last_modified">[[last_modified]]</div>
[[FOOTER]]
EOT_UNIQKI
	)
}

sub print_edit{
	process_tpl("edit.tpl", shift, <<'EOT_UNIQKI'
[[HEADER]]
<div id="edit">
<h1>[[edit_page]]</h1>
<form action="[[PAGE]]?edit" method="post" enctype="multipart/form-data">
<div>
<input type="hidden" id="version" name="version" value="[[VERSION]]" />
<textarea accesskey="e" id="text" name="text" rows="24" cols="80">[[TEXT]]</textarea>
<br />
<input accesskey="p" type="submit" id="preview" name="preview" value="[[preview]]" />
<input accesskey="s" type="submit" id="save" name="save" value="[[save]]" /> .
<a accesskey="c" href="[[PAGE]].html">[[cancel]]</a> .
<a accesskey="i" href="[[INDEX_PAGE]].html">[[index]]</a>
<br />
[[file_upload]] <input accesskey="f" type="file" id="file" name="file" />
</div>
</form>
</div>
[[FOOTER]]
EOT_UNIQKI
	)
}

sub print_preview{
	process_tpl("preview.tpl", shift, <<'EOT_UNIQKI'
[[HEADER]]
<div id="preview-warning">[[preview_warning]]</div>
<div id="preview">
[[PREVIEW]]
</div>
[[EDIT]]
[[FOOTER]]
EOT_UNIQKI
	)
}

sub print_updated{
	process_tpl("updated.tpl", shift, <<'EOT_UNIQKI'
[[HEADER]]
<div id="updated">
<h1>[[page_updated]]</h1>
[[save_your_changes_and_read_latest_version]]
<br />
<textarea accesskey="e" id="text" name="text" rows="24" cols="80">[[TEXT]]</textarea>
</div>
[[FOOTER]]
EOT_UNIQKI
	)
}

sub print_wiki_view{
	# View templates are never served dynamically, so don't print a
	# content-type header
	$html_started = 1;
	process_tpl("wiki_view.tpl", shift, <<'EOT_UNIQKI'
[[HEADER]]
<div id="wiki-view">
<!-- start text -->
[[TEXT]]
<!-- end text -->
</div>
<div id="wiki-menu">
<span class="write-access"><a accesskey="e" href="[[CGI]]/[[PAGE]]?wiki_edit">[[edit]]</a> .</span>
<a accesskey="d" href="[[CGI]]/[[PAGE]]?diff=-1">[[diff]]</a> .
<a accesskey="l" href="[[CGI]]?search=[[PAGE]]%5C.html&amp;link=1">[[backlinks]]</a> .
<a accesskey="i" href="[[INDEX_PAGE]].html">[[index]]</a> .
<a class="visitor" accesskey="l" href="[[CGI]]/[[PAGE]]?login">[[login]]</a>
<a class="user" accesskey="l" href="[[CGI]]/[[PAGE]]?logout">[[logout]]</a>
</div>
<div id="last_modified">[[last_modified]]</div>
[[FOOTER]]
EOT_UNIQKI
	)
}

sub print_wiki_edit{
	process_tpl("wiki_edit.tpl", shift, <<'EOT_UNIQKI'
[[HEADER]]
<div id="wiki-edit">
<h1>[[wiki_edit_page]]</h1>
<form action="[[PAGE]]?wiki_edit" method="post" enctype="multipart/form-data">
<div>
<input type="hidden" id="version" name="version" value="[[VERSION]]" />
<textarea accesskey="e" id="text" name="text" rows="24" cols="80">[[TEXT]]</textarea><br />
<input accesskey="p" type="submit" id="preview" name="preview" value="[[preview]]" />
<input accesskey="s" type="submit" id="save" name="save" value="[[save]]" /> .
<a accesskey="c" href="[[PAGE]].html">[[cancel]]</a> .
<a accesskey="i" href="[[INDEX_PAGE]].html">[[index]]</a>
<br />
[[file_upload]] <input accesskey="f" type="file" id="file" name="file" />
</div>
</form>
</div>
[[FOOTER]]
EOT_UNIQKI
	)
}

sub print_wiki_preview{
	process_tpl("wiki_preview.tpl", shift, <<'EOT_UNIQKI'
[[HEADER]]
<div id="wiki-preview-warning">[[preview_warning]]</div>
<div id="wiki-preview">
[[PREVIEW]]
</div>
[[WIKI_EDIT]]
[[FOOTER]]
EOT_UNIQKI
	)
}

sub print_css{
	process_tpl("uniqki.css", shift, <<'EOT_UNIQKI'
/******************************************************************************/
body {
	background-color:	#eeeeee;
}
h1 {
	margin-top:		0px;
}
pre {
	background-color:	#eeeeee;
	border:			1px solid #dddddd;
	overflow:		auto;
}
table {
	border-collapse:	collapse;
}
table caption {
	text-align:		left;
	font-size:		smaller;
}
table th {
	border:			1px solid #999999;
	padding:		3px;
	background-color:	#eeeeee;
}
table td {
	border:			1px solid #999999;
	padding:		3px;
}
figure {
}
figure img {
}
figure figcaption {
	font-size:		smaller;
}
a {
	color:			green;
	text-decoration:	none;
}
a[href*="://"] {
	color:			blue;
}
form {
	margin:			0px;
}
textarea {
	width:			100%;
}

/******************************************************************************/
#container {
	max-width:		960px;
	margin:			auto;
}
#top {
}
#site-title {
	font-weight:		bold;
	font-size:		120%;
}
#site-title a {
	color:			black;
	text-decoration:	none;
}
#site-description {
	font-size:		smaller;
}
#main {
	background-color:	white;
	border:			1px solid #aaaaaa;
	padding:		10px;
	box-shadow:		5px 5px 5px #aaaaaa;
}
#login {
}
#manage-pages {
}
#manage-users {
}
#manage-myself {
}
#forgot-password {
}
#reset-password {
}
#message {
}
#menu {
	display:		none;
}
#last_modified {
	padding-top:		2px;
	font-size:		smaller;
}
#bottom {
	margin-top:		5px;
	text-align:		right;
	font-size:		smaller;
	font-style:		italic;
}
#validators {
}

/******************************************************************************/
#view {
}
#edit {
}
#preview-warning {
	background-color:	red;
	padding:		5px;
	margin-bottom:		10px;
}
#preview {
}
#updated {
}
#file-link-example {
	border-bottom:		1px dashed #999999;
	padding-bottom:		20px;
}

/******************************************************************************/
#wiki-view {
	background-color:	#eeeeee;
	color:			#000000;
	border:			1px solid #999999;
	padding:		5px;
}
#wiki-edit {
}
#wiki-preview-warning {
	background-color:	red;
	padding:		5px;
	margin-bottom:		10px;
}
#wiki-preview {
}
#wiki-menu {
	padding:		5px 5px 0px 5px;
	display:		none;
}

/******************************************************************************/
#toc {
}
.toc-heading {
	font-weight:		bold;
}
.toc-list {
}
.text-left {
	text-align:		left;
}
.text-center {
	text-align:		center;
}
.text-right {
	text-align:		right;
}

/******************************************************************************/
#diff {
}
.diff-unchanged {
	font-family:		monospace;
}
.diff-added {
	background-color:	#66cccc;
	color:			#000000;
	font-family:		monospace;
}
.diff-deleted {
	background-color:	#ff99cc;
	color:			#000000;
	font-family:		monospace;
	text-decoration:	line-through;
}
.diff-modified {
	background-color:	#cccccc;
	color:			#000000;
	font-family:		monospace;
}
.diff-modified-added {
	background-color:	#66cccc;
	color:			#000000;
	font-family:		monospace;
}
.diff-modified-deleted {
	background-color:	#ff99cc;
	color:			#000000;
	font-family:		monospace;
	text-decoration:	line-through;
}

/******************************************************************************/
#ls {
}
.ls-time {
	font-size:		70%;
	font-style:		italic;
}

/******************************************************************************/
.goto-input {
}

/******************************************************************************/
#search {
}
.search-highlight {
	font-weight:		bold;
}
.search-input {
}

/******************************************************************************/
.comment-website {
	display:		none;
}
.comment-input {
}
EOT_UNIQKI
	)
}

sub print_js{
	process_tpl("uniqki.js", shift, <<'EOT_UNIQKI'
/* http://developer.mozilla.org/en/docs/AJAX:Getting_Started */
function ajax_request(url, data, func){
	var xml_request = null;

	/* Create an XMLHTTP instance */
	if(window.XMLHttpRequest){ /* Mozilla, Safari, ... */
		xml_request = new XMLHttpRequest();
		if(xml_request.overrideMimeType){
			/* Some web servers return a non-standard mime type. */
			xml_request.overrideMimeType('text/xml');
		}
	}else
	if(window.ActiveXObject){ /* IE */
		try{
			xml_request = new ActiveXObject('Msxml2.XMLHTTP');
		}catch(e){
		try{
			xml_request = new ActiveXObject('Microsoft.XMLHTTP');
		}catch(e){}
		}
	}
	if(!xml_request){
		alert('Cannot create an XMLHTTP instance.');
		return;
	}

	/* This function has no arguments. */
	xml_request.onreadystatechange = function(){
		if(xml_request.readyState != 4)
			return;
		if(xml_request.status != 200)
			return;
		func(xml_request);
	}

	if(data == null)
		var method = 'GET';
	else{
		var method = 'POST';
		xml_request.setRequestHeader('Content-Type',
			'application/x-www-form-urlencoded');
	}

	/* xml_request.open(method, url, asynchronous) */
	xml_request.open(method, url, true);

	/* xml_request.send(POST data) */
	/* required even if the method is not POST. */
	xml_request.send(data);
}

/* http://forum.java.sun.com/thread.jspa?threadID=696590&tstart=105 */
function ajax_responseXML(xml_request){
	var xml = null;

	if(window.ActiveXObject){ /* IE */
		xml = document.createElement('div');
		xml.innerHTML = xml_request.responseText;

		/* Huidae Cho <http://geni.isnew.info> */
		xml.getElementById = function(id){
			for(var i = 0; i < this.childNodes.length; i++){
				if(id == this.childNodes[i].id)
					return this.childNodes[i];
			}
			return null;
		}
	}else
	if(window.XMLHttpRequest){
		xml = xml_request.responseXML;
	}

	return xml;
}

function process_menu(xml_request){
	var items = xml_request.responseText.split(':');
	var user = items[0];
	var admin = items[1];
	var has_read_access = items[2];
	var has_write_access = items[3];

	[].forEach.call(document.getElementsByClassName(
			user == '' ? 'user' : 'visitor'),
		function(el){
			el.parentNode.removeChild(el);
		});
	if(admin == 0)
		[].forEach.call(document.getElementsByClassName('admin'),
			function(el){
				el.parentNode.removeChild(el);
			});
	if(has_read_access == 0)
		[].forEach.call(document.getElementsByClassName('read-access'),
			function(el){
				el.parentNode.removeChild(el);
			});
	if(has_write_access == 0)
		[].forEach.call(document.getElementsByClassName('write-access'),
			function(el){
				el.parentNode.removeChild(el);
			});

	var menu = document.getElementById('menu');
	var wiki_menu = document.getElementById('wiki-menu');
	if(menu != null)
		menu.style.display = 'block';
	if(wiki_menu != null)
		wiki_menu.style.display = 'block';
}

ajax_request('[[CGI]]/[[PAGE]]?user_info', null, process_menu);
EOT_UNIQKI
	)
}

#-------------------------------------------------------------------------------
# Text file subroutines
sub lcs{
	my ($c0, $c1) = @_;
	my @lcs;
	my $s;
	for($s=0; $s<=$#$c0&&$s<=$#$c1; $s++){
		last if($$c0[$s] ne $$c1[$s]);
	}
	my ($e0, $e1);
	for($e0=$#$c0,$e1=$#$c1; $e0>$s&&$e1>$s; $e0--,$e1--){
		last if($$c0[$e0] ne $$c1[$e1]);
	}
	my ($m, $n);
	for($m=$s; $m<=$e0; $m++){
		for($n=$s; $n<=$e1; $n++){
			if($$c0[$m] eq $$c1[$n]){
				if($m && $n){
					$lcs[$m][$n] = $lcs[$m-1][$n-1] + 1;
				}else{
					$lcs[$m][$n] = 1;
				}
			}elsif($m && $n && $lcs[$m][$n-1]+0 > $lcs[$m-1][$n]+0){
				$lcs[$m][$n] = $lcs[$m][$n-1] + 0;
			}else{
				if($m){
					$lcs[$m][$n] = $lcs[$m-1][$n] + 0;
				}else{
					$lcs[$m][$n] = 0;
				}
			}
		}
	}
	my $i = $lcs[$e0][$e1];
	my @delta;
	$delta[$i] = ($e0+1).",".($e1+1);
	for($m=$e0,$n=$e1; $i>0&&$m>=$s&&$n>=$s; $m--,$n--){
		if($$c0[$m] eq $$c1[$n]){
			$delta[--$i] = "$m,$n";
		}elsif($lcs[$m][$n-1] > $lcs[$m-1][$n]){
			$m++;
		}else{
			$n++;
		}
	}
	return ($s, @delta);
}

sub diff{
	my @line0 = split /\n/, $_[0], -1; $#line0--;
	my @line1 = split /\n/, $_[1], -1; $#line1--;
	my ($s, @delta) = lcs(\@line0, \@line1);
	my ($m, $n) = ($s, $s);
	my $diff = "";
	for(my $i=0; $i<=$#delta; $i++,$m++,$n++){
		my ($x, $y) = split /,/, $delta[$i];
		if($x > $m){
			for(; $m<$x; $m++){
				$diff .= "-$m\n";
			}
		}
		if($y > $n){
			for(; $n<$y; $n++){
				$diff .= "+$m $line1[$n]\n";
			}
		}
	}
	return $diff;
}

sub patch{
	my @line0 = split /\n/, $_[0], -1; $#line0--;
	my @lined = split /\n/, $_[1];
	my $line0p = "";
	for(my $i=0; $i<=$#lined; $i++){
		if($lined[$i] =~ m/^\+/){
			my $p = index $lined[$i], " ";
			my $j = substr $lined[$i], 1, $p-1;
			my $l = substr $lined[$i], $p+1;
			if($j){
				$line0[$j-1] .= "\n$l";
			}else{
				$line0p .= "$l\n";
			}
		}else{
			$line0[substr $lined[$i], 1] = "\x00";
		}
	}
	$line0[0] = "$line0p$line0[0]";
	my $str = join "\n", @line0;
	$str .= "\n";
	$str =~ s/\x00\n//g;
	return $str;
}

sub save{
	my ($PAGE, $TEXT) = @_;

	my $version = 1;
	my $txtv;

	if(-f "$PAGE.txt"){
		local *FH;
		if(open FH, "$PAGE.txt.v"){
			my $line = <FH>;
			local $/ = undef;
			$txtv = $line.<FH>;
			close FH;
			my @items = split /:/, $line;
			$version = $items[0];
		}else{
			my $time = (stat "$PAGE.txt")[9];
			$txtv = "${version}::$time\n";
		}
		my $text = read_file("$PAGE.txt");

		my $diff = diff($TEXT, $text);
		if($diff eq ""){
			$rebuild = 1;
			return;
		}

		$version++;
		my $time = time;
		$txtv = "$version:$USER:$time\n$diff\x00\n$txtv";
	}else{
		my $time = time;
		$txtv = "$version:$USER:$time\n";
	}

	write_file("$PAGE.txt.v", $txtv);
	$rebuild = 1 if(write_file("$PAGE.txt", $TEXT));
}

sub get_author{
	my $PAGE = shift;
	local *FH;
	my $author = get_msg("unknown_author");
	if(open FH, "$PAGE.txt.v"){
		my @items = split /:/, <FH>;
		close FH;
		exit_message("internal_errors") unless(-f "$PAGE.txt");
		my $user = $items[1];
		if($user ne ""){
			@items = find_user_info($user);
			$author = $items[4];
		}
	}
	return $author;
}

sub get_version{
	my $PAGE = shift;
	local *FH;
	my $version = 0;
	if(open FH, "$PAGE.txt.v"){
		my @items = split /:/, <FH>;
		close FH;
		exit_message("internal_errors") unless(-f "$PAGE.txt");
		$version = $items[0];
	}elsif(-f "$PAGE.txt"){
		$version = 1;
	}
	return $version;
}

sub lock_file{
	my $file = shift;
	my $timeout = 60;
	my $i = 0;
	while(-f "$file.lock"){
		exit_message("internal_errors") if(++$i > $timeout);
		sleep 1;
	}
	$locked_files{$file} = 1;
	exit_message("internal_errors") unless(write_file("$file.lock"));
}

sub unlock_file{
	my $file = shift;
	unlink "$file.lock";
	delete $locked_files{$file};
}

sub preview{
	local $PAGE = shift;
	local $TEXT = shift;
	my $uploaded = shift;
	my $wiki_edit = shift;
	my $txt;

	local $TITLE = "";
	local $PREVIEW;
	local $wiki;

	write_file(\$txt, ($wiki_edit ? "#!wiki\n" : "")."$TEXT\n");

	$PREVIEW = parse_file(\$txt);
	chomp $PREVIEW;

	if($TITLE eq ""){
		if($PAGE eq $INDEX_PAGE){
			($TITLE = $SITE_TITLE) =~ s/<[^>]*>//g;
		}else{
			$TITLE = $PAGE;
		}
	}
	$PREVIEW = $uploaded.$PREVIEW;
	$TEXT =~ s/&/&amp;/g; $TEXT =~ s/</&lt;/g; $TEXT =~ s/>/&gt;/g;

	if($wiki_edit){
		print_wiki_preview();
	}else{
		print_preview();
	}
}

sub make_html{
	local $PAGE = shift;
	local $AUTHOR = get_author($PAGE);
	local $TIME = format_time((stat "$PAGE.txt")[9]);
	local $TITLE = "";
	local $TEXT = parse_file("$PAGE.txt");
	local $wiki;
	local *FH;

	if($TITLE eq ""){
		if($PAGE eq $INDEX_PAGE){
			($TITLE = $SITE_TITLE) =~ s/<[^>]*>//g;
		}else{
			$TITLE = $PAGE;
		}
	}

	$header_printed = 0;
	$footer_printed = 0;

	my $html;
	open FH, ">", \$html; my $fh = select FH;
	if($wiki){
		print_wiki_view();
	}else{
		print_view();
	}
	close FH; select $fh;
	$html =~ s/\r//g;

	lock_file("$PAGE.html");
	write_file("$PAGE.html", $html);
	chmod 0755, "$PAGE.html" if($hosting eq "awardspace");
	unlock_file("$PAGE.html");
}

sub rmrf{
	local *DH;
	foreach(@_){
		if(-f $_){
			unlink $_;
		}elsif(-d $_){
			my $dir = $_;
			opendir DH, $dir;
			my @i = map {"$dir/$_"} grep !/^\.{1,2}$/, readdir DH;
			closedir DH;
			rmrf(@i);
			rmdir $dir;
		}
	}
}

sub rmdirp{
	foreach(@_){
		my $dir = $_;
		while(index($dir, "/") >= 0){
			rmdir $dir;
			$dir =~ s#/[^/]*$##;
		}
		rmdir $dir;
	}
}

sub find{
	my $file = shift;
	if(-d $file){
		local *DH;
		my @list;
		opendir DH, $file;
		foreach(sort readdir DH){
			next if($_ eq "." || $_ eq "..");
			push @list, find("$file/$_");
		}
		closedir DH;
		return @list;
	}elsif(-f $file){
		return $file;
	}
}

sub get_var{
	my (%var, $v);
	foreach(split /&/, $QUERY_STRING){
		m/^([^=]*)=(.*)$/;
		$v = $1; $var{$v} = $2;
		$var{$v} =~ y/+/ /; $var{$v} =~ s/%0D//g;
		$var{$v} =~ s/%(..)/pack "c", hex($1)/eg;
	}
	read STDIN, my $content, $CONTENT_LENGTH;
	if(index($content, "\r\n") != -1){
		(my $boundary = $content) =~ s/\r\n.*$//s;
		$content =~ s/^$boundary\r\n//;
		$content =~ s/\r\n$boundary--\r\n$//;
		foreach(split /\r\n$boundary\r\n/, $content){
			my ($header, $body) = m/(.*?)\r\n\r\n(.*)$/s;
			$header =~ m/ name="(.*?)"/;
			my $name = $1;
			if($header =~ m/ filename="(.*?)"/){
				($var{$name} = $1) =~ s#^.*[/\\]##;
				$var{"$name="} = $body;
			}else{
				$body =~ s/\r//g;
				$var{$name} = $body;
			}
		}
	}else{
		foreach(split /&/, $content){
			m/^([^=]*)=(.*)$/;
			$v = $1; $var{$v} = $2;
			$var{$v} =~ y/+/ /; $var{$v} =~ s/%0D//g;
			$var{$v} =~ s/%(..)/pack "c", hex($1)/eg;
		}
	}
	return %var;
}

sub get_cookie_domain_path{
	(my $script_dir = $SCRIPT_NAME) =~ s#[^/]*$##;
	my $subdomains = 0;
	my $paths = "";
	foreach my $item (split /:/, $SHARE_COOKIES){
		if($item eq "subdomains"){
			$subdomains = 1;
		}elsif($item eq "subpaths" || $item eq "all_paths"){
			$paths = $item;
		}
	}
	return ($subdomains ? "domain=$HTTP_HOST; " : "").
		($paths eq "all_paths" ? "path=/" :
			($paths eq "subpaths" && $doc_root eq "" ?
				"path=$script_dir" : "path=$SCRIPT_NAME"));
}

sub set_cookie{
	my ($session_id, $expires) = @_;

	my @t = gmtime $expires;
	my @m = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);
	my @w = qw(Sun Mon Tue Wed Thu Fri Sat);
	my $expires = sprintf "%s, %02d-%s-%d %02d:%02d:%02d GMT",
		$w[$t[6]], $t[3], $m[$t[4]], $t[5]+1900, $t[2], $t[1], $t[0];

	print "Set-Cookie: uniqki=$session_id; $cookie_domain_path; ".
		"expires=$expires; secure; httponly\n";
}

sub clear_cookie{
	print "Set-Cookie: uniqki=; $cookie_domain_path; ".
		"expires=Tue, 01-Jan-1980 00:00:00 GMT; secure; httponly\n";
}

sub find_user_info{
	my $user = shift;
	local *FH;

	my $method = 0;
	# $method=0: No user found
	# $method=1: Use $PASSWORD_FILE
	# $method=2: Use $adminpw

	if($PASSWORD_FILE eq ""){
		# No password file is specified in u.cfg.  Since the password
		# file in the default config is u.pw, an empty $PASSWORD_FILE
		# was assigned by the user.
		if($adminpw eq $tmp_adminpw){
			# If $adminpw is still temporary, this situation can be
			# very dangerous because anyone can login using the
			# public temporary password.  Do not allow any login in
			# this case.
		}else{
			# If $adminpw has been changed, use this password.
			$method = 2;
		}
	}elsif(-f $PASSWORD_FILE){
		# Use the password file
		$method = 1;
	}elsif($adminpw eq $tmp_adminpw){
		# Password file does not exist and $adminpw is temporary.  The
		# first run of this script is this case.  Create the password
		# file only for the login action immediately before checking
		# credentials against the temporary password to avoid timing
		# attacks.
		$method = 2;
	}else{
		# Password file does not exist and $adminpw has been changed.
		# Assume that the user deleted the password file intentionally
		# for single file operations.
		$method = 2;
	}
	return if($method == 0);

	my $userline = "";
	if($method == 1){
		open FH, $PASSWORD_FILE;
		my @lines = grep /^$user:/, <FH>;
		close FH;

		if($#lines == 0){
			$userline = $lines[0];
			$userline =~ s/[\r\n]//;
		}
	}elsif($method == 2 &&
		"$user:" eq substr $adminpw, 0, length("$user:")){
		$userline = $adminpw;
	}
	return if($userline eq "");

	return split /:/, $userline;
}

sub find_user_info_by_email_address{
	my $email = shift;
	local *FH;

	my $method = 0;
	# $method=0: No user found
	# $method=1: Use $PASSWORD_FILE
	# $method=2: Use $adminpw

	if($PASSWORD_FILE eq ""){
		# No password file is specified in u.cfg.  Since the password
		# file in the default config is u.pw, an empty $PASSWORD_FILE
		# was assigned by the user.
		if($adminpw eq $tmp_adminpw){
			# If $adminpw is still temporary, this situation can be
			# very dangerous because anyone can login using the
			# public temporary password.  Do not allow any login in
			# this case.
		}else{
			# If $adminpw has been changed, use this password.
			$method = 2;
		}
	}elsif(-f $PASSWORD_FILE){
		# Use the password file
		$method = 1;
	}elsif($adminpw eq $tmp_adminpw){
		# Password file does not exist and $adminpw is temporary.  The
		# first run of this script is this case.  Create the password
		# file only for the login action immediately before checking
		# credentials against the temporary password to avoid timing
		# attacks.
		$method = 2;
	}else{
		# Password file does not exist and $adminpw has been changed.
		# Assume that the user deleted the password file intentionally
		# for single file operations.
		$method = 2;
	}
	return if($method == 0);

	(my $escaped_email = $email) =~ s/\./\\./g;

	my $userline = "";
	if($method == 1){
		open FH, $PASSWORD_FILE;
		my @lines = grep /:$escaped_email(?::[^:]*){2}$/i, <FH>;
		close FH;

		if($#lines == 0){
			$userline = $lines[0];
			$userline =~ s/[\r\n]//;
		}
	}elsif($method == 2 &&
		$adminpw =~ m/:$escaped_email(?::[^:]*){2}$/i){
		$userline = $adminpw;
	}
	return if($userline eq "");

	return split /:/, $userline;
}

sub find_user_info_by_password_reset_token{
	my $token = shift;
	local *FH;

	my $method = 0;
	# $method=0: No user found
	# $method=1: Use $PASSWORD_FILE
	# $method=2: Use $adminpw

	if($PASSWORD_FILE eq ""){
		# No password file is specified in u.cfg.  Since the password
		# file in the default config is u.pw, an empty $PASSWORD_FILE
		# was assigned by the user.
		if($adminpw eq $tmp_adminpw){
			# If $adminpw is still temporary, this situation can be
			# very dangerous because anyone can login using the
			# public temporary password.  Do not allow any login in
			# this case.
		}else{
			# If $adminpw has been changed, use this password.
			$method = 2;
		}
	}elsif(-f $PASSWORD_FILE){
		# Use the password file
		$method = 1;
	}elsif($adminpw eq $tmp_adminpw){
		# Password file does not exist and $adminpw is temporary.  The
		# first run of this script is this case.  Create the password
		# file only for the login action immediately before checking
		# credentials against the temporary password to avoid timing
		# attacks.
		$method = 2;
	}else{
		# Password file does not exist and $adminpw has been changed.
		# Assume that the user deleted the password file intentionally
		# for single file operations.
		$method = 2;
	}
	return if($method != 1);

	(my $escaped_token = $token) =~ s/\./\\./g;

	my $userline = "";
	open FH, $PASSWORD_FILE;
	my @lines = grep /:$escaped_token$/, <FH>;
	close FH;

	if($#lines == 0){
		$userline = $lines[0];
		$userline =~ s/[\r\n]//;
	}
	return if($userline eq "");

	return split /:/, $userline;
}

sub authenticate_user{
	my ($user, $pw, $logout_others) = @_;

	my $method = 0;
	# $method=0: Login not allowed
	# $method=1: Create $PASSWORD_FILE and force to change the password
	# $method=2: Use $PASSWORD_FILE
	# $method=3: Use $adminpw

	if($PASSWORD_FILE eq ""){
		# No password file is specified in u.cfg.  Since the password
		# file in the default config is u.pw, an empty $PASSWORD_FILE
		# was assigned by the user.
		if($adminpw eq $tmp_adminpw){
			# If $adminpw is still temporary, this situation can be
			# very dangerous because anyone can login using the
			# public temporary password.  Do not allow any login in
			# this case.
			exit_message("login_not_allowed");
		}else{
			# If $adminpw has been changed, use this password.
			$method = 3;
		}
	}elsif(-f $PASSWORD_FILE){
		# Use the password file
		$method = 2;
	}elsif($adminpw eq $tmp_adminpw){
		# Password file does not exist and $adminpw is temporary.  The
		# first run of this script is this case.  Create the password
		# file only for the login action immediately before checking
		# credentials against the temporary password to avoid timing
		# attacks.
		if($QUERY_STRING eq "login"){
			write_file($PASSWORD_FILE, "$adminpw\n");
			$method = 1;
		}
	}else{
		# Password file does not exist and $adminpw has been changed.
		# Assume that the user deleted the password file intentionally
		# for single file operations.
		$method = 3;
	}

	my ($usr, $saved_pw, $group, $email, $name, $token) =
		find_user_info($user);
	if(!defined $usr || $saved_pw eq "blocked"){
		close_session();
		exit_message("login_failed");
	}

	my $salt = pack("H*", substr $saved_pw, 0, 16);
	if($saved_pw ne hash_password($user, $pw, $salt)){
		close_session();
		exit_message("login_failed");
	}

	# If admin password is not temporary, the password is secure.
	my $userpw = "$user:$saved_pw:";
	$insecure_pw = 0 if($userpw ne substr $tmp_adminpw, 0, length($userpw));

	clear_user_sessions($user) if($logout_others eq "1");
	start_session($user);

	if($insecure_pw){
		# Force to change the password
		exit_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE?manage_myself");
	}

	clear_password_reset_token($token);

	$USER = $user;
	$NAME = $name;
	$admin = 1 if($group eq "admin");
}

sub find_session_info{
	my $session_id = shift;
	local *FH;

	return if(!-f $sessions_file || !is_session_id($session_id));

	open FH, $sessions_file;
	my @lines = grep /^$session_id:/, <FH>;
	close FH;
	return if($#lines == -1);

	return split /:/, $lines[0];
}

sub start_session{
	my $user = shift;
	my ($session_id, $expires) = generate_session_id($user);
	set_cookie($session_id, $expires);
}

sub renew_session{
	my $session_id = shift;

	my $expires = time + $INACTIVE_TIMEOUT * 60;
	my $new_sessions = "";
	my $renewed = 0;

	lock_file($sessions_file);
	local *FH;
	open FH, $sessions_file;
	while(<FH>){
		if(m/^$session_id:/){
			$renewed = 1;
			my @items = split /:/;
			$_ = "$session_id:$items[1]:$items[2]:$expires\n";
		}
		$new_sessions .= $_;
	}
	close FH;

	if($renewed){
		write_file($sessions_file, $new_sessions);
		set_cookie($session_id, $expires);
	}
	unlock_file($sessions_file);
}

sub close_session{
	clear_cookie();

	my $cookie = $HTTP_COOKIE; $cookie =~ s/; /\n/g;
	return unless($cookie =~ m/^uniqki=(.+)$/m);

	my $session_id = $1;
	return if(!-f $sessions_file || !is_session_id($session_id));

	my $new_sessions = "";
	my $deleted = 0;

	lock_file($sessions_file);
	local *FH;
	open FH, $sessions_file;
	while(<FH>){
		if(m/^$session_id:/){
			$deleted = 1;
			next;
		}
		$new_sessions .= $_;
	}
	close FH;

	write_file($sessions_file, $new_sessions) if($deleted);
	unlock_file($sessions_file);
}

sub clear_user_sessions{
	my $user = shift;

	unless(defined $user){
		clear_cookie();
		my $cookie = $HTTP_COOKIE; $cookie =~ s/; /\n/g;
		$cookie =~ m/^uniqki=(.+)$/m;
		my $session_id = $1;
		(my $sess, $user) = find_session_info($session_id);
	}
	return if(!-f $sessions_file || !is_username($user));

	my $new_sessions = "";
	my $deleted = 0;

	lock_file($sessions_file);
	local *FH;
	open FH, $sessions_file;
	while(<FH>){
		if(m/^[^:]*:$user:/){
			$deleted = 1;
			next;
		}
		$new_sessions .= $_;
	}
	close FH;

	write_file($sessions_file, $new_sessions) if($deleted);
	unlock_file($sessions_file);
}

sub clear_expired_sessions{
	return if(!-f $sessions_file);

	my $new_sessions = "";
	my $deleted = 0;
	my $time = time;

	lock_file($sessions_file);
	local *FH;
	open FH, $sessions_file;
	while(<FH>){
		if(m/:([0-9]+)$/ && $time > $1){
			$deleted = 1;
			next;
		}
		$new_sessions .= $_;
	}
	close FH;

	write_file($sessions_file, $new_sessions) if($deleted);
	unlock_file($sessions_file);
}

sub handle_session{
	my $cookie = $HTTP_COOKIE; $cookie =~ s/; /\n/g;
	unless($cookie =~ m/^uniqki=(.+)$/m){
		clear_cookie();
		return;
	}

	my $session_id = $1;
	my ($sess, $user, $status, $expires) = find_session_info($session_id);

	unless(defined $sess){
		clear_cookie();
		return;
	}
	if($status ne "active" || time > $expires){
		close_session();
		return;
	}
	my ($usr, $pw, $group, $email, $name, $token) = find_user_info($user);
	unless(defined $usr){
		close_session();
		return;
	}

	renew_session($session_id);

	# If admin password is not temporary, the password is secure.
	my $userpw = "$user:$pw:";
	$insecure_pw = 0 if($userpw ne substr $tmp_adminpw, 0, length($userpw));

	$USER = $user;
	$NAME = $name;
	$admin = 1 if($group eq "admin");
}

sub clear_password_reset_token{
	my $token = shift;
	return unless(-f $PASSWORD_FILE);

	my $new_pw = "";
	my $cleared = 0;

	lock_file($PASSWORD_FILE);
	local *FH;
	open FH, $PASSWORD_FILE;
	while(<FH>){
		if(":$token\n" eq substr $_, length($_) - length(":$token\n")){
			my @items = split /:/;
			$cleared = 1;
			$_ = "$items[0]:$items[1]:$items[2]:$items[3]:$items[4]:\n";
		}
		$new_pw .= $_;
	}
	close FH;

	write_file($PASSWORD_FILE, $new_pw) if($cleared);
	unlock_file($PASSWORD_FILE);
}

sub generate_random_string{
	my $len = shift;
	# http://www.perlmonks.org/?node_id=233023
	my @chars = ("a".."z", "A".."Z", "0".."9");
	my $str;
	$str .= $chars[rand @chars] for 1..$len;
	return $str;
}

sub generate_salt{
	# salt length: 8
	return generate_random_string(8);
}

sub generate_session_id{
	my $user = shift;
	my $session_id;
	my $i = 0;
	my $found;
	do{
		$session_id = generate_random_string(64);
		my @session = find_session_info($session_id);
		$found = defined $session[0] ? 1 : 0;
		$i++;
	}while($found && $i<10);

	exit_message("session_errors") if($found);

	my $expires = time + $INACTIVE_TIMEOUT * 60;

	lock_file($sessions_file);
	local *FH;
	exit_message("session_errors") unless(open FH, ">>$sessions_file");
	print FH "$session_id:$user:active:$expires\n";
	close FH;
	unlock_file($sessions_file);

	return ($session_id, $expires);
}

# PBKDF2 for password hashing
# http://www.ict.griffith.edu.au/anthony/software/pbkdf2.pl
# Anthony Thyssen
sub get_pbkdf2_key{
	# key length: 128
	my ($password, $salt) = @_;
	my $prf = \&hmac_sha1;
	my $iter = 8192;
	my $keylen = 64;
	return unpack("H*", pbkdf2($prf, $password, $salt, $iter, $keylen));
}

# http://www.perlmonks.org/?node_id=631963
# Thanks to Jochen Hoenicke <hoenicke@gmail.com>
# (one of the authors of Palm Keyring)
sub pbkdf2{
	my ($prf, $password, $salt, $iter, $keylen) = @_;
	my ($k, $t, $u, $ui, $i);
	$t = "";
	for($k = 1; length($t) < $keylen; $k++){
		$u = $ui = hmac_sha1($salt.pack('N', $k), $password);
		for($i = 1; $i < $iter; $i++){
			$ui = hmac_sha1($ui, $password);
			$u ^= $ui;
		}
		$t .= $u;
	}
	return substr $t, 0, $keylen;
}

sub hash_password{
	# hashed password length: 2*8+128=144
	my ($user, $pw, $salt) = @_;
	$salt = generate_salt() unless(defined $salt);
	return unpack("H*", $salt).get_pbkdf2_key("$user:$salt:$pw", $salt);

}

sub generate_password_set_token{
	# password set token length: 64+1+...
	my $user = shift;
	return generate_random_string(64).".".
		(time + $SET_PASSWORD_TIMEOUT * 60);
}

sub generate_password_reset_token{
	# password reset token length: 64+1+...
	my $user = shift;
	return generate_random_string(64).".".
		(time + $RESET_PASSWORD_TIMEOUT * 60);
}

sub send_email{
	my ($email, $subject, $text) = @_;
	eval "use MIME::Lite;";
	exit_message("perl_module_not_installed", "MIME::Lite") if($@);

	if($smtp_server ne ""){
		if($smtp_port ne ""){
			if($smtp_username ne "" && $smtp_password ne ""){
				MIME::Lite->send("smtp", $smtp_server,
					Port=>$smtp_port,
					AuthUser=>$smtp_username,
					AuthPass=>$smtp_password);
			}else{
				MIME::Lite->send("smtp", $smtp_server,
					Port=>$smtp_port);
			}
		}else{
			if($smtp_username ne "" && $smtp_password ne ""){
				MIME::Lite->send("smtp", $smtp_server,
					AuthUser=>$smtp_username,
					AuthPass=>$smtp_password);
			}else{
				MIME::Lite->send("smtp", $smtp_server);
			}
		}
	}
	MIME::Lite->quiet(1);

	my $msg = MIME::Lite->new(
		From	=> $EMAIL_ADDRESS,
		To	=> $email,
		Subject	=> $subject,
		Data	=> $text
	);
	$msg->send();
	return $msg->last_send_successful();
}

sub create_goto_form{
	# $mode=undef: return
	# $mode=1: print
	my $mode = shift;
	my $goto = get_msg("goto_form_goto");
	my $form = <<EOT;
<form class="goto-input" action="$SCRIPT_NAME" method="get">
<div>
<input accesskey="g" id="goto" name="goto" />
<input type="submit" value="$goto" />
</div>
</form>
EOT
	if($mode == 1){
		print $form;
	}elsif($p){
		# Forms are not allowed inside a <p> block
		$text .= "</p>\n";
		$p = 0;
	}
	return $form;
}

sub create_search_form{
	# $mode=undef: return
	# $mode=1: print
	my $mode = shift;
	my $search = get_msg("search_form_search");
	my $simple = get_msg("search_form_simple");
	my $icase = get_msg("search_form_ignore_case");
	my $link = get_msg("search_form_links");
	my $title = get_msg("search_form_print_titles");
	my $nomatch = get_msg("search_form_dont_print_matches");
	my $form = <<EOT;
<form class="search-input" action="$CGI" method="get">
<div>
<input accesskey="s" id="search" name="search" />
<input type="submit" value="$search" />
<br />
<input type="checkbox" id="simple" name="simple" value="1" checked="checked" /> $simple
<input type="checkbox" id="icase" name="icase" value="1" checked="checked" /> $icase
<input type="checkbox" id="link" name="link" value="1" /> $link
<br />
<input type="checkbox" id="title" name="title" value="1" /> $title
<input type="checkbox" id="nomatch" name="nomatch" value="1" /> $nomatch
</div>
</form>
EOT
	if($mode == 1){
		print $form;
	}elsif($p){
		# Forms are not allowed inside a <p> block
		$text .= "</p>\n";
		$p = 0;
	}
	return $form;
}

sub create_comment_form{
	# $mode=undef: return
	# $mode=1: print
	my ($page, $comment, $direction, $rows, $cols, $mode) = @_;
	$page = $PAGE if($page eq "");
	$comment = "comment" if($comment eq "");
	$direction = "down" if($direction eq "");
	$rows = "6" if($rows eq "");
	$cols = "80" if($cols eq "");
	exit_message("invalid_comment_tag", $comment)
		unless($comment =~ m/^[a-zA-Z0-9_-]+$/);
	my $id = time;

	my $leave_this_field_blank = get_msg("comment_form_leave_this_field_blank");
	my $write = get_msg("comment_form_write");
	my $form = <<EOT;
<form class="comment-input" action="$CGI?comment=$comment" method="post">
<div>
<div class="comment-website">$leave_this_field_blank<input id="website" name="website" /></div>
<input type="hidden" id="id" name="id" value="$id" />
<input type="hidden" id="page" name="page" value="$page" />
<input type="hidden" id="direction" name="direction" value="$direction" />
<textarea accesskey="c" id="text" name="text" rows="$rows" cols="$cols"></textarea>
<input type="submit" value="$write" />
</div>
</form>
EOT
	if($mode == 1){
		print $form;
	}elsif($p){
		# Forms are not allowed inside a <p> block
		$text .= "</p>\n";
		$p = 0;
	}
	return $form;
}

sub verify_input_data{
	$verify_input = \&verify_input unless(defined($verify_input));
	return $verify_input->(@_);
}

sub read_file{
	my $file = shift;
	my $text = "";
	local *FH;

	# "<" is required for the in-memory file
	if(open FH, "<", $file){
		# sysread is faster, but it doesn't work with in-memory files.
		local $/ = undef;
		$text = <FH>;
		close FH;
	}

	return $text;
}

sub write_file{
	# return 1 if successful
	# return 0 otherwise
	my ($file, $text) = @_;
	local *FH;

	# ">" is required for the in-memory file
	if(open FH, ">", $file){
		print FH $text;
		close FH;
		return 1;
	}
	return 0;
}

# Parsing subroutines
sub parse_file{
	my $file = shift;
	local *UNIQKI_FH;

	return "" unless(open UNIQKI_FH, "<", $file);
	$wiki = <UNIQKI_FH> eq "#!wiki\n" ? 1 : 0;
	close UNIQKI_FH;

	local ($text, $protocol, $protocol_char, $protocol_punct, $image_ext,
		$code_block, $syntax_block, @syntax_blocks, $re_i_start, $re_i,
		@re, @re_sub, $toc, $notoc, %h_i, $h_top, $h_prev, $p, $pre,
		$pre_code, $list, $table, $figure);
	my ($header_file, $footer_file);

	unless($wiki){
		($header_file, $footer_file) = ($HEADER_FILE, $FOOTER_FILE);
	}else{
		($header_file, $footer_file) =
			($WIKI_HEADER_FILE, $WIKI_FOOTER_FILE);
	}

	$begin_parsing = \&begin_parsing unless(defined($begin_parsing));
	$parse_line = \&parse_line unless(defined($parse_line));
	$end_parsing = \&end_parsing unless(defined($end_parsing));

	$begin_parsing->();
	foreach my $f ($header_file, $file, $footer_file){
		# "<" is required for the in-memory file
		next if($f eq "" || !open UNIQKI_FH, "<", $f);
		$parse_line->($_) while(<UNIQKI_FH>);
		close UNIQKI_FH;
	}
	$end_parsing->();

	return $text;
}

sub parse_block{
	my $txt = shift;
	local ($text, $protocol, $protocol_char, $protocol_punct, $image_ext,
		$code_block, $syntax_block, @syntax_blocks, $re_i_start, $re_i,
		@re, @re_sub, $toc, $notoc, %h_i, $h_top, $h_prev, $p, $pre,
		$pre_code, $list, $table, $figure);

	$begin_parsing = \&begin_parsing unless(defined($begin_parsing));
	$parse_line = \&parse_line unless(defined($parse_line));
	$end_parsing = \&end_parsing unless(defined($end_parsing));

	$begin_parsing->();
	$parse_line->($_) foreach(split /\n/, $txt, -1);
	$end_parsing->();

	return $text;
}

sub parse_lines{
	my $txt = shift;
	local $text;

	$parse_line = \&parse_line unless(defined($parse_line));
	$parse_line->($_) foreach(split /\n/, $txt, -1);

	return $text;
}

################################################################################
# User-replaceable subroutines
sub verify_input{
	# return 1 if OK
	# return 0 otherwise
	my ($query, $var) = @_;
	if($query eq "comment"){
		return 0 if($$var{website} ne "" || $$var{id} >= time - 15);
		(my $text = $$var{text}) =~ s/[`~!@#\$%^&*_=+\\|;:'",.\/?()\[\]{}<>0-9-]//g;
		$text =~ s/[ \t\n]+/ /g;
		$text =~ s/^ | $//g;
		return 0 if($text eq "");

		$$var{text} =~ s/^[ \t\n]+|[ \t\n]+$//g;
	}
	return 1;
}

sub begin_parsing{
	$protocol = 'https?://|ftp://|news://|telnet://|gopher://|wais://|mailto:|file://';
	$protocol_char = 'a-zA-Z0-9:@/~%.,_$?=&;#+-';
	$protocol_punct = '.,;:!?';
	$image_ext = 'png|gif|jpg|jpeg';

	$text = "";
	$code_block = "";
	$syntax_block = "";
	@syntax_blocks = ();
	$re_i_start = 0;
	$re_i = 0;
	@re = ();
	@re_sub = ();
	$toc = "";
	$notoc = 0;
	%h_i = ();
	$h_top = 0;
	$h_prev = 0;
	$p = 0;
	$pre = 0;
	$pre_code = "";
	$list = "";
	$table = "";
	$figure = "";
}

sub parse_line{
	# \x00: NONE
	# \x01: &
	# \x02: <
	# \x03: >
	# \x04: place holder for auto-generated TOC
	# \x05: place holder for syntax block
	# \x1e: delimiter
	# ##admin code
	# #user code
	# ``inline perl code``
	# %comment
	local $_ = shift;
	s/[\r\n]//g;
#	$text .= "[[$_]]\n";

	# Apply regular expressions where needed
	if(!$pre && m/^(?!#(?:no)?regex)/){
		for(my $i=$re_i_start; $i<$re_i; $i++){
			if(m/^(?!#(?:no)?regex)/){
				eval "s\x1e$re[$i]\x1e$re_sub[$i]\x1eg;";
			}
		}
		if(m/\n/){
			local $re_i_start = $re_i;
			my @lines = split /\n/, $_, -1;
			$parse_line->($_) foreach(@lines);
			return;
		}
	}
	# Wiki but not pre
	if($wiki && !$pre){
		# Skip admin code
		return if("##" eq substr $_, 0, 2);
		# Escape inline perl code
		s/``(.*?)``(?!`)/`\x00`$1`\x00`/g;
	}
	# Process code block
	if($code_block ne ""){
		if($_ eq "##}"){
			my $code = "$code_block}";
			undef $code_block;
			$code =~ s/^(##[{}]_*)_$/$1/mg;
			eval $code;
			return;
		}
		$code_block .= "$_\n";
		return;
	}
	# Process syntax block
	if($syntax_block ne ""){
		if("))" eq substr($_, 0, 2) && "_" ne substr($_, 2, 1)){
			my $i = index $syntax_block, "\n";
			my $begin = substr $syntax_block, 0, $i;
			my $end = substr $_, 2;
			my $code = substr $syntax_block, $i + 1;
			undef $syntax_block;
			$code =~ s/(\(\(_*)_$/$1/mg;
			$code =~ s/^(\)\)_*)_/$1/mg;
			my $parsed_block = parse_block($code);
			chomp $parsed_block;
			push @syntax_blocks, $parsed_block;
			$_ = "$begin\x05$end";
		}else{
			$syntax_block .= "$_\n";
			return;
		}
	}
	# Start or close pre
	if(m/^(---+)(?:\[(.*)\])?$/ && (!$pre || ($pre == length($1) &&
				($2 eq "" || $pre_code eq $2)))){
		if($pre){
			chomp $text;
			if($pre_code eq ""){
				$text .= "</pre>\n";
			}else{
				$text .= "</code></pre>\n";
				$pre_code = "";
			}
			$pre = 0;
		}else{
			if($list ne ""){
				$text .= create_list($list);
				$list = "";
			}
			if($table ne ""){
				$text .= create_table($table);
				$table = "";
			}
			if($figure ne ""){
				$text .= create_figure($figure);
				$figure = "";
			}
			if($p){
				$text .= "</p>\n";
				$p = 0;
			}
			if($2 eq ""){
				$text .= "<pre>";
			}else{
				$text .= qq(<pre><code class="language-$2">);
				$pre_code = $2;
			}
			$pre = length($1);
		}
		return;
	}
	# Inside pre
	if($pre){
		s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g; s/\x00//g;
		$text .= "$_\n";
		return;
	}
	# Skip comment
	if("%" eq substr $_, 0, 1){
		return;
	}
	# Register regular expressions
	if(m/^#regex (.)(.+)(?<!\\)\1(.*)(?<!\\)\1$/){
		# Don't allow code embedding in a wiki page
		return if($wiki && (index($2, '(?{') != -1 ||
			  	    index($2, '(??{') != -1 ||
				    index($3, '@{[') != -1));

		my $i;
		for($i=0; $i<$re_i; $i++){
			last if($re[$i] eq $2);
		}
		$re[$re_i++] = $2 if($i == $re_i);
		$_ = $3;
		# Treat a single backslash as an escape character.
		s/\\(?![\\a-zA-Z0-9])/\x00/g;
		# Don't allow access to variables.
		s/\$/\\\$/g;
		$re_sub[$i] = $_;
		return;
	}
	# Clear regular expressions
	if(m/^#noregex(?:| (.)(.+)(?<!\\)\1)$/){
		if($2 eq ""){
			$re_i = 0;
			$#re = $#re_sub = -1;
		}else{
			for(my $i=0; $i<$re_i; $i++){
				if($re[$i] eq $2){
					$re_i--;
					for(; $i<$re_i; $i++){
						$re[$i] = $re[$i+1];
						$re_sub[$i] = $re_sub[$i+1];
					}
					$#re = $#re_sub = $re_i-1;
					last;
				}
			}
		}
		return;
	}
	# Output verbose html code
	if(m/^#html (.+)$/){
		$text .= "$1\n";
		return;
	}
	# Table of contents
	if("#notoc" eq $_){
		$notoc = 1;
		return;
	}
	# Admin code starts
	# Include other Uniqki files
	if(m/^##include (.+)$/){
		local *FH;
		if(open FH, $1){
			$parse_line->($_) while(<FH>);
			close FH;
		}
		return;
	}
	# Shell commands
	if(m/^##shell (.+)$/){
		$text .= `$1`;
		return;
	}
	# Perl subroutines or code
	if(m/^##((?:sub |{).*)$/){
		if("}" eq substr $1, -1){
			eval $1;
			return;
		}
		$code_block = "$1\n";
		return;
	}
	# Ignore other lines starting with #
	if("#" eq substr $_, 0, 1){
		return;
	}
	# Syntax block
	if("((" eq substr $_, -2){
		# Process the first line later
		$syntax_block = (substr $_, 0, length($_) - 2)."\n";
		return;
	}
	# Close list
	if($list ne "" && !(m/^( *)((?:[*+-]|: .*?:) )?/ && length($1)%2 == 0 &&
			"$1$2" ne "")){
		$text .= create_list($list);
		$list = "";
	}
	# Close table
	if($table ne "" &&
		!(m/^(?:![ \t](?:.*[ \t])?!|[|^][ \t](?:.*[ \t])?(?:[!^]+|\|+_?))$/)){
		$text .= create_table($table);
		$table = "";
	}
	# Close figure
	if($figure ne "" && !(m/^([@"])[ \t](?:.*[ \t])?\1$/)){
		$text .= create_figure($figure);
		$figure = "";
	}
	# Close paragraph
	if("" eq $_ || m/^___+$/){
		if($p){
			$text .= "</p>\n";
			$p = 0;
		}
		# Horizontal line
		$text .= "<hr />\n" if($_ ne "");
		return;
	}
	# Escape inline syntax
	s/""(.)(.*?)\1""/@{[escape_inline_syntax($2)]}/g;
	# Regular [&<>] should not be translated to html codes at this point
	# because page names and links will be affected.  Instead, flag them so
	# that they can be converted to html later.  This flagging does not
	# apply to escaped characters (\x00[&<>]).  Escaped characters may come
	# from the #regex syntax to enter [&<>] as is without converting them
	# to &amp, &lt, and &gt.
	s/(?<!\x00)&/\x01/g; s/(?<!\x00)</\x02/g; s/(?<!\x00)>/\x03/g;
	# Pages
	s#\[\[(.*?)(?:\#(.*?))?(?:\|(.*?))?\]\]#@{[link_page($1, $2, $3)]}#g;
	# Images
	s#{{{(.*?)(?:\|(.*?))?}}}(?:\[(.*?)\])?#@{[link_image($1, $2, $3)]}#g;
	# Files
	s#{{(.*?)(?:\|(.*?))?}}#@{[link_file($1, $2)]}#g;
	# URL images
	s#\x02\x02\x02(.*?)(?:\|(.*?))?\x03\x03\x03(?:\[(.*?)\])?#@{[link_url_image($1, $2, $3)]}#g;
	# URLs
	s#\x02\x02(.*?)(?:\|(.*?))?\x03\x03#@{[link_url($1, $2)]}#g;
	# Text styles
	# Avoid conflicts with //italic//
	s#($protocol)#$1\x00#ogi;
	s#//(?!\x00)(.*?)//(?!\x00)#<i>$1</i>#g;
	s#($protocol)\x00#$1#ogi;
	s#\*\*(.*?)\*\*#<b>$1</b>#g;
	s#''(.*?)''(?:\[(.*?)\])?#@{[$2 eq "" ? "<code>$1</code>" : qq(<code class="language-$2">$1</code>)]}#g;
	s#--(.*?)--#<s>$1</s>#g;
	s#__(.*?)__#<u>$1</u>#g;
	s#\!\!(.*?)\!\!#<mark>$1</mark>#g;
	# Percent-encode and protect links inside tags
	s#<([^>]*(?:$protocol)[^>]*)>#<@{[protect_urls(encode_urls($1))]}>#ogi;
	# Protect protocols outside a tag
	s#(<a [^>]*>)([^<]*(?:$protocol)[^<]*)(</a>)#$1@{[protect_urls($2)]}$3#ogi;
	# Translate non-protected protocols to links
	s#(?<![a-zA-Z\x00])((?:$protocol)[\x01$protocol_char]+\x01[a-z]+;)(?=(?:[ \t]|$))#<a href="\x00@{[encode_url($1)]}">\x00$1</a>#ogi;
	s#(?<![a-zA-Z\x00])((?:$protocol)[\x01$protocol_char]+)(?=[$protocol_punct](?:[ \t]|$))#<a href="\x00@{[encode_url($1)]}">\x00$1</a>#ogi;
	s#(?<![a-zA-Z\x00])((?:$protocol)[\x01$protocol_char]+)#<a href="\x00@{[encode_url($1)]}">\x00$1</a>#ogi;
	s/\x01/&amp;/g; s/\x02/&lt;/g; s/\x03/&gt;/g;
	# Collect list lines
	if(m/^( *)((?:[*+-]|: .*?:) )?/ && length($1)%2 == 0 && "$1$2" ne "" &&
		($list ne "" || $2 ne "")){
		if($p){
			$text .= "</p>\n";
			$p = 0;
		}
		$list .= "$_\n";
		return;
	}
	# Collect table lines
	if(m/^(?:![ \t](?:.*[ \t])?!|[|^][ \t](?:.*[ \t])?(?:[!^]+|\|+_?))$/){
		if($p){
			$text .= "</p>\n";
			$p = 0;
		}
		$table .= "$_\n";
		return;
	}
	# Collect figure lines
	if(m/^([@"])[ \t](?:.*[ \t])?\1$/){
		if($p){
			$text .= "</p>\n";
			$p = 0;
		}
		$figure .= "$_\n";
		return;
	}
	# Heading
	if(m/^(=+)!? (.*)$/ && length($1) <= 6){
		my $i = length($1);
		my $inc_toc = "!" ne substr $_, $i, 1 ? 1 : 0;
		$_ = $2;
		# Inline perl code
		s/``(.*?)``(?!`)/$1/eeg;
		# Discard NONE characters
		y/\x00//d;
		(my $t = $_) =~ s/<[^>]*>//g;
		$t =~ s/^ *//; $t =~ s/ *$//;
		my $id = $t;
		$id =~ s/&amp;/&/g; $id =~ s/&lt;/</g; $id =~ s/&gt;/>/g;
		$id = convert_page_name($id);
		my $enc_id = encode_url($id);
		my $j = $h_i{$id}++;
		if($j > 0){
			$id .= ".".($j+1);
		}
		if($p){
			$text .= "</p>\n";
			$p = 0;
		}
		if($i == 1){
			if($TITLE eq ""){
				$TITLE = $_;
				$TITLE =~ s/<[^>]*>//g;
			}
			$text .= qq(<h$i>$_</h$i>\n);
			return;
		}else{
			$text .= "\x04" if($toc eq "" && $inc_toc);
			$text .= qq(<h$i id="$id">$_</h$i>\n);
		}
		return unless($inc_toc);

		if($i > $h_prev){
			if($h_prev){
				$toc .= "<li><ul>" while($h_prev++<$i);
				$h_prev--;
			}else{
				$toc .= "<ul class=\"toc-list\">";
				$toc .= "\n" if($i > 1);
				$toc .= "<li><ul>" while(++$h_prev<$i);
				$h_top = $i;
			}
			$toc .= "\n";
		}elsif($i < $h_prev){
			$toc .= "</ul></li>" while(--$h_prev>=$i);
			$toc .= "\n";
			$h_prev++;
			$h_top = $i if($i < $h_top);
		}
		$toc .= "<li><a href=\"#$enc_id\">$t</a></li>\n";
		return;
	}
	# Start a new paragraph
	if(!$p && !$pre && $list eq "" && $table eq ""){
		$text .= "<p>";
		$p = 1;
	}
	# Inline perl code
	s/``(.*?)``(?!`)/$1/eeg;
	# Discard NONE characters
	y/\x00//d;
	$text .= "$_\n";
}

sub end_parsing{
	if($list ne ""){
		$text .= create_list($list);
		$list = "";
	}
	if($table ne ""){
		$text .= create_table($table);
		$table = "";
	}
	if($figure ne ""){
		$text .= create_figure($figure);
		$figure = "";
	}
	if($pre){
		chomp $text;
		if($pre_code eq ""){
			$text .= "</pre>\n";
		}else{
			$text .= "</code></pre>\n";
			$pre_code = "";
		}
		$pre = 0;
	}
	if($p){
		$text .= "</p>\n";
		$p = 0;
	}
	if($notoc){
		$text =~ s/\x04//g;
	}elsif($h_prev){
		my $i = $h_prev;
		$toc .= "</ul></li>" while(--$h_prev>0);
		$toc .= ($i > 1 ? "\n" : "")."</ul>\n";
		for(my $i=0; $i<$h_top-1; $i++){
			$toc =~ s#^(.*\n)<li><ul>#\1#;
			$toc =~ s#</ul></li>(\n.*)$#\1#;
		}
		$toc =~ s#</li>\n<li>(<ul>)#\n\1#g;
		$toc =~ s#\n+#\n#g;
		my $heading = get_msg("table_of_contents");
		$toc = "<div id=\"toc\">\n".
			"<div class=\"toc-heading\">$heading</div>\n".
			"$toc</div>\n";
		$h_prev = 0;
		$text =~ s/\x04/$toc/g;
	}
	my $i = 0;
	$text =~ s/\x05/@{[$syntax_blocks[$i++]]}/g;
	$text =~ s#<(i|b|code|su|mark)>([ \t\n]*)</\1>#$2#g;
	$text =~ s#\n*(<(?:p|li|dd)>)\n*#\n$1#g;
	$text =~ s#\n*(</(?:p|li|dd)>)\n*#$1\n#g;
	$text =~ s#^\n+|\n+$##g;
}

################################################################################
# Clean up
END{
	while(my $file = each %locked_files){
		unlock_file($file);
	}
}

if($PAGE eq $CGI && $FILE ne ""){
################################################################################
# u/u/.../PAGE?ACTION	Called from a secured site
	exit_redirect("$HTTP_BASE$SCRIPT_NAME/$FILE?$QUERY_STRING");
}

$PAGE = convert_page_name($PAGE);

################################################################################
# Login, logout
if($QUERY_STRING eq "logout"){
#-------------------------------------------------------------------------------
# u/PAGE?logout		Logout
	close_session();
	exit_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE");
}elsif($QUERY_STRING eq "logout_all"){
#-------------------------------------------------------------------------------
# u/PAGE?logout_all	Logout from all computers
	clear_user_sessions();
	exit_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE");
}

clear_expired_sessions();
handle_session();

if(!is_logged_in()){
if($QUERY_STRING eq "login"){
	if($REQUEST_METHOD eq "GET"){
#-------------------------------------------------------------------------------
# u/PAGE?login		GET login request: Login form
		print_login();
		exit;
	}else{
#-------------------------------------------------------------------------------
# u/PAGE?login		POST login request: Check credentials
		my %var = get_var();
		authenticate_user($var{user}, $var{pw}, $var{logout_others});
	}
}elsif($QUERY_STRING eq "loginout"){
#-------------------------------------------------------------------------------
# u?loginout		Loginout
# u/PAGE?loginout	Loginout
	exit_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE?login");
}
}elsif($QUERY_STRING eq "loginout"){
#-------------------------------------------------------------------------------
# u?loginout		Loginout
# u/PAGE?loginout	Loginout
	exit_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE?logout");
}

{
#-------------------------------------------------------------------------------
# Is this page wiki?
	my $page;
	local *FH;
	if($PAGE eq "" && ($QUERY_STRING eq "login" || $QUERY_STRING eq "")){
		$page = $INDEX_PAGE;
	}else{
		$page = $PAGE;
	}
	$wiki = 0;
	if($page ne ""){
		if(-f "$page.txt"){
			open FH, "$page.txt";
			$wiki = 1 if(<FH> eq "#!wiki\n");
			close FH;
		}elsif($WIKI_ALLOWED_PAGES ne "" &&
			$page =~ m/$WIKI_ALLOWED_PAGES/o){
			$wiki = 1;
		}
	}
}

if($QUERY_STRING eq "css"){
#-------------------------------------------------------------------------------
# u?css			Print CSS
	print_css(2);
	exit;
}elsif($QUERY_STRING eq "js"){
#-------------------------------------------------------------------------------
# u?js			Print JavaScript
	print_js(2);
	exit;
}elsif($QUERY_STRING eq "user_info"){
#-------------------------------------------------------------------------------
# u/PAGE?user_info	Print user information
	my $page_exists = page_exists();
	my $has_read_access = $page_exists && has_read_access() ? 1 : 0;
	my $has_write_access = $page_exists && has_write_access() ? 1 : 0;
	exit_text("$USER:$admin:$has_read_access:$has_write_access");
}elsif($QUERY_STRING eq "forgot_password"){
#-------------------------------------------------------------------------------
# u?forgot_password		Forgot password
# u/PAGE?forgot_password	Forgot password
	if($REQUEST_METHOD eq "GET"){
		print_forgot_password();
		exit;
	}

	my %var = get_var();
	if($var{user} eq "" && $var{email} eq ""){
		exit_message("enter_username_or_email_address");
	}
	my ($user, $pw, $group, $email, $name, $token);
	$user = "";
	if($var{email} ne ""){
		if(!is_email_address($var{email})){
			exit_message("check_email_address");
		}
		($user, $pw, $group, $email, $name, $token) =
			find_user_info_by_email_address($var{email});
		unless(defined $user){
			exit_message("email_address_not_found", $var{email});
		}
		if($var{user} ne "" && $var{user} ne $user){
			exit_message("user_info_mismatch");
		}
	}
	if($user eq ""){
		($user, $pw, $group, $email, $name, $token) =
			find_user_info($var{user});
		unless(defined $user){
			exit_message("user_not_found", $var{user});
		}
	}

	exit_message("user_blocked", $user) if($pw eq "blocked");
	exit_message("password_reset_token_still_valid")
		if(is_password_reset_token_valid($token));

	$token = generate_password_reset_token($user);

	my $new_pw = "";
	my $token_added = 0;

	lock_file($PASSWORD_FILE);
	if(-f $PASSWORD_FILE){
		local *FH;
		open FH, $PASSWORD_FILE;
		while(<FH>){
			if(m/^$user:/){
				$token_added = 1;
				my @items = split /:/;
				$_ = "$user:$items[1]:$items[2]:$items[3]:$items[4]:$token\n";
			}
			$new_pw .= $_;
		}
		close FH;
	}elsif($adminpw =~ m/^$user:/){
		$token_added = 1;
		my @items = split /:/, $adminpw;
		$new_pw = "$user:$items[1]:$items[2]:$items[3]:$items[4]:$token\n";
	}

	# Something's wrong because a username already found does not exist.
	exit_message("internal_errors") unless($token_added);

	my $link = "$HTTP_BASE$SCRIPT_NAME?reset_password=$token";
	my $subject = get_msg("reset_password_email_subject", $DOC_BASE);
	my $text = get_msg("reset_password_email_text", $var{user}, $DOC_BASE,
		$link, $RESET_PASSWORD_TIMEOUT);
	if(!send_email($email, $subject, $text)){
		exit_message("email_notification_failed", $user, $email);
	}

	write_file($PASSWORD_FILE, $new_pw);
	unlock_file($PASSWORD_FILE);

	exit_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE");
}elsif($QUERY_STRING eq "reset_password" && $REQUEST_METHOD eq "POST"){
#-------------------------------------------------------------------------------
# u?reset_password	Reset password
# u/PAGE?reset_password	Reset password
	my %var = get_var();
	exit_message("invalid_password_reset_token")
		unless(is_password_reset_token_valid($var{token}));
	my ($user, $saved_pw, $group, $email, $name) =
		find_user_info_by_password_reset_token($var{token});
	exit_message("password_reset_token_not_found") unless(defined $user);

	if($var{pw} ne $var{pw2}){
		exit_message("confirm_password");
	}
	unless(is_password($var{pw})){
		exit_message("check_password");
	}

	my $new_pw = "";
	my $reset = 0;

	lock_file($PASSWORD_FILE);
	if(-f $PASSWORD_FILE){
		local *FH;
		open FH, $PASSWORD_FILE;
		while(<FH>){
			if(m/^$user:/){
				$reset = 1;
				my @items = split /:/;
				my $pw = hash_password($user, $var{pw});
				my $userline = "$user:$pw:$items[2]:$items[3]:$items[4]:\n";
				$_ = $userline;
			}
			$new_pw .= $_;
		}
		close FH;
	}
	# Password reset token cannot be found this time?
	exit_message("internal_errors") unless($reset);

	write_file($PASSWORD_FILE, $new_pw);
	unlock_file($PASSWORD_FILE);

	exit_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE");
}elsif($QUERY_STRING =~ m/^reset_password=([a-zA-Z0-9]{8}[0-9a-f]{40}\.([0-9]+))$/){
#-------------------------------------------------------------------------------
# u?reset_password=token	Reset password
# u/PAGE?reset_password=token	Reset password
	my $token = $1;
	my $expires = $2;

	my $time = time;
	if($time >= $expires){
		clear_password_reset_token($token);
		exit_message("password_reset_token_expired");
	}

	local $PASSWORD_RESET_TOKEN = $token;
	print_reset_password();
	exit;
}elsif($QUERY_STRING eq "manage_myself"){
#-------------------------------------------------------------------------------
# u?manage_myself	Manage myself
# u/PAGE?manage_myself	Manage myself
	print_manage_myself();
	exit;
}elsif($QUERY_STRING eq "update_myself" && $REQUEST_METHOD eq "POST" && is_logged_in()){
#-------------------------------------------------------------------------------
# u?update_myself	Update myself
# u/PAGE?update_myself	Update myself
	my %var = get_var();
	if($var{pw} ne $var{pw2}){
		exit_message("confirm_password");
	}
	if($var{pw} ne "" && !is_password($var{pw})){
		exit_message("check_password");
	}
	if($var{pw} eq "" && $var{email} eq "" && $var{name} eq ""){
		exit_message("enter_user_info_to_update");
	}

	my $new_pw = "";
	my $updated = 0;

	lock_file($PASSWORD_FILE);
	if(-f $PASSWORD_FILE){
		local *FH;
		open FH, $PASSWORD_FILE;
		while(<FH>){
			if(m/^$USER:/){
				$updated = 1;
				my @items = split /:/;
				my $pw = $var{pw} ne "" ?
					hash_password($USER, $var{pw}) :
					$items[1];
				my $group = $items[2];
				my $email = $var{email} ne "" ?
					$var{email} : $items[3];
				my $name = $var{name} ne "" ?
					$var{name} : $items[4];
				my $token = $items[5];
				# new line from $items[5]
				my $userline = "$USER:$pw:$group:$email:$name:$token";
				if($userline eq $_){
					close FH;
					exit_message("enter_user_info_to_update", $USER);
				}
				$_ = $userline;
			}
			$new_pw .= $_;
		}
		close FH;
	}else{
		my @items = split /:/, $adminpw;
		if($USER ne $items[0]){
			# Something's wrong because you're the only user, but
			# the user line in this script is not you! How did you
			# login?
			exit_message("internal_errors");
		}

		$updated = 1;
		my $pw = $var{pw} ne "" ? hash_password($USER, $var{pw}) :
			$items[1];
		my $group = $items[2];
		my $email = $var{email} ne "" ? $var{email} : $items[3];
		my $name = $var{name} ne "" ? $var{name} : $items[4];
		my $token = $items[5];
		# new line from $items[5]
		my $userline = "$USER:$pw:$group:$email:$name:$token";
		if($userline eq $adminpw){
			exit_message("enter_user_info_to_update", $USER);
		}
		$new_pw = "$userline\n";
	}
	# How did you login when your username is not found?
	exit_message("internal_errors") unless($updated);

	write_file($PASSWORD_FILE, $new_pw);
	unlock_file($PASSWORD_FILE);

	exit_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE?manage_myself");
}elsif($QUERY_STRING eq "delete_myself" && $REQUEST_METHOD eq "POST" && is_logged_in()){
#-------------------------------------------------------------------------------
# u?delete_myself	Delete myself
# u/PAGE?delete_myself	Delete myself
	my $new_pw = "";
	my $deleted = 0;
	my $nadmins = 0;

	lock_file($PASSWORD_FILE);
	if(-f $PASSWORD_FILE){
		local *FH;
		open FH, $PASSWORD_FILE;
		while(<FH>){
			$nadmins++ if($admin && m/^(?:[^:]*:){2}admin:/);
			if(m/^$USER:/){
				$deleted = 1;
				next;
			}
			$new_pw .= $_;
		}
		close FH;
	}
	# How did you login when your username is not found?
	exit_message("internal_errors") unless($deleted);

	# You cannot delete yourself when you are the only admin.
	exit_message("cannot_delete_only_admin") if($nadmins == 1);

	clear_user_sessions($USER);

	write_file($PASSWORD_FILE, $new_pw);
	unlock_file($PASSWORD_FILE);

	exit_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE");
}elsif(!has_read_access()){
#-------------------------------------------------------------------------------
# Read-secured
	exit_message("read_secured");
################################################################################
# User actions
}elsif($QUERY_STRING eq "login" || $QUERY_STRING eq ""){
#-------------------------------------------------------------------------------
# u?login		After a successful login
# u/PAGE?login		After a successful login
# u/PAGE/FILE?login	After a successful login
# u			No action specified
# u/PAGE		No action specified
# u/PAGE/FILE		No action specified
	exit_path("$PAGE/$FILE") if($FILE ne "" ||
		($PAGE ne "" && "/" eq substr $PATH_INFO, -1));
	exit_redirect("$HTTP_BASE$SCRIPT_NAME/$INDEX_PAGE") if($PAGE eq "");
	unless(-f "$PAGE.txt"){
		my $msg_id = has_write_access() ?
			"create_page" : "page_not_found";
		exit_message($msg_id, $PAGE);
	}
}elsif($QUERY_STRING ne "delete" && $FILE ne ""){
#-------------------------------------------------------------------------------
# u/PAGE/FILE		Show/download PAGE/FILE
	exit_path("$PAGE/$FILE");
}elsif($QUERY_STRING =~ m/^goto(?:[&=].+)?$/){
#-------------------------------------------------------------------------------
# u?goto		Create the goto form
# u?goto=PAGE		Go to or create PAGE using a form (admin only)
	my %var = get_var();
	if($var{goto} eq ""){
		local $TITLE = get_msg("goto_form");
		print_header();
		create_goto_form(1);
		print_footer();
		exit;
	}

	$_ = $var{goto};
	s#/.*$##; s#\.html$##;
	y/+/ /;

	exit_redirect("$HTTP_BASE$SCRIPT_NAME/$_");
}elsif($QUERY_STRING eq "refresh" && $PAGE ne ""){
#-------------------------------------------------------------------------------
# u/PAGE?refresh	Refresh
	if(-f "$PAGE.txt"){
		$rebuild = 1;
	}else{
		my $msg_id = has_write_access() ?
			"create_page" : "page_not_found";
		exit_message($msg_id, $PAGE);
	}
}elsif($QUERY_STRING =~ m/^diff(?:=(-?[0-9]+))?$/){
#-------------------------------------------------------------------------------
# u/PAGE?diff		Diff current and previous version
# u/PAGE?diff=([0-9]+)	Diff current and \1 version
# u/PAGE?diff=-([0-9]+)	Diff current and current-\1 version
	unless(-f "$PAGE.txt"){
		exit_message("page_not_found", $PAGE);
	}

	my $current_version = get_version($PAGE);
	my $version = $1 > 0 ? $1 : $current_version + ($1 < 0 ? $1 : -1);

	if($version >= $current_version || $version <= 0){
		exit_message("current_version", $PAGE, $current_version)
	}

	my $title = get_msg("differences", $PAGE, $version, $current_version);
	local $TITLE = $title;

	my $current_text = read_file("$PAGE.txt");

	my $text = $current_text;
	open FH, "$PAGE.txt.v"; local $/ = "\x00\n";
	while(<FH>){
		m/^([0-9]+):.*?\n(.*)\x00\n$/s;
		$text = patch($text, $2);
		last if($version == $1 - 1);
	}
	close FH;

	print_header();
	print qq(<div id="diff">\n<h1>$title</h1>\n);

	my @line0 = split /\n/, $text, -1; $#line0--;
	my @line1 = split /\n/, $current_text, -1; $#line1--;
	my ($s, @delta) = lcs(\@line0, \@line1);
	my $m = $s;
	my $n;
	for($n=0; $n<$s; $n++){
		$_ = $line1[$n];
		s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g;
		print qq(<div class="diff-unchanged">= $_</div>\n);
	}
	eval "use Encode qw(decode);";
	my $encode = $@ ? 0 : 1;
	for(my $i=0; $i<=$#delta; $i++,$m++,$n++){
		my ($x, $y) = split /,/, $delta[$i];
		if($x > $m && $y > $n){
			for(; $m<$x&&$n<$y; $m++,$n++){
				print qq(<div class="diff-modified">* );
				my $l0 = $line0[$m];
				my $l1 = $line1[$n];
				if($encode){
					$l0 = decode($CHARSET, $l0);
					$l1 = decode($CHARSET, $l1);
				}
				my @l0 = split //, $l0, -1; $#l0--;
				my @l1 = split //, $l1, -1; $#l1--;
				my ($is, @idelta) = lcs(\@l0, \@l1);
				my $im = $is;
				my $in;
				for($in=0; $in<$is; $in++){
					$_ = $l1[$in];
					s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g;
					print;
				}
				for(my $ii=0; $ii<=$#idelta; $ii++,$im++,$in++){
					my ($ix, $iy) = split /,/, $idelta[$ii];
					if($ix > $im){
						print qq(<span class="diff-modified-deleted">);
						$_ = "";
						for(; $im<$ix; $im++){
							$_ .= $l0[$im];
						}
						s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g;
						print qq($_</span>);
					}
					if($iy > $in){
						print qq(<span class="diff-modified-added">);
						$_ = "";
						for(; $in<$iy; $in++){
							$_ .= $l1[$in];
						}
						s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g;
						print qq($_</span>);
					}
					if($in <= $#l1){
						$_ = $l1[$in];
						s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g;
						print;
					}
				}
				for(; $in<=$#l1; $in++){
					$_ = $l1[$in];
					s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g;
					print;
				}
				print qq(</div>\n);
			}
		}
		if($x > $m){
			for(; $m<$x; $m++){
				$_ = $line0[$m];
				s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g;
				print qq(<div class="diff-deleted">- $_</div>\n);
			}
		}
		if($y > $n){
			for(; $n<$y; $n++){
				$_ = $line1[$n];
				s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g;
				print qq(<div class="diff-added">+ $_</div>\n);
			}
		}
		if($n <= $#line1){
			$_ = $line1[$n];
			s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g;
			print qq(<div class="diff-unchanged">= $_</div>\n);
		}
	}
	for(; $n<=$#line1; $n++){
		$_ = $line1[$n];
		s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g;
		print qq(<div class="diff-unchanged">= $_</div>\n);
	}

	print qq(</div>\n);
	print_footer();
	exit;
}elsif($QUERY_STRING =~ m/^ls(?:[&=].+)?$/){
#-------------------------------------------------------------------------------
# u?ls			List all pages in alphabetical order
# u?ls=az		List all pages in alphabetical order
# u?ls=za		List all pages in reverse order
# u?ls=taz		List all pages in alphabetical order of titles
# u?ls=tza		List all pages in reverse order of titles
# u?ls=rc		Recent changes
# u?ls=oc		Old changes
# u?ls&n=([0-9]+)	List only \1 pages in alphabetical order
# u?ls&title=1		Print page titles instead of page names
# u?ls&glob=GLOB	List all GLOB pages in alphabetical order
	my %var = get_var();
	my ($msg_id, $title);
	if($var{glob} eq ""){
		$msg_id = $var{ls} eq "rc" ? "recent_changes" :
			($var{ls} eq "oc" ? "old_changes" :
			($var{ls} eq "za" ? "all_pages_reversed" :
			"all_pages"));
		$title = get_msg($msg_id);
	}else{
		$msg_id = $var{ls} eq "rc" ? "recent_changes_matching" :
			($var{ls} eq "oc" ? "old_changes_matching" :
			($var{ls} eq "za" ? "all_pages_reversed_matching" :
			"all_pages_matching"));
		$title = get_msg($msg_id, $var{glob});
	}
	my $glob = $var{glob} eq "" ? "*" : $var{glob};

	local $TITLE = $title;
	print_header();
	print qq(<div id="ls">\n<h1>$title</h1>\n<ul>\n);

	my $tls = $var{ls} eq "taz" || $var{ls} eq "tza" ? 1 : 0;
	my $roc = $var{ls} eq "rc" || $var{ls} eq "oc" ? 1 : 0;
	my $n = $var{n} eq "" ? 0 : $var{n};
	my $i = 0;
	my @list;
	foreach(<$glob.txt>){
		next if(substr($_,0,1) eq "." || index($_,"/") >= 0 || !-f $_);
		s/\.txt$//;
		my $page = $_;
		my $title = $page;
		my @t = localtime((stat "$page.txt")[9]);
		my $time = sprintf "%d-%02d-%02d %02d:%02d:%02d",
			$t[5]+1900, $t[4]+1, $t[3], $t[2], $t[1], $t[0];
		if($tls || $var{title} eq "1"){
			my $text = read_file("$page.html");
			if($text ne ""){
				$text =~ s#<(script|style).*?</\1>##sgi;
				if($text =~ m#<h1[^>]*>(.+?)</h1>#si){
					$_ = $1;
					s/<[^>]*>//g; s/[<>]//g;
					$title = $_;
				}
			}
		}
		if($roc){
			if($var{title} eq "1"){
				$list[$i++] = "$time\x00$title\x00$page";
			}else{
				$list[$i++] = "$time\x00$page\x00$title";
			}
		}elsif($tls){
			$list[$i++] = "$title\x00$page\x00$time";
		}else{
			$list[$i++] = "$page\x00$title\x00$time";
		}
	}
	@list = sort @list;
	@list = reverse @list
		if($var{ls} eq "rc" || $var{ls} eq "za" || $var{ls} eq "tza");
	$n = $i if($n > $i || !$n);
	$i = 0;
	foreach(@list){
		my ($page, $title, $time);
		m/^(.*)\x00(.*)\x00(.*)$/;
		if($roc){
			if($var{title} eq "1"){
				$page = $3;
				$title = $2;
			}else{
				$page = $2;
				$title = $3;
			}
			$time = $1;
		}else{
			if($tls){
				$page = $2;
				$title = $var{title} eq "1" ? $1 : $page;
			}else{
				$page = $1;
				$title = $2;
			}
			$time = $3;
		}
		print qq(<li><a href="$page.html">$title</a> <span class="ls-time">$time</span></li>\n);
		last if(++$i == $n);
	}

	print qq(</ul>\n</div>\n);
	print_footer();
	exit;
}elsif($QUERY_STRING =~ m/^rss(?:[&=].+)?$/){
#-------------------------------------------------------------------------------
# u?rss			RSS for recent 10 pages
# u?rss=([0-9]+)	RSS for recent \1 pages
# u?rss&glob=GLOB	RSS for recent 10 GLOB pages
	my %var = get_var();
	my $glob = $var{glob} eq "" ? "*" : $var{glob};

	my $t = time;
	my @g = gmtime $t;
	my @l = localtime $t;
	my $g = $g[5]*31536000+$g[4]*2592000+$g[3]*86400+$g[2]*3600+$g[1]*60+
		$g[0];
	my $l = $l[5]*31536000+$l[4]*2592000+$l[3]*86400+$l[2]*3600+$l[1]*60+
		$l[0];
	my $i = 0;
	my @list;
	foreach(<$glob.txt>){
		next if(substr($_,0,1) eq "." || index($_,"/") >= 0 || !-f $_);
		s/\.txt$//;
		my $t = (stat "$_.txt")[9];
		my @t = split / +/, scalar gmtime($t);
		$list[$i++] = sprintf "%d %s, %02d %s %d %s GMT %s",
			$t, $t[0], $t[2], $t[1], $t[4], $t[3], $_;
	}
	my $n = 10;
	$n = $1 if($var{rss} =~ m/^([0-9]+)$/);
	$n = $i if($n > $i || !$n);
	(my $site_title = $SITE_TITLE) =~ s/<[^>]*>//g;
	(my $site_description = $SITE_DESCRIPTION) =~ s/<[^>]*>//g;
	print <<EOT;
Content-Type: text/xml

<?xml version="1.0" encoding="$CHARSET"?>
<rss version="2.0">
<channel>
<title>$site_title</title>
<link>$DOC_BASE</link>
<description>$site_description</description>
EOT
	undef $/;
	$i = 0;
	foreach(reverse sort @list){
		my ($time, $page) = m/^[0-9]+ (.+? GMT) (.*)$/;
		local *FH;
		open FH, "$page.html";
		my $text = <FH>;
		close FH;

		$text =~ s/\r//g;
		$text =~ s/^.*<!-- start text -->|<!-- end text -->.*$//sgi;

		my $has_more = ($text =~ s/<!-- more -->.*$//s);
		my $title;
		if($text =~ m#<h1[^>]*>(.+?)</h1>(.*)$#si){
			$title = $1;
			$text = $2;
			$title =~ s/<[^>]*>//g;
			$title =~ s/&[^ ]*;/ /g;
			$title =~ s/[ \t\n]+/ /g;
			$title =~ s/^ //;
			$title =~ s/ $//;
		}else{
			$title = $page;
		}
		$text =~ s#<(script|style).*?</\1>##sgi;
		$text =~ s/<[^>]*>//g;
		$text =~ s/&[^ ]*;/ /g;
		$text =~ s/[ \t\n]+/ /g;
		$text =~ s/^ //;
		$text =~ s/ $//;
		if($text =~ m/^((?:[^ ]+ ){20})/){
			$text = "$1...";
		}elsif($has_more){
			$text .= " ...";
		}
		print <<EOT;
<item>
<title>$title</title>
<link>$DOC_BASE/$page.html</link>
<description>$text</description>
<pubDate>$time</pubDate>
</item>
EOT
		last if(++$i == $n);
	}
	print <<EOT;
</channel>
</rss>
EOT
	exit;
}elsif($QUERY_STRING =~ m/^search(?:[&=].+)?$/){
#-------------------------------------------------------------------------------
# u?search=(.*)			Search using regular expressions
# u?search=(.*)&simple=1	Search using space separated words
# u?search=(.*)&icase=1		Case-insensitive search
# u?search=(.*)&link=1		Search for pages which link to \1 page
# u?search=(.*)&title=1		Print page titles instead of page names
# u?search=(.*)&nomatch=1	Don't print matches
# u?search=(.*)&glob=GLOB	Search GLOB pages
	my %var = get_var();
	if($var{search} eq ""){
		local $TITLE = get_msg("search_form");
		print_header();
		create_search_form(1);
		print_footer();
		exit;
	}

	my $glob = $var{glob} eq "" ? "*" : $var{glob};

	$_ = $var{search};
	if($var{simple} eq "1"){
		s/[<>\r]//g; s/[\t\n]/ /g; s/ +/ /g; s/^ //; s/ $//;
		$_ = quotemeta;
		s/\\ />/g;
		s/\\"([^"]*)\\"/\x01$1\x02/g;
		while(s/\x01([^\x02]*)>([^\x02]*)\x02/\x01$1 +$2\x02/g){}
		s/[\x01\x02]//g; s/\\"//g;
	}
	my @search = split />/;

	$_ = $var{search};
	s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g;
	my $query = $_;
	my $title;
	if($var{glob} eq ""){
		$title = get_msg("search", $query);
	}else{
		$title = get_msg("search_matching", $var{glob}, $query);
	}

	local $TITLE = $title;
	print_header();
	print qq(<div id="search">\n<h1>$title</h1>\n);

	foreach(<$glob.html>){
		next if(substr($_,0,1) eq "." || index($_,"/") >= 0 || !-f $_);
		s/\.html$//;
		my $page = $query = $_;

		my $text = read_file("$page.html");
		next if($text eq "");

		$text =~ s/^.*<!-- start text -->|<!-- end text -->.*$//sgi;
		$text =~ s#<(script|style).*?</\1>##sgi;

		if($var{title} eq "1" && $text =~ m#<h1[^>]*>(.+?)</h1>#si){
			$_ = $1;
			s/<[^>]*>//g; s/[<>]//g;
			$query = $_;
		}
		my ($i, $line, $search, $found, @found, @result);
		if($var{link} eq "1"){
			foreach(split /\n/, $text){
				$line = $_;
				$found = "";
				for($i=0; $i<=$#search; $i++){
					$search = $search[$i];
					$search = "(?i)$search"
						if($var{icase} eq "1");
					if($line =~ m#<[aA][ \t][^>]*(?:href|HREF)[ \t]*=[ \t]*"(?:$search)"[^>]*>[^<]+</[aA]>#){
						$found = $line if($found eq "");
						$found =~ s#<[aA][ \t][^>]*(?:href|HREF)[ \t]*=[ \t]*"(?:$search)"[^>]*>([^<]+)</[aA]>#\x01$1\x02#g;
						$found[$i] = 1;
					}
				}
				if($found ne ""){
					$_ = $found;
					s/<[^>]*>//g; s/<.*$//; s/^.*>//;
					push @result, $_;
				}
			}
		}else{
			$text =~ s/<[^>]*>//g; $text =~ s/[<>]//g;
			foreach(split /\n/, $text){
				$line = $_;
				$found = "";
				for($i=0; $i<=$#search; $i++){
					$search = $search[$i];
					$search = "(?i)$search"
						if($var{icase} eq "1");
					if($line =~ m#$search#){
						$found = $line if($found eq "");
						$found =~ s#($search)#\x01$1\x02#g;
						$found[$i] = 1;
					}
				}
				push @result, $found if($found ne "");
			}
		}
		for($i=0; $i<=$#search; $i++){
			last if(!$found[$i]);
		}
		next if($i <= $#search);
		if($var{nomatch} eq "1"){
			print qq(<div><a href="$page.html">$query</a></div>\n);
			next;
		}
		foreach(@result){
			s#\x01#<span class="search-highlight">#g;
			s#\x02#</span>#g;
			print qq(<div><a href="$page.html">$query</a>: $_</div>\n);
		}
	}

	print qq(</div>\n);
	print_footer();
	exit;
}elsif($QUERY_STRING =~ m/^comment(?:[&=].+)?$/){
#-------------------------------------------------------------------------------
# u/PAGE?comment			Generate the comment form for PAGE
#					(id=comment, down, rows=80, cols=6)
# u/PAGE?comment&direction=(up|down)	Generate the comment form for PAGE
#					(id=comment, (up|down), rows=80, cols=6)
# u/PAGE?comment&rows=([0-9]+)		Generate the comment form for PAGE
#					(id=comment, down, rows=\1, cols=6)
# u/PAGE?comment&cols=([0-9]+)		Generate the comment form for PAGE
#					(id=comment, down, rows=80, cols=\1)
# u/PAGE?comment=COMMENT		Generate the comment form for PAGE
#					(id=COMMENT, down, rows=80, cols=6)
# u?comment&page=PAGE			Generate the comment form for PAGE
#					(id=comment, down, rows=80, cols=6)
	my %var = get_var();
	if($REQUEST_METHOD eq "GET"){
		$PAGE = $var{page} if($var{page} ne "");
		if($PAGE eq ""){
			exit_message("specify_comment_page");
		}elsif(!-f "$PAGE.txt"){
			exit_message("page_not_found", $PAGE);
		}

		local $TITLE = get_msg("comment_form");
		print_header();
		create_comment_form($PAGE, $var{comment}, $var{direction},
			$var{rows}, $var{cols}, 1);
		print_footer();
		exit;
	}
	exit_rebuild($var{page}) unless(verify_input_data("comment", \%var));

	$PAGE = $var{page};
	exit_message("page_not_found", $PAGE) unless(-f "$PAGE.txt");

	exit_message("invalid_comment_tag", $var{comment})
		unless($var{comment} =~ m/^[a-zA-Z0-9_-]+$/);

	$var{text} = escape_comment($var{text});

	my $TEXT = "";
	my $time = format_time(time);
	my $added = 0;

	lock_file("$PAGE.txt");
	local *FH;
	if(open FH, "$PAGE.txt"){
		while(<FH>){
			if(m/^#%$var{comment}$/){
				if($var{direction} eq "up"){
					$TEXT .= "$_#%$time\n$var{text}\n\n";
				}else{
					$TEXT .= "#%$time\n$var{text}\n\n$_";
				}
				$added = 1;
			}else{
				$TEXT .= $_;
			}
		}
		close FH;
	}
	exit_message("comment_tag_not_found", "#%$var{comment}") unless($added);
	save($PAGE, $TEXT);
	unlock_file("$PAGE.txt");
}elsif($QUERY_STRING =~ m/^wiki_/){
#-------------------------------------------------------------------------------
# Uniqki Wiki
	unless(has_write_access()){
		my $msg_id;
		if($wiki){
			if(-f "$PAGE.txt"){
				$msg_id = "not_allowed_to_edit_wiki_page";
			}else{
				$msg_id = "not_allowed_to_create_wiki_page";
			}
		}else{
			if(-f "$PAGE.txt"){
				$msg_id = "not_wiki_page";
			}else{
				$msg_id = "not_allowed_to_create_nonwiki_page";
			}
		}
		exit_message($msg_id, $PAGE);
	}
	if($REQUEST_METHOD eq "GET"){
		if($QUERY_STRING =~ m/^wiki_edit(?:=(-?[0-9]+))?$/){
#-------------------------------------------------------------------------------
# u/PAGE?wiki_edit		Create/edit PAGE
# u/PAGE?wiki_edit=([0-9]+)	Edit the version \1 of PAGE
# u/PAGE?wiki_edit=-([0-9]+)	Edit the current-\1 version of PAGE
			if($1 ne "" && !-f "$PAGE.txt"){
				exit_message("page_not_found", $PAGE);
			}

			local $TITLE = $PAGE;
			local $TEXT = "";
			local $VERSION = get_version($PAGE);

			if($1 eq "" && -f "$PAGE.txt"){
				$TEXT = read_file("$PAGE.txt");
				chomp $TEXT;
				if("#!wiki\n" ne substr $TEXT, 0, 7){
					exit_message("internal_errors");
				}

				$TEXT = substr $TEXT, 7;
				$TEXT =~ s/&/&amp;/g;
				$TEXT =~ s/</&lt;/g;
				$TEXT =~ s/>/&gt;/g;
			}elsif($1 ne ""){
				local *FH;

				my $version = $1 > 0 ? $1 : $VERSION + $1;

				$TEXT = read_file("$PAGE.txt");
				if("#!wiki\n" ne substr $TEXT, 0, 7){
					exit_message("internal_errors");
				}

				if($version >= $VERSION || $version <= 0){
					exit_message("current_version", $PAGE,
						$version);
				}

				open FH, "$PAGE.txt.v"; local $/ = "\x00\n";
				while(<FH>){
					m/^([0-9]+):.*?\n(.*)\x00\n$/s;
					$TEXT = patch($TEXT, $2);
					last if($version == $1 - 1);
				}
				close FH;
				if("#!wiki\n" ne substr $TEXT, 0, 7){
					# Previous version was not a wiki page
					exit_message("not_wiki_page", $PAGE);
				}

				$TEXT = substr $TEXT, 7;
				$TEXT =~ s/&/&amp;/g;
				$TEXT =~ s/</&lt;/g;
				$TEXT =~ s/>/&gt;/g;
				chomp $TEXT;
			}
			$VERSION++;
			print_wiki_edit();
		}
		exit;
	}

	my %var = get_var();
	exit_rebuild($PAGE) unless(verify_input_data($QUERY_STRING, \%var));

	local *FH;
	my $t = time;
	if($QUERY_STRING eq "wiki_upload"){
#-------------------------------------------------------------------------------
# Wiki upload
		exit if($WIKI_ALLOWED_FILES eq "" || !-f "$PAGE.txt" ||
			$var{file} eq "" ||
			$var{file} !~ m/$WIKI_ALLOWED_FILES/oi);

		open FH, "$PAGE.txt";
		if(<FH> ne "#!wiki\n"){
			close FH;
			exit_message("internal_errors");
		}
		close FH;

		mkdir $PAGE, 0755 if(!-d $PAGE);
		write_file("$PAGE/$t.$var{file}", $var{"file="});
		chmod 0755, "$PAGE/$t.$var{file}" if($hosting eq "awardspace");
		exit_message("wiki_file_uploaded", $var{file}, "$t.$var{file}");
	}
	if(-f "$PAGE.txt"){
		open FH, "$PAGE.txt";
		if(<FH> ne "#!wiki\n"){
			close FH;
			exit_message("internal_errors");
		}
		close FH;
	}

	local $VERSION = $var{version};
	local $TEXT = $var{text};
	if($VERSION != get_version($PAGE) + 1){
		print_updated();
		exit;
	}
	if($var{file} ne "" && $var{file} =~ m/$WIKI_ALLOWED_FILES/oi){
		mkdir $PAGE, 0755 if(!-d $PAGE);
		write_file("$PAGE/$t.$var{file}", $var{"file="});
		chmod 0755, "$PAGE/$t.$var{file}" if($hosting eq "awardspace");
		if($var{preview} eq ""){
			(my $f = $var{file}) =~ s/ /%20/g;
			$TEXT .= "\n[$PAGE/$t.$f $var{file}]";
		}
	}
	if($var{preview} ne ""){
		my $uploaded;
		if($var{file} ne "" && -f "$PAGE/$t.$var{file}"){
			$uploaded = get_msg("wiki_file_uploaded", $var{file},
				"$t.$var{file}");
		}

		preview($PAGE, $TEXT, $uploaded, 1);
		exit;
	}

	lock_file("$PAGE.txt");
	save($PAGE, "#!wiki\n$TEXT\n");
	unlock_file("$PAGE.txt");
}elsif(!$admin){
################################################################################
# Admin actions
	exit_message("admin_actions_not_allowed");
}elsif($insecure_pw){
#-------------------------------------------------------------------------------
# Admin password is still temporary. No admin actions are allowed other than
# changing the password.
	exit_message("change_admin_password");
}elsif($QUERY_STRING eq "manage_pages"){
#-------------------------------------------------------------------------------
# u?manage_pages	Manage pages
# u/PAGE?manage_pages	Manage pages
	print_manage_pages();
	exit;
}elsif($QUERY_STRING eq "backup"){
#-------------------------------------------------------------------------------
# u?backup		Backup all pages
# u/PAGE?backup		Backup PAGE
	eval "use Archive::Zip;";
	exit_message("perl_module_not_installed", "Archive::Zip") if($@);

	my $zip = Archive::Zip->new();
	my $file;
	if($PAGE eq ""){
		$file = "uniqki.zip";
		$zip->addTree(".");
	}else{
		$file = "$PAGE.zip";
		foreach("txt", "txt.v", "html"){
			$zip->addFile("$PAGE.$_") if(-f "$PAGE.$_");
		}
		$zip->addTree($PAGE, $PAGE) if(-d $PAGE);
	}
	print <<EOT;
Content-Type: application/zip
Content-Disposition: attachment; filename="$file"

EOT
	$zip->writeToFileHandle(*STDOUT);
	exit;
}elsif($QUERY_STRING eq "restore"){
#-------------------------------------------------------------------------------
# u?restore		Restore
# u/PAGE?restore	Restore
	eval "use Archive::Zip;";
	exit_message("perl_module_not_installed", "Archive::Zip") if($@);

	my $boundary = <STDIN>;
	my $file = <STDIN>; my $tmp = $file.<STDIN>.<STDIN>;
	$file =~ s#^.*?filename="(.*?)".*$#$1#s; $file =~ s#^.*[/\\]##;
	my $length = $CONTENT_LENGTH - length($tmp) - 2 *
		length($boundary) - 4;
	read STDIN, my $content, $length;
	my ($fh, $name) = Archive::Zip::tempFile(".");
	print $fh $content;
	my $zip = Archive::Zip->new();
	$zip->readFromFileHandle($fh);
	(my $cgi = $CGI) =~ s#^(?:/~[^/]+)?/##;
	$zip->removeMember($cgi);
	$zip->removeMember($PASSWORD_FILE);
	foreach($zip->memberNames()){
		$zip->removeMember($_) if(-f $_ && !-w $_);
		if($hosting eq "awardspace" &&
			(m#\.html$# || m#/#)){
			my $member = $zip->memberNamed($_);
			$member->unixFileAttributes(0755);
		}
	}
	$zip->extractTree();
	close $fh;
	unlink $name;

	if($hosting eq "awardspace"){
		foreach($zip->memberNames()){
			chmod 0755, $_ if(m#\.html$# || m#/#);
		}
	}

	exit_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE?manage_pages");
}elsif($QUERY_STRING =~ m/^refresh(?:&.+)?$/){
#-------------------------------------------------------------------------------
# u?refresh		Refresh all
# u?refresh&glob=GLOB	Refresh GLOB pages
	my %var = get_var();
	my $glob = $var{glob};
	my $title = $glob eq "" ? get_msg("refresh_pages") :
		get_msg("refresh_pages_matching", $glob);

	local $TITLE = $title;
	print_header();
	print qq(<div id="ls">\n<h1>$title</h1>\n<ul>\n);
	foreach($glob eq "" ? (<.*.txt>, <*.txt>) : <$glob.txt>){
		next if(index($_, "/") >= 0 || !-f $_);
		s/\.txt$//;
		$PAGE = $_;
		make_html($PAGE);
		undef $begin_parsing;
		undef $parse_line;
		undef $end_parsing;
		print qq(<li><a href="$PAGE.html">$PAGE</a></li>\n);
	}
	print qq(</ul>\n</div>\n);
	print_footer();
	exit;
}elsif($QUERY_STRING eq "manage_users"){
#-------------------------------------------------------------------------------
# u?manage_users	Manage users
# u/PAGE?manage_users	Manage users
	print_manage_users();
	exit;
}elsif($QUERY_STRING eq "add_user" && $REQUEST_METHOD eq "POST"){
#-------------------------------------------------------------------------------
# u?add_user		Add user
# u/PAGE?add_user	Add user
	my %var = get_var();
	if($var{user} eq ""){
		exit_message("enter_username");
	}
	if(!is_username($var{user})){
		exit_message("check_username");
	}
	if($var{user} eq $USER){
		exit_message("cannot_add_yourself");
	}
	if($var{email} eq ""){
		exit_message("enter_email_address");
	}
	if(!is_email_address($var{email})){
		exit_message("check_email_address");
	}
	if($var{name} eq ""){
		exit_message("enter_full_name");
	}
	if(!is_full_name($var{name})){
		exit_message("check_full_name");
	}
	if($var{pw} ne $var{pw2}){
		exit_message("confirm_password");
	}
	if($var{pw} ne "" && !is_password($var{pw})){
		exit_message("check_password");
	}

	(my $escaped_email = $var{email}) =~ s/\./\\./g;
	my $new_pw = "";

	lock_file($PASSWORD_FILE);
	if(-f $PASSWORD_FILE){
		local *FH;
		open FH, $PASSWORD_FILE;
		while(<FH>){
			if(m/^$var{user}:/){
				close FH;
				exit_message("user_already_exists", $var{user});
			}
			if(m/:$escaped_email(?::[^:]*){2}$/i){
				close FH;
				exit_message("email_address_already_registered",
					$var{email});
			}
			$new_pw .= $_;
		}
		close FH;
	}elsif($adminpw =~ m/:$escaped_email(?::[^:]*){2}$/i){
		exit_message("email_address_already_registered", $var{email});
	}else{
		$new_pw = "$adminpw\n";
	}

	# Add a new user if user was not found
	my $group = $var{admin} eq "yes" ? "admin" : "user";
	my $pw;
	my $token;
	if($var{pw} eq ""){
		$pw = "reset";
		$token = generate_password_set_token($var{user});

		my $link = "$HTTP_BASE$SCRIPT_NAME?reset_password=$token";
		my $subject = get_msg("new_user_email_subject", $DOC_BASE);
		my $text = get_msg("new_user_email_text", $var{user}, $DOC_BASE,
			$link, $SET_PASSWORD_TIMEOUT);
		if(!send_email($var{email}, $subject, $text)){
			exit_message("email_notification_failed", $var{user},
				$var{email});
		}
	}else{
		$pw = hash_password($var{user}, $var{pw});
		$token = "";
	}
	$new_pw .= "$var{user}:$pw:$group:$var{email}:$var{name}:$token\n";

	write_file($PASSWORD_FILE, $new_pw);
	unlock_file($PASSWORD_FILE);

	exit_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE?manage_users");
}elsif($QUERY_STRING eq "update_user" && $REQUEST_METHOD eq "POST"){
#-------------------------------------------------------------------------------
# u?update_user		Update user
# u/PAGE?update_user	Update user
	my %var = get_var();
	if($var{user} eq ""){
		exit_message("enter_username");
	}
	if(!is_username($var{user})){
		exit_message("check_username");
	}
	if($var{name} ne "" && !is_full_name($var{name})){
		exit_message("check_full_name");
	}
	if($var{pw} ne $var{pw2}){
		exit_message("confirm_password");
	}
	if($var{pw} ne "" && !is_password($var{pw})){
		exit_message("check_password");
	}
	if($var{pw} eq "" && $var{email} eq "" &&
		$var{admin} ne "yes" && $var{admin} ne "no"){
		exit_message("enter_user_info_to_update");
	}

	my $new_pw = "";
	my $updated = 0;

	lock_file($PASSWORD_FILE);
	if(-f $PASSWORD_FILE){
		local *FH;
		open FH, $PASSWORD_FILE;
		while(<FH>){
			if(m/^$var{user}:/){
				$updated = 1;
				my @items = split /:/;
				my $pw = $var{pw} ne "" ?
					hash_password($var{user}, $var{pw}) :
					$items[1];
				my $group = $var{admin} eq "yes" ? "admin" :
					($var{admin} eq "no" ? "user" :
						$items[2]);
				my $email = $var{email} ne "" ?
					$var{email} : $items[3];
				my $name = $var{name} ne "" ?
					$var{name} : $items[4];
				my $token = $items[5];
				# new line from $items[5]
				my $userline = "$var{user}:$pw:$group:$email:$name:$token";
				if($userline eq $_){
					close FH;
					exit_message("enter_user_info_to_update", $var{user});
				}
				$_ = $userline;
			}
			$new_pw .= $_;
		}
		close FH;
	}else{
		my @items = split /:/, $adminpw;
		if($var{user} ne $items[0]){
			# Something's wrong because you're the only user, but
			# the user line in this script is not you! How did you
			# login?
			exit_message("internal_errors");
		}

		$updated = 1;
		my $pw = $var{pw} ne "" ? hash_password($var{user}, $var{pw}) :
			$items[1];
		my $group = $var{admin} eq "yes" ? "admin" :
			($var{admin} eq "no" ? "user" : $items[2]);
		my $email = $var{email} ne "" ? $var{email} : $items[3];
		my $name = $var{name} ne "" ? $var{name} : $items[4];
		my $token = $items[5];
		# new line from $items[5]
		my $userline = "$var{user}:$pw:$group:$email:$name:$token";
		if($userline eq $adminpw){
			exit_message("enter_user_info_to_update", $var{user});
		}
		$new_pw = "$userline\n";
	}
	exit_message("user_not_found", $var{user}) unless($updated);

	write_file($PASSWORD_FILE, $new_pw);
	unlock_file($PASSWORD_FILE);

	exit_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE?manage_users");
}elsif($QUERY_STRING eq "block_user" && $REQUEST_METHOD eq "POST"){
#-------------------------------------------------------------------------------
# u?block_user		Block user
# u/PAGE?block_user	Block user
	my %var = get_var();
	if($var{user} eq ""){
		exit_message("enter_username");
	}
	if(!is_username($var{user})){
		exit_message("check_username");
	}
	if($var{user} eq $USER){
		exit_message("cannot_block_yourself");
	}

	my $new_pw = "";
	my $blocked = 0;

	lock_file($PASSWORD_FILE);
	if(-f $PASSWORD_FILE){
		local *FH;
		open FH, $PASSWORD_FILE;
		while(<FH>){
			if(m/^$var{user}:/){
				my @items = split /:/;
				if($items[1] eq "blocked"){
					close FH;
					exit_message("user_already_blocked",
						$var{user});
				}
				$blocked = 1;
				clear_user_sessions($var{user});
				$_ = "$var{user}:blocked:$items[2]:$items[3]:$items[4]:\n";
			}
			$new_pw .= $_;
		}
		close FH;
	}
	exit_message("user_not_found", $var{user}) unless($blocked);

	write_file($PASSWORD_FILE, $new_pw);
	unlock_file($PASSWORD_FILE);

	exit_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE?manage_users");
}elsif($QUERY_STRING eq "unblock_user" && $REQUEST_METHOD eq "POST"){
#-------------------------------------------------------------------------------
# u?unblock_user	Unblock user
# u/PAGE?unblock_user	Unblock user
	my %var = get_var();
	if($var{user} eq ""){
		exit_message("enter_username");
	}
	if(!is_username($var{user})){
		exit_message("check_username");
	}
	if($var{user} eq $USER){
		exit_message("cannot_unblock_yourself");
	}

	if($var{pw} ne $var{pw2}){
		exit_message("confirm_password");
	}
	if($var{pw} ne "" && !is_password($var{pw})){
		exit_message("check_password");
	}

	my $new_pw = "";
	my $unblocked = 0;
	my $token = "";

	lock_file($PASSWORD_FILE);
	if(-f $PASSWORD_FILE){
		local *FH;
		open FH, $PASSWORD_FILE;
		while(<FH>){
			if(m/^$var{user}:/){
				my @items = split /:/;
				if($items[1] ne "blocked"){
					close FH;
					exit_message("user_already_unblocked",
						$var{user});
				}
				$unblocked = 1;
				my $pw;
				if($var{pw} eq ""){
					$pw = "reset";
					$token = generate_password_set_token($var{user});
				}else{
					$pw = hash_password($var{user},
						$var{pw});
					$token = "";
				}
				$_ = "$var{user}:$pw:$items[2]:$items[3]:$items[4]:$token\n";
			}
			$new_pw .= $_;
		}
		close FH;
	}
	exit_message("user_not_found", $var{user}) unless($unblocked);

	if($token ne ""){
		my $link = "$HTTP_BASE$SCRIPT_NAME?reset_password=$token";
		my $subject = get_msg("unblocked_user_email_subject",
			$DOC_BASE);
		my $text = get_msg("unblocked_user_email_text", $var{user},
			$DOC_BASE, $link, $SET_PASSWORD_TIMEOUT);
		if(!send_email($var{email}, $subject, $text)){
			exit_message("email_notification_failed", $var{user},
				$var{email});
		}
	}

	write_file($PASSWORD_FILE, $new_pw);
	unlock_file($PASSWORD_FILE);

	exit_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE?manage_users");
}elsif($QUERY_STRING eq "delete_user" && $REQUEST_METHOD eq "POST"){
#-------------------------------------------------------------------------------
# u?delete_user		Delete user
# u/PAGE?delete_user	Delete user
	my %var = get_var();
	if($var{user} eq ""){
		exit_message("enter_username");
	}
	if(!is_username($var{user})){
		exit_message("check_username");
	}
	if($var{user} eq $USER){
		exit_message("cannot_delete_yourself");
	}

	my $new_pw = "";
	my $deleted = 0;

	lock_file($PASSWORD_FILE);
	if(-f $PASSWORD_FILE){
		local *FH;
		open FH, $PASSWORD_FILE;
		while(<FH>){
			if(m/^$var{user}:/){
				$deleted = 1;
				clear_user_sessions($var{user});
				next;
			}
			$new_pw .= $_;
		}
		close FH;
	}
	exit_message("user_not_found", $var{user}) unless($deleted);

	write_file($PASSWORD_FILE, $new_pw);
	unlock_file($PASSWORD_FILE);

	exit_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE?manage_users");
}elsif($QUERY_STRING eq "install_password"){
#-------------------------------------------------------------------------------
# u?install_password		Install the password file, but don't overwrite
# u/PAGE?install_password	Install the password file, but don't overwrite
	write_pw();
	exit_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE");
}elsif($QUERY_STRING eq "install_config"){
#-------------------------------------------------------------------------------
# u?install_config	Install the config file, but don't overwrite
# u/PAGE?install_config	Install the config file, but don't overwrite
	process_cfg(1);
	exit_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE");
}elsif($QUERY_STRING eq "install_messages"){
#-------------------------------------------------------------------------------
# u?install_messages		Install the messages file, but don't overwrite
# u/PAGE?install_messages	Install the messages file, but don't overwrite
	process_msg(1);
	exit_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE");
}elsif($QUERY_STRING eq "install_template"){
#-------------------------------------------------------------------------------
# u?install_template		Install the template files, but don't overwrite
# u/PAGE?install_template	Install the template files, but don't overwrite
	if($TEMPLATE_DIRECTORY ne ""){
		mkdir $TEMPLATE_DIRECTORY, 0755 unless(-d $TEMPLATE_DIRECTORY);
		print_header(1);
		print_footer(1);
		print_login(1);
		print_manage_pages(1);
		print_manage_users(1);
		print_manage_myself(1);
		print_forgot_password(1);
		print_reset_password(1);
		print_message(1);
		print_view(1);
		print_edit(1);
		print_preview(1);
		print_updated(1);
		print_wiki_view(1);
		print_wiki_edit(1);
		print_wiki_preview(1);
		print_css(1);
		print_js(1);
	}
	exit_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE");
}elsif($PAGE eq ""){
#-------------------------------------------------------------------------------
# u?ACTION		Redirect to index
	exit_redirect("$HTTP_BASE$SCRIPT_NAME/$INDEX_PAGE");
}elsif($QUERY_STRING eq "upload"){
#-------------------------------------------------------------------------------
# u/PAGE?upload		Upload PAGE/FILE
	my %var = get_var();
	exit_rebuild($PAGE) unless(verify_input_data("upload", \%var));

	if($var{file} ne ""){
		mkdir $PAGE, 0755 if(!-d $PAGE);
		write_file("$PAGE/$var{file}", $var{"file="});
		chmod 0755, "$PAGE/$var{file}" if($hosting eq "awardspace");
		$rebuild = 1;
	}
}elsif($QUERY_STRING eq "delete" && $FILE ne ""){
#-------------------------------------------------------------------------------
# u/PAGE/FILE?delete	Delete PAGE/FILE
	my $dir = "";
	if(unlink "$PAGE/$FILE"){
		$dir = "$PAGE/$FILE"; $dir =~ s#/[^/]+$##;
	}elsif(-d "$PAGE/$FILE"){
		$dir = "$PAGE/$FILE";
	}
	if($dir ne ""){
		while(index($dir, "/") >= 0){
			rmdir $dir;
			$dir =~ s#/[^/]*$##;
		}
		rmdir $dir;
	}
	$rebuild = 1;
}elsif($QUERY_STRING =~ m/^edit(?:=(-?[0-9]+))?$/){
#-------------------------------------------------------------------------------
# u/PAGE?edit		Create/edit PAGE
# u/PAGE?edit=([0-9]+)	Edit the version \1 of PAGE
# u/PAGE?edit=-([0-9]+)	Edit the current-\1 version of PAGE
	local $TITLE = $PAGE;
	local ($VERSION, $TEXT);
	if($REQUEST_METHOD eq "GET"){
		$VERSION = get_version($PAGE);
		my $version = $1 > 0 ? $1 : $VERSION + $1;
		$TEXT = read_file("$PAGE.txt");
		if($TEXT ne ""){
			if($version > 0 && $version < $VERSION){
				local *FH;
				open FH, "$PAGE.txt.v"; local $/ = "\x00\n";
				while(<FH>){
					m/^([0-9]+):.*?\n(.*)\x00\n$/s;
					$TEXT = patch($TEXT, $2);
					last if($version == $1 - 1);
				}
				close FH;
			}
		}
		$VERSION++;
		if($TEXT ne ""){
			$TEXT =~ s/&/&amp;/g;
			$TEXT =~ s/</&lt;/g;
			$TEXT =~ s/>/&gt;/g;
			chomp $TEXT;
		}
		print_edit();
		exit;
	}

	my %var = get_var();
	exit_rebuild($PAGE) unless(verify_input_data("edit", \%var));

	$VERSION = $var{version};
	$TEXT = $var{text};
	if($VERSION != get_version($PAGE) + 1){
		print_updated();
		exit;
	}
	if($var{file} ne ""){
		mkdir $PAGE, 0755 if(!-d $PAGE);
		write_file("$PAGE/$var{file}", $var{"file="});
		chmod 0755, "$PAGE/$var{file}" if($hosting eq "awardspace");
	}
	if($var{preview} ne ""){
		my $uploaded;
		if($var{file} ne "" && -f "$PAGE/$var{file}"){
			$uploaded = get_msg("file_uploaded", $var{file});
		}

		preview($PAGE, $TEXT, $uploaded, 0);
		exit;
	}
	lock_file("$PAGE.txt");
	save($PAGE, "$TEXT\n");
	unlock_file("$PAGE.txt");
}elsif($QUERY_STRING =~ m/^revert(?:=(-?[0-9]+))?$/){
#-------------------------------------------------------------------------------
# u/PAGE?revert			Go back to the previous version of PAGE
# u/PAGE?revert=([0-9]+)	Go back to the \1 version of PAGE
# u/PAGE?revert=-([0-9]+)	Go back to the current-\1 version of PAGE
	unless(-f "$PAGE.txt"){
		exit_message("page_not_found", $PAGE);
	}

	lock_file("$PAGE.txt");
	my $current_version = get_version($PAGE);
	my $version = $1 > 0 ? $1 : $current_version + ($1 < 0 ? $1 : -1);
	if($version > 0 && $version < $current_version){
		local *FH;
		my $text = read_file("$PAGE.txt");
		open FH, "$PAGE.txt.v"; local $/ = "\x00\n";
		while(<FH>){
			m/^([0-9]+):.*?\n(.*)\x00\n$/s;
			$text = patch($text, $2);
			if($version == $1 - 1){
				$rebuild = 1;
				last;
			}
		}
		if($rebuild){
			local $/ = "\n";
			my $line = <FH>;
			my @items = split /:/, $line;
			my $time = $items[2];

			local $/ = undef;
			my $txtv = $line.<FH>;
			close FH;

			write_file("$PAGE.txt.v", $txtv);
			write_file("$PAGE.txt", $text);
			utime $time, $time, "$PAGE.txt";
		}else{
			close FH;
		}
	}
	unlock_file("$PAGE.txt");
}elsif($QUERY_STRING eq "delete"){
#-------------------------------------------------------------------------------
# u/PAGE?delete		Delete PAGE
	unlink "$PAGE.txt", "$PAGE.txt.v", "$PAGE.html";
	rmrf($PAGE);
	$PAGE = $INDEX_PAGE;
}

#-------------------------------------------------------------------------------
# Rebuild, if requested, and redirect
make_html($PAGE) if($rebuild);

if($nonwiki_read_access ne "open" || $wiki_read_access ne "open"){
	exit_redirect("$HTTP_BASE$SCRIPT_NAME/$PAGE") if($QUERY_STRING ne "");
	exit_message("page_not_found", $PAGE) unless(-f "$PAGE.html");

	local *FH;
	start_html();
	open FH, "$PAGE.html";
	print <FH>;
	close FH;
	exit;
}

exit_redirect("$DOC_BASE/$PAGE.html");
